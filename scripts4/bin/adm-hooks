#!/usr/bin/env bash
# adm-hooks — gerenciamento e execução segura de hooks para ADM
# Local: /usr/src/adm/bin/adm-hooks
set -Eeuo pipefail
IFS=$'\n\t'

# Exit codes
ADM_OK=0
ADM_ERR_USAGE=80
ADM_ERR_INTERNAL=99
ADM_ERR_PERMISSION=70
ADM_ERR_HOOK=60

# Paths (configurable via env)
ADM_ROOT_DEFAULT="/usr/src/adm"
ADM_ROOT="${ADM_ROOT:-$ADM_ROOT_DEFAULT}"
LOGGER="${ADM_ROOT}/bin/adm-logger"
HOOKS_DIR="${ADM_ROOT}/hooks"
METAFILE_DIR="${ADM_ROOT}/metafile"
STATE_DIR="${ADM_ROOT}/var/state/hooks"
HISTORY_FILE="${STATE_DIR}/history.log"
TMP_BASE="${ADM_ROOT}/.tmp/hooks"
EXEC_ID="$(date -u +%Y%m%d-%H%M%S)-$$"

# load logger (fallback minimal)
if [[ -f "$LOGGER" ]]; then
  # shellcheck source=/usr/src/adm/bin/adm-logger
  source "$LOGGER"
else
  log_start(){ :; }
  log_info(){ printf '[INFO] %s\n' "$*"; }
  log_ok(){ printf '[OK] %s\n' "$*"; }
  log_warn(){ printf '[WARN] %s\n' "$*"; }
  log_err(){ printf '[ERR] %s\n' "$*"; }
  log_end(){ :; }
  log_set_phase(){ :; }
  log_set_subject(){ :; }
fi

# helpers
_ensure_dirs() {
  mkdir -p "$HOOKS_DIR" "$METAFILE_DIR" "$STATE_DIR" "$TMP_BASE"
}
_safe_path() {
  local p; p="$(readlink -f "$1" 2>/dev/null || true)"
  [[ -n "$p" ]] || return 1
  case "$p" in
    "$ADM_ROOT"/*|"$ADM_ROOT") printf '%s' "$p"; return 0;;
    *) return 1;;
  esac
}
_tmpdir() {
  local d="${TMP_BASE}/run-${EXEC_ID}"
  mkdir -p "$d"
  printf '%s' "$d"
}
_validate_hook_name() {
  # allow letters, numbers, -, _
  [[ "$1" =~ ^[a-zA-Z0-9_.-]+$ ]]
}
_is_executable() { [[ -x "$1" && -f "$1" ]]; }

# find hooks: precedence global -> metafile/<cat>/<prog>/hooks
_find_hooks_for() {
  # args: phase category program
  local phase="$1" category="$2" program="$3"
  local hooks_list=()
  local global="${HOOKS_DIR%/}/${phase}.sh"
  if _is_executable "$global" && [[ ! -f "${global}.disabled" ]]; then hooks_list+=("$global"); fi
  # metafile-specific
  if [[ -n "$category" && -n "$program" ]]; then
    local dir="${METAFILE_DIR%/}/${category}/${program}/hooks"
    if [[ -d "$dir" ]]; then
      # prefer exact file name <phase>.sh then any *.d/*.sh in lexical order
      if [[ -f "${dir%/}/${phase}.sh" && -x "${dir%/}/${phase}.sh" && ! -f "${dir%/}/${phase}.sh.disabled" ]]; then
        hooks_list+=("${dir%/}/${phase}.sh")
      fi
      if [[ -d "${dir%/}/${phase}.d" ]]; then
        while IFS= read -r f; do
          [[ -x "$f" ]] || continue
          [[ -f "${f}.disabled" ]] && continue
          hooks_list+=("$f")
        done < <(find "${dir%/}/${phase}.d" -maxdepth 1 -type f -name '*.sh' | sort)
      fi
    fi
  fi
  printf '%s\n' "${hooks_list[@]:-}" 
}

# record history (JSONL)
_record_history() {
  local phase="$1" category="$2" program="$3" hook="$4" result="$5" elapsed="$6" msg="$7"
  mkdir -p "$(dirname "$HISTORY_FILE")"
  printf '{"ts":"%s","exec":"%s","phase":"%s","target":"%s/%s","hook":"%s","result":"%s","elapsed":%s,"msg":"%s"}\n' \
    "$(date -u +%Y-%m-%dT%H:%M:%SZ)" "$EXEC_ID" "$phase" "$category" "$program" "$hook" "$result" "$elapsed" "$(_json_escape "${msg:-}")" \
    >> "$HISTORY_FILE"
}

# json escape util (light)
_json_escape() {
  local s=${1:-}
  s=${s//\\/\\\\}; s=${s//\"/\\\"}; s=${s//$'\n'/\\n}; s=${s//$'\r'/\\r}; s=${s//$'\t'/\\t}
  printf '%s' "$s"
}

# safe exec of hook with isolation
_run_hook_script() {
  local hook_path="$1"
  local phase="$2"
  local category="$3"
  local program="$4"
  local context="$5"    # e.g., build dir or target
  local dry="$6"        # 1 = dry-run
  local start end elapsed outfile errfile rc
  start=$(date +%s.%N)
  outfile="$(mktemp "${TMP_BASE}/out.XXXXXX")"
  errfile="$(mktemp "${TMP_BASE}/err.XXXXXX")"
  log_set_phase "$phase"
  log_info "Executando hook: $(basename "$hook_path") for ${category}/${program} (dry=$dry)"
  if [[ "$dry" -eq 1 ]]; then
    # perform a syntax check if shell script
    if head -n1 "$hook_path" | grep -qE '^#!'; then
      if ! bash -n "$hook_path" 2>"$errfile"; then
        rc=2
        log_err "Syntax error em hook $(basename "$hook_path"): $(cat "$errfile")"
      else
        rc=0
        log_ok "Dry-run OK (syntax) for $(basename "$hook_path")"
      fi
    else
      # non-shell executable: check executable bit
      rc=0
      log_ok "Dry-run: executable exists for $(basename "$hook_path")"
    fi
  else
    # run in subshell with sanitized env
    (
      export ADM_HOOK_PHASE="$phase"
      export ADM_HOOK_CATEGORY="$category"
      export ADM_HOOK_PROGRAM="$program"
      export ADM_HOOK_CONTEXT="$context"
      export ADM_HOOK_EXEC_ID="$EXEC_ID"
      cd "${context:-$ADM_ROOT}" 2>/dev/null || true
      # restrict PATH to safe minimal
      PATH="/usr/bin:/bin"
      # run
      exec "$hook_path"
    ) >"$outfile" 2>"$errfile" || rc=$?
    rc=${rc:-0}
    if [[ "$rc" -eq 0 ]]; then
      log_ok "Hook $(basename "$hook_path") retornou 0 em ${phase}"
    else
      log_err "Hook $(basename "$hook_path") retornou ${rc} em ${phase}; stderr: $(head -n2 "$errfile" | tr '\n' ' ' )"
    fi
  fi
  end=$(date +%s.%N)
  elapsed=$(awk "BEGIN{printf \"%.3f\", $end - $start}")
  # save logs
  local logdest="${STATE_DIR%/}/${category}/${program}"
  mkdir -p "$logdest"
  cp -f "$outfile" "${logdest}/$(basename "$hook_path").out.${EXEC_ID}" 2>/dev/null || true
  cp -f "$errfile"  "${logdest}/$(basename "$hook_path").err.${EXEC_ID}" 2>/dev/null || true
  rm -f "$outfile" "$errfile"
  _record_history "$phase" "$category" "$program" "$(basename "$hook_path")" "$([[ ${rc:-0} -eq 0 ]] && echo ok || echo fail)" "$elapsed" "exit=${rc:-0}"
  return "${rc:-0}"
}

# apply chain: runs global then program hooks for phase; stops on error (unless continue flag)
_apply_chain() {
  local phase="$1" category="$2" program="$3" context="$4" dry="$5" continue_on_error="${6:-0}"
  local hooks
  mapfile -t hooks < <(_find_hooks_for "$phase" "$category" "$program")
  if [[ "${#hooks[@]}" -eq 0 ]]; then
    log_info "Nenhum hook para phase=${phase} target=${category}/${program}"
    return 0
  fi
  local h rc
  for h in "${hooks[@]}"; do
    if [[ -f "${h}.disabled" ]]; then
      log_info "Hook disabled: $(basename "$h")"
      continue
    fi
    if ! _is_executable "$h"; then
      log_warn "Hook não executável: $h — pulando"
      continue
    fi
    if ! _run_hook_script "$h" "$phase" "$category" "$program" "$context" "$dry"; then
      rc=$?
      # try on-error handler in same dir (program-specific preferred)
      local dir
      dir="$(dirname "$h")"
      local onerr="${dir%/}/on-error.sh"
      if [[ -x "$onerr" ]]; then
        log_info "Executando on-error handler: $(basename "$onerr")"
        _run_hook_script "$onerr" "on-error" "$category" "$program" "$context" "$dry" || true
      fi
      if [[ "$continue_on_error" -ne 1 ]]; then
        log_err "Abortando cadeia de hooks em phase=${phase} devido a falha em $(basename "$h")"
        return "$rc"
      fi
    fi
  done
  return 0
}

# enable/disable hooks by creating .disabled marker or removing it
_hook_set_enabled() {
  local target="$1" enable="$2"
  if [[ ! -e "$target" ]]; then log_err "Hook alvo não existe: $target"; return 1; fi
  if [[ "$enable" -eq 1 ]]; then
    rm -f "${target}.disabled" 2>/dev/null || true
    log_ok "Enabled $target"
  else
    touch "${target}.disabled"
    log_ok "Disabled $target"
  fi
}

# commands
_cmd_list() {
  local category="${1:-}" program="${2:-}"
  log_set_phase "list"
  log_info "Listando hooks"
  # global
  for f in "$HOOKS_DIR"/*; do
    [[ -f "$f" || -d "$f" ]] || continue
  done
  # list program hooks if provided
  if [[ -n "$category" && -n "$program" ]]; then
    local dir="${METAFILE_DIR%/}/${category}/${program}/hooks"
    if [[ -d "$dir" ]]; then
      find "$dir" -maxdepth 2 -type f -name '*.sh' | sort | while read -r h; do
        local kind="program"
        [[ -f "${h}.disabled" ]] && printf '%s\t%s\t%s\t%s\n' "$h" "$kind" "disabled" "$category/$program" || printf '%s\t%s\t%s\t%s\n' "$h" "$kind" "enabled" "$category/$program"
      done
    else
      log_info "Nenhum diretório de hooks para $category/$program"
    fi
  else
    # show global hooks
    if [[ -d "$HOOKS_DIR" ]]; then
      find "$HOOKS_DIR" -maxdepth 1 -type f -name '*.sh' | sort | while read -r h; do
        [[ -f "${h}.disabled" ]] && printf '%s\tglobal\tdisabled\n' "$h" || printf '%s\tglobal\tenabled\n' "$h"
      done
    fi
  fi
}

_cmd_run() {
  # adm-hooks run <phase> <category> <program> <context> [--dry] [--continue-on-error]
  local phase="${1:-}" category="${2:-}" program="${3:-}" context="${4:-}" dry=0 continue_on_error=0
  shift 4 || true
  while (( $# )); do
    case "$1" in --dry) dry=1 ;; --continue) continue_on_error=1 ;; *) log_warn "opção desconhecida $1";; esac
    shift
  done
  if [[ -z "$phase" || -z "$category" || -z "$program" ]]; then
    log_err "Uso: adm-hooks run <phase> <category> <program> <context> [--dry]"; return $ADM_ERR_USAGE
  fi
  # safety check context path
  if [[ -n "$context" ]]; then
    if ! _safe_path "$context"; then
      log_err "Contexto inseguro ou fora do ADM_ROOT: $context"; return $ADM_ERR_PERMISSION
    fi
  fi
  # run chain
  _apply_chain "$phase" "$category" "$program" "$context" "$dry" "$continue_on_error"
  return $?
}

_cmd_status() {
  # print recent history
  log_set_phase "status"
  log_info "Últimas entradas de hooks (5)"
  if [[ -f "$HISTORY_FILE" ]]; then
    tail -n 50 "$HISTORY_FILE" | tail -n 10
  else
    log_info "Nenhum histórico"
  fi
}

_cmd_enable_disable() {
  # adm-hooks enable|disable <path-to-hook> OR <category> <program> <hookname>
  local action="$1"; shift
  if [[ $# -eq 1 ]]; then
    _hook_set_enabled "$1" $([[ "$action" == "enable" ]] && echo 1 || echo 0)
    return $?
  elif [[ $# -eq 3 ]]; then
    local category="$1" program="$2" hookname="$3"
    local file="${METAFILE_DIR%/}/${category}/${program}/hooks/${hookname}"
    if [[ -f "$file" ]]; then
      _hook_set_enabled "$file" $([[ "$action" == "enable" ]] && echo 1 || echo 0)
      return $?
    else
      log_err "Hook não encontrado: $file"
      return 1
    fi
  else
    log_err "Uso: adm-hooks enable|disable <hookpath> OR <category> <program> <hookname>"
    return $ADM_ERR_USAGE
  fi
}

_cmd_clean() {
  # remove history and disable markers
  log_set_phase "clean"
  if [[ -d "$STATE_DIR" ]]; then
    rm -rf "$STATE_DIR"/* 2>/dev/null || true
  fi
  # optionally remove .disabled markers? We'll keep them unless --all specified
  log_ok "Hooks state limpo"
}

_usage() {
  cat <<EOF
adm-hooks <cmd> [args]

Commands:
  list [category] [program]                 : listar hooks (global ou por programa)
  run <phase> <category> <program> <context> [--dry] [--continue]
  status                                    : mostrar histórico recente
  enable <hookpath> | <category> <program> <hookname>
  disable <hookpath> | <category> <program> <hookname>
  clean                                     : limpar estado/histórico
  help
EOF
  exit $ADM_ERR_USAGE
}

# trap cleanup
_on_exit() {
  rm -rf "${TMP_BASE}/run-${EXEC_ID}" 2>/dev/null || true
}
trap _on_exit EXIT INT TERM

# entrypoint
main() {
  log_start "adm-hooks" "hooks"
  log_set_subject "adm-hooks"
  _ensure_dirs
  if (( $# < 1 )); then _usage; fi
  local cmd="$1"; shift
  case "$cmd" in
    list) _cmd_list "$@" ;;
    run) _cmd_run "$@" ;;
    status) _cmd_status ;;
    enable) _cmd_enable_disable enable "$@" ;;
    disable) _cmd_enable_disable disable "$@" ;;
    clean) _cmd_clean ;;
    help) _usage ;;
    *) log_err "Comando desconhecido: $cmd"; _usage ;;
  esac
  log_end $ADM_OK
}

main "$@"
