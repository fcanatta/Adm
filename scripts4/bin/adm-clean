#!/usr/bin/env bash
# adm-clean — limpeza segura e registrada para ADM
# Requisitos: adm-logger (sourced), coreutils (find, du, mv, rm), bash
set -Eeuo pipefail
IFS=$'\n\t'

# ---- Config / Defaults ----
ADM_ROOT_DEFAULT="/usr/src/adm"
ADM_ROOT="${ADM_ROOT:-$ADM_ROOT_DEFAULT}"
ADM_LOGGER_PATH="${ADM_ROOT}/bin/adm-logger"
TRASH_DIR=""
EXEC_ID=""
DRY_RUN=0
MODE_BUILD=0
MODE_CACHE=0
MODE_LOGS=0
MODE_ARTIFACTS=0
MODE_TMP=0
MODE_ALL=0
FORCE=0
QUIET=0
VERBOSE=0
OLDER_THAN_DAYS=0
KEEP_N=0

# ---- exit codes (reuse from logger spec) ----
ADM_OK=0
ADM_ERR_USAGE=80
ADM_ERR_CLEAN=70
ADM_ERR_INTERRUPTED=90
ADM_ERR_INTERNAL=99

# ---- load logger if available, otherwise fallback minimal logger ----
if [[ -f "$ADM_LOGGER_PATH" ]]; then
  # shellcheck source=/usr/src/adm/bin/adm-logger
  source "$ADM_LOGGER_PATH"
else
  # minimal fallback
  log_start() { EXEC_ID="$(date -u +%Y%m%d-%H%M%S)-$$"; echo "LOG START $*"; }
  log_info()  { printf '[INFO] %s\n' "$*"; }
  log_ok()    { printf '[OK] %s\n' "$*"; }
  log_warn()  { printf '[WARN] %s\n' "$*"; }
  log_err()   { printf '[ERR] %s\n' "$*"; }
  log_end()   { printf '[END] %s\n' "$*"; }
  log_set_phase() { :; }
  log_set_subject() { :; }
  log_inc_artifacts() { :; }
fi

# ---- helpers ----
_usage() {
  cat <<EOF
Uso: adm-clean [opções]

Opções:
  --dry-run         : mostrar o que seria removido (padrão seguro)
  --all             : limpa builds, cache, logs, artifacts, tmp (confirmação necessária)
  --builds          : limpa builds temporários
  --cache           : limpa cache de fontes/pacotes
  --logs            : rotaciona/apaga logs antigos
  --artifacts       : remove artefatos antigos
  --tmp             : limpa diretórios temporários
  --older-than N    : remove arquivos com N dias ou mais
  --keep N          : mantém apenas N itens mais recentes (quando aplicável)
  --force           : força operação (ignora prompts e bloqueios de segurança)
  --quiet           : saída reduzida
  --verbose         : saída detalhada
  --help            : mostrar este texto
EOF
  exit $ADM_ERR_USAGE
}

_is_root() {
  [[ "$(id -u)" -eq 0 ]]
}

_resolve_adm_root() {
  # canonicalize and sanity-check ADM_ROOT
  if [[ -z "${ADM_ROOT:-}" ]]; then
    log_err "ADM_ROOT não definido"
    exit $ADM_ERR_USAGE
  fi
  ADM_ROOT="$(readlink -f "$ADM_ROOT")" || true
  if [[ "$ADM_ROOT" == "/" || "$ADM_ROOT" == "/usr" || "$ADM_ROOT" == "/usr/src" ]]; then
    log_err "ADM_ROOT inseguro: '$ADM_ROOT' — abortando"
    exit $ADM_ERR_USAGE
  fi
  if [[ ! -d "$ADM_ROOT" ]]; then
    log_err "ADM_ROOT não existe: $ADM_ROOT"
    exit $ADM_ERR_USAGE
  fi
  TRASH_DIR="${ADM_ROOT}/.trash/adm-clean-${EXEC_ID:-tmp}"
  mkdir -p "$TRASH_DIR"
}

_safe_path() {
  # resolve and ensure path is under ADM_ROOT; prints canonical path
  local p="$1"
  local cp
  cp="$(readlink -f "$p" 2>/dev/null || true)"
  if [[ -z "$cp" ]]; then
    echo ""
    return 1
  fi
  case "$cp" in
    "$ADM_ROOT"/*) printf '%s' "$cp"; return 0 ;;
    "$ADM_ROOT") printf '%s' "$cp"; return 0 ;;
    *) return 1 ;;
  esac
}

_confirm() {
  # prompt yes/no unless FORCE=1
  if [[ "$FORCE" -eq 1 ]]; then return 0; fi
  local msg="$1"
  printf "%s [y/N]: " "$msg" >&2
  read -r ans || return 1
  case "$ans" in
    y|Y|yes|YES) return 0 ;;
    *) return 1 ;;
  esac
}

_bytes_human() {
  # input bytes -> human readable
  numfmt --to=si --suffix=B --format="%.3f" "$1" 2>/dev/null || echo "${1}B"
}

# ---- parse args ----
_parse_args() {
  if [[ $# -eq 0 ]]; then _usage; fi
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run) DRY_RUN=1; shift ;;
      --all) MODE_ALL=1; shift ;;
      --builds) MODE_BUILD=1; shift ;;
      --cache) MODE_CACHE=1; shift ;;
      --logs) MODE_LOGS=1; shift ;;
      --artifacts) MODE_ARTIFACTS=1; shift ;;
      --tmp) MODE_TMP=1; shift ;;
      --older-than) OLDER_THAN_DAYS="${2:-}"; shift 2 ;;
      --keep) KEEP_N="${2:-}"; shift 2 ;;
      --force) FORCE=1; shift ;;
      --quiet) QUIET=1; shift ;;
      --verbose) VERBOSE=1; shift ;;
      --help) _usage ;;
      *) log_err "Opção desconhecida: $1"; _usage ;;
    esac
  done
  # if --all then set components
  if [[ "$MODE_ALL" -eq 1 ]]; then
    MODE_BUILD=1; MODE_CACHE=1; MODE_LOGS=1; MODE_ARTIFACTS=1; MODE_TMP=1
  fi
  # require at least one mode
  if [[ $MODE_BUILD -eq 0 && $MODE_CACHE -eq 0 && $MODE_LOGS -eq 0 && $MODE_ARTIFACTS -eq 0 && $MODE_TMP -eq 0 ]]; then
    log_err "Nenhuma ação selecionada. Use --help."
    exit $ADM_ERR_USAGE
  fi
}

# ---- collect targets ----
TARGETS=()

_collect_targets() {
  log_set_phase "detect"
  log_info "Detectando alvos para limpeza"
  local d list size
  # builds
  if [[ $MODE_BUILD -eq 1 ]]; then
    d="${ADM_ROOT}/build"
    d=$(_safe_path "$d") || { log_warn "No build dir em $ADM_ROOT"; }
    if [[ -n "$d" && -d "$d" ]]; then
      mapfile -t list < <(find "$d" -maxdepth 2 -mindepth 1 -type d -printf '%T@ %p\n' 2>/dev/null | sort -nr | awk '{print $2}')
      if [[ "${#list[@]}" -eq 0 ]]; then log_info "Sem builds a limpar"; else TARGETS+=("${list[@]}"); fi
    fi
  fi
  # cache
  if [[ $MODE_CACHE -eq 1 ]]; then
    d="${ADM_ROOT}/cache"
    d=$(_safe_path "$d") || { log_warn "No cache dir in $ADM_ROOT"; }
    if [[ -n "$d" && -d "$d" ]]; then
      mapfile -t list < <(find "$d" -maxdepth 2 -mindepth 1 -type d -printf '%T@ %p\n' 2>/dev/null | sort -nr | awk '{print $2}')
      TARGETS+=("${list[@]}")
    fi
  fi
  # artifacts
  if [[ $MODE_ARTIFACTS -eq 1 ]]; then
    d="${ADM_ROOT}/artifacts"
    d=$(_safe_path "$d") || { log_warn "No artifacts dir"; }
    if [[ -n "$d" && -d "$d" ]]; then
      mapfile -t list < <(find "$d" -maxdepth 2 -mindepth 1 -type d -printf '%T@ %p\n' 2>/dev/null | sort -nr | awk '{print $2}')
      TARGETS+=("${list[@]}")
    fi
  fi
  # logs
  if [[ $MODE_LOGS -eq 1 ]]; then
    d="${ADM_ROOT}/logs"
    d=$(_safe_path "$d") || { log_warn "No logs dir"; }
    if [[ -n "$d" && -d "$d" ]]; then
      # list files under logs/raw and logs/structured
      mapfile -t list < <(find "$d/raw" "$d/structured" -type f -mtime +"${OLDER_THAN_DAYS:-0}" 2>/dev/null || true)
      TARGETS+=("${list[@]}")
    fi
  fi
  # tmp
  if [[ $MODE_TMP -eq 1 ]]; then
    d="${ADM_ROOT}/tmp"
    d=$(_safe_path "$d") || { log_warn "No tmp dir"; }
    if [[ -n "$d" && -d "$d" ]]; then
      mapfile -t list < <(find "$d" -maxdepth 2 -mindepth 1 -type d -printf '%T@ %p\n' 2>/dev/null | sort -nr | awk '{print $2}')
      TARGETS+=("${list[@]}")
    fi
  fi

  # filter by older-than if set (only for files/dirs with mtime)
  if [[ -n "${OLDER_THAN_DAYS:-}" && "${OLDER_THAN_DAYS:-}" =~ ^[0-9]+$ && "${OLDER_THAN_DAYS}" -gt 0 ]]; then
    local cutoff epoch
    cutoff="${OLDER_THAN_DAYS}"
    mapfile -t TARGETS < <(printf "%s\n" "${TARGETS[@]}" | while read -r p; do
      if [[ -e "$p" ]]; then
        epoch_now=$(date +%s)
        mtime=$(stat -c %Y "$p" 2>/dev/null || echo 0)
        days=$(( (epoch_now - mtime) / 86400 ))
        if (( days >= cutoff )); then printf '%s\n' "$p"; fi
      fi
    done)
  fi

  # apply keep N: keep N most recent (by mtime) per parent directory
  if [[ "${KEEP_N:-0}" =~ ^[0-9]+$ && "${KEEP_N}" -gt 0 ]]; then
    # group by parent
    local parent
    declare -A keepmap
    for p in "${TARGETS[@]}"; do
      parent="$(dirname "$p")"
      keepmap["$parent"]+="$p"$'\n'
    done
    local newtargets=()
    for parent in "${!keepmap[@]}"; do
      mapfile -t arr < <(printf "%s" "${keepmap[$parent]}" | xargs -I{} stat -c '%Y %n' {} 2>/dev/null | sort -nr | awk '{print $2}')
      local i=0
      for item in "${arr[@]}"; do
        ((i++))
        if (( i > KEEP_N )); then newtargets+=("$item"); fi
      done
    done
    TARGETS=("${newtargets[@]}")
  fi

  # dedupe
  mapfile -t TARGETS < <(printf "%s\n" "${TARGETS[@]}" | awk '!seen[$0]++')
  if [[ "${#TARGETS[@]}" -eq 0 ]]; then
    log_info "Nenhum alvo encontrado para limpeza."
  else
    log_info "Alvos detectados: ${#TARGETS[@]}"
    [[ "$VERBOSE" -eq 1 ]] && printf '%s\n' "${TARGETS[@]}" | sed 's/^/  /'
  fi
}

# ---- simulate / show summary ----
_simulate() {
  log_set_phase "analyze"
  local total_bytes=0 count=0
  local p size
  for p in "${TARGETS[@]}"; do
    if [[ -e "$p" ]]; then
      size=$(du -sb "$p" 2>/dev/null | awk '{print $1}' || echo 0)
      total_bytes=$((total_bytes + size))
      ((count++))
      if [[ $DRY_RUN -eq 1 || $VERBOSE -eq 1 ]]; then
        log_info "Candidato: $p ($( _bytes_human "$size" ))"
      fi
    fi
  done
  log_info "Possíveis itens: $count — Espaço candidato: $(_bytes_human "$total_bytes")"
}

# ---- execute removal with trash + rollback list ----
MOVED_ITEMS=()

_move_to_trash() {
  local src="$1"
  local rel dest base
  base="$(basename "$src")"
  rel="$(date +%s)-${RANDOM}-${base}"
  dest="${TRASH_DIR}/${rel}"
  # ensure parent exists
  mkdir -p "$(dirname "$dest")"
  if mv "$src" "$dest" 2>/dev/null; then
    MOVED_ITEMS+=("$dest:$src")
    log_ok "Movido para trash: $src -> $dest"
    return 0
  else
    log_warn "Falha ao mover para trash: $src"
    return 1
  fi
}

_execute_removal() {
  log_set_phase "remove"
  local freed=0 deleted=0 failed=0
  for p in "${TARGETS[@]}"; do
    if [[ ! -e "$p" ]]; then
      log_warn "Item não existe (pular): $p"
      continue
    fi
    # safety check
    safe=$(_safe_path "$p" || true)
    if [[ -z "$safe" ]]; then
      log_err "Caminho inseguro ou fora do ADM_ROOT: $p — ignorando"
      ((failed++))
      continue
    fi
    if [[ $DRY_RUN -eq 1 ]]; then
      log_info "DRY-RUN: (remover) $p"
      continue
    fi
    # move to trash first
    if _move_to_trash "$p"; then
      ((deleted++))
    else
      ((failed++))
    fi
  done

  # after moved, attempt to delete the trash directory (garbage collect)
  if [[ $DRY_RUN -eq 0 && "${#MOVED_ITEMS[@]}" -gt 0 ]]; then
    if rm -rf "${TRASH_DIR}" 2>/dev/null; then
      log_ok "Trash removido com sucesso"
    else
      log_warn "Falha ao remover trash ${TRASH_DIR}; tentando rollback"
      return 2
    fi
  fi

  log_info "Remoção concluída: deletados=${deleted} falhas=${failed}"
  return 0
}

_rollback() {
  log_set_phase "rollback"
  log_warn "Iniciando rollback: tentando restaurar itens movidos"
  local pair src dst
  for pair in "${MOVED_ITEMS[@]}"; do
    dst="${pair#*:}"
    src="${pair%%:*}"
    # attempt move back
    if [[ -e "$src" ]]; then
      mkdir -p "$(dirname "$dst")" 2>/dev/null || true
      if mv "$src" "$dst" 2>/dev/null; then
        log_ok "Restaurado: $dst"
      else
        log_err "Falha ao restaurar $dst (orig: $src)"
      fi
    else
      log_warn "Item de backup ausente: $src"
    fi
  done
}

# ---- main ----
main() {
  parse_err=0
  EXEC_ID="$(date -u +%Y%m%d-%H%M%S)-$$"
  log_start "adm-clean" "clean"
  log_set_subject "adm-clean"
  # parse args
  _parse_args "$@"

  # apply quiet/verbose to logger if available
  if [[ "$QUIET" -eq 1 ]]; then log_quiet_on 2>/dev/null || true; fi
  if [[ "$VERBOSE" -eq 1 ]]; then log_verbose_on 2>/dev/null || true; fi

  # root safety: disallow running as root unless --force (protect host)
  if _is_root && [[ "$FORCE" -ne 1 ]]; then
    log_warn "Execução como root detectada. Passe --force para confirmar (recomendado apenas em CI)."
    exit $ADM_ERR_USAGE
  fi

  # resolve ADM_ROOT and prepare trash dir
  _resolve_adm_root

  TRASH_DIR="${ADM_ROOT}/.trash/adm-clean-${EXEC_ID}"
  mkdir -p "$TRASH_DIR"

  # detect active mounts referencing ADM_ROOT (avoid cleaning mounted dirs)
  if mountpoint -q "${ADM_ROOT}/build" 2>/dev/null || mountpoint -q "${ADM_ROOT}/tmp" 2>/dev/null; then
    log_err "Montagens ativas detectadas em ${ADM_ROOT} (ex: build/tmp) — abortando"
    exit $ADM_ERR_CLEAN
  fi

  # collect targets
  _collect_targets

  if [[ "${#TARGETS[@]}" -eq 0 ]]; then
    log_info "Nada a limpar"
    log_end $ADM_OK
    exit $ADM_OK
  fi

  # simulate
  _simulate

  # confirm if doing destructive all and not forced
  if [[ $DRY_RUN -eq 0 && $MODE_ALL -eq 1 && $FORCE -ne 1 ]]; then
    if ! _confirm "Confirmar limpeza TOTAL em $ADM_ROOT ?"; then
      log_info "Operação cancelada pelo usuário"
      log_end $ADM_OK
      exit $ADM_OK
    fi
  fi

  # execute removal
  if [[ $DRY_RUN -eq 1 ]]; then
    log_info "DRY-RUN ativo: nenhuma ação de remoção será executada"
    log_end $ADM_OK
    exit $ADM_OK
  fi

  if ! _execute_removal; then
    log_err "Erro durante remoção; tentando rollback"
    _rollback || log_err "Rollback falhou"
    log_end $ADM_ERR_CLEAN
    exit $ADM_ERR_CLEAN
  fi

  # success
  log_info "Limpeza finalizada com sucesso"
  log_end $ADM_OK
  return $ADM_OK
}

# ---- trap handlers ----
_on_int() {
  log_err "Interrompido pelo usuário"
  _rollback || true
  log_end $ADM_ERR_INTERRUPTED
  exit $ADM_ERR_INTERRUPTED
}
trap _on_int INT TERM

# ---- entrypoint ----
main "$@"
