Obs:Só gerar código depois que eu pedir ou autorizar,sempre entregar os scripts com funções 
completas e funcionais entregar com código completo,limpo,maduro,funcional e com todos os 
possíveis erros e erros silenciosos e problemas corrigidos.

============================================================
       ADM BUILD SYSTEM - V 1.0 - CONSTRUCTION TOOLS
============================================================

## Objetivo
Criar um sistema de construção baseado no modelo do T2 SDE,
mas automatizado com codigo limpo,estável, completo,funcional.
O foco é reprodutibilidade, modularidade e automação completa
em shell puro, com o mínimo de dependências externas e uso do host,
ser capaz de construir bootstrap do zero e daí iniciar a construção 
do sistema linux from scratch e depois beyond linux from scratch
com xorg,kde,gnome,firefox os scripts serão capaz de construir 
qualquer programa é sempre manter o sistema limpo e funcional.

Estrutura de diretórios:
------------------------
/usr/src/adm/scripts/    - todos os scripts principais do sistema
/usr/src/adm/repo/<categoria>/{<programa,hooks,patch>}/      - repositório de pacotes, hooks, patches e metadados (build.pkg)
/usr/src/adm/build/      - diretório temporário de compilação 
/usr/src/adm/logs/       - registros e saídas organizadas por data
/usr/src/adm/bootstrap/  - diretório de bootstrap e imagens finais e stages 1,2,3,4
/usr/src/adm/cache/{sources,packages}/     - sources e pacotes criados
/usr/src/adm/state/    - pacotes instalados e estados
/usr/src/adm/update/<categoria>/<programa/build.pkg     - diretório de updates com versões novas de atualização 
Categorias do repo  É pra ser criado nos diretórios update/ e repo/ com o env.sh



## Scripts Principais (em /usr/src/adm/scripts)

1. Env
   - Lê e aplica configurações globais do sistema.
   - Define variáveis globais ao sistema para ser usado pelo bootstrap e sistema.
   - Define perfis para construção como agressive, padrão, simples (definidos com comando set)
   - Carrega funções auxiliares de configuração.
   - Confere e cria toda a estrutura de diretórios necessária para o sistema com as devidas permissões 
   - Poder ser chamada várias vezes sem problemas ao sistema.

2. Bootstrap
   - Inicializa o ambiente de build.
   - Cria diretórios em /usr/src/adm/bootstrap.
   - Testa ferramentas essenciais (bash, tar, make, gcc).
   - Prepara variáveis para a arquitetura local.
   - Gera o primeiro toolchain stage0 com rootfs.
   - Cria chroot cria tudo que é preciso pra construir os stages corretamente arquivos,diretórios
   - Depois segue criando toolchain stage1,stage2,stage3 com rootfs de cada stage.
   - Nas atualizações quando detectado toolchain o bootstrap deve gerenciar,construir, manter.

3. Check-Deps
   - Verifica dependências do ambiente (gcc, make, bison, flex, etc).
   - Garante que o sistema host tem o necessário para construir o bootstrap.
   - Checa dependências do sistema e garante que o sistema tem o necessário para construir.
   - Checa se todas as variáveis estão carregadas e se o perfil de construção está correto.
   - Checa e mostra se o sistema está pronto pra construção de qualquer programa.
   - Pode ser chamado antes de iniciar qualquer build.

4. PkgQueue
   - Gera a lista ordenada de pacotes a serem construídos.
   - Lê todos os build.pkg e ordena conforme STAGE e dependências.
   - Se é cross se tem múltiplas arquiteturas — assume target == host.
   - Salva a ordem de build em /usr/src/adm/state/pkgqueue.list.
   - Garante ordem correta na fila.

5. FetchPkg
   - Lê o URL no build.pkg faz múltiplos downloads em todos os formatos,git,https,FTP,rsync dos sources para o cache.
   - Checa multiplos sha256sum e confere com o do build.pkg se ok procegue se não baixa novamente.
   - Extrai em todos os formatos para o diretório de trabalho.

6. PatchPkg
   - Aplica patches em níveis p0,p1,p2 

7. HookPkg
   - Aplica hooks em todos os estágios pre/post e uninstall também 

8. Install-Pkg
   - Instala binários gerados ou converte binários deb,rpm em pacote para instalar.
   - Com comando para definir diretório final.
   - Salva registro de programa instalado.

9. Create-Pkg
   - Cria arquivo binário tar.zst ou tar.xz com .pkg.tar
   - Strip e guardar em cache


10. Build-Pkg
   - Função principal de construção.
   - Lê o build.pkg do pacote.
   - Executa:
     1. FetchPkg → baixa e valida o source e extrai para diretório de trabalho
     3. PatchPkg → aplica patches encontrados em /usr/src/adm/repo/<categoria>/<programa/patch/
     4. HookPkg   prepare → hooks pré-configuração.
     5. compile → executa build conforme BUILD_HINT.
     6. install → instala em diretório temporário DESTDIR.
     7. Create-Pkg → cria arquivo binário .pkg.tar.
     8. register → grava em state/installed.list.
     9. Install-Pkg  instalação final 
   - Log completo em /usr/src/adm/log/<pkg>.log.

11. Emerge-Pkg
   - Controla a construção em lote de pacotes.
   - Lê pkgqueue.list e chama Build-Pkg para cada pacote em ordem.
   - Detecta falhas e pausa a fila.
   - Permite retomar o processo do ponto onde parou.
   - Usar os profiles e Otimizar ao máximo 

12. Update-Pkg
   - Atualiza um pacote específico:
     - Lê o build.pkg em URL e busca no upstream nova versão estável.
     - Cria build.pkg atualizado em /usr/src/adm/update/<categoria>/<programa/build.pkg
     - Detectar toolchain e chamar bootstrap para atualizar,gerenciar.
     - Comando para Recompila e substitui binário removendo o antigo.
     - Lê build.pkg mantém dependências originais,mas possibilitando atualizar cada uma das dependências também 
   - Log em /usr/src/adm/log/update-<pkg>.log.

13. Cleanup
   - Remove diretórios temporários antigos.
   - Limpa caches inválidos e logs muito antigos.
   - Mantém apenas últimos builds bem-sucedidos.

14. Verify-Pkg
   - Verifica integridade de instalação completa se tem libs faltando,quebrada,links,permissões.
   - Recalcula checksums e compara com manifest.
   - Valida presença de dependências.
   - Reporta divergências ou arquivos ausentes.
   - Verifica permissões em diretório,arquivos e concerta.

15. DiffPkg
   - Responsável por criar,compara,editar,aplicar diff 
   - Opção de criar diff no diretório específico já com as modificações.
   - Tanto manual como pro sistema.

16. Mkinitramfs
   - Cria mkinitramfs,initramfs completo para o stage com kernel


## Estrutura de Pacote (build.pkg)

Exemplo: /usr/src/adm/repo/base/bc/build.pkg

DESCRIPTION=Programa de linha de comando no Linux que funciona como uma calculadora.
NAME=bc
VERSION=1.08.2
BUILD=1
URL=https://ftp.gnu.org/$NAME/bc/$NAME-$VERSION.tar.xz
SHA256=76e3a9531c7764bd13c600c1e016e6760d9b8379ba06d1ecc08d5a68
BUILD_DEPS=readline
RUN_DEPS=
BUILD_HINT=autotools,(todos os compiladores),custom 
STAGE=1


custom_build()
{essa função só aparece quando custom está selecionado em BUILD_HINT}

--------------------------

## Hooks

Cada pacote pode conter um diretório hooks/ com scripts:

pre-prepare
post-prepare
pre-compile
post-compile
pre-install
post-install
pre-uninstall
post-uninstall

Executados automaticamente pelo Build-Pkg nas etapas correspondentes.


## Patches

Diretório: /usr/src/adm/repo/<categoria>/<pacote>/patches/
Arquivos aplicados automaticamente antes da compilação,
em ordem numérica (001-*, 002-*, ...).


## Fluxo de Construção

1. bootstrap → prepara ambiente
2. create-pkgqueue → gera lista ordenada
3. emerge-pkg → constrói todos os pacotes em sequência
4. build-pkg → compila individualmente
5. update-pkg → atualiza versões quando necessário
6. cleanup → remove resíduos
7. verify-pkg → valida integridade final


## Regras Gerais

- Sem suporte a cross-compilação
- Arquitetura fixa: x86_64
- Dependências resolvidas linearmente (recursão simples)
- Fonte, patch e build sempre controlados pelo .desc
- Todos os logs e caches ficam em /var/adm
- Nenhum script depende de sistema de build externo


## Resultado

- Sistema totalmente shell puro, modular e previsível
- Capaz de construir sistemas completos (LFS, BLFS, KDE, GNOME, Firefox)
- Reprodutível e fácil de depurar
- Mantém a filosofia original do T2, mas mais leve e direto

# Fim do Roadmap







Objetivo; criar scripts simples com código limpo,completo,funcional,funções limpas,completas,funcionais
priorizar automação,limpeza,clareza,funcionalidade,completude quero todos os scripts completos,funcionais,limpos e organizados
quero que eles fazem o que precisa somente com o que precisa,não completar o código com coisas desnecessárias
que não fazem parte do escopo do projeto.

Diretório base: /usr/src/adm/


------------------------------------------------------------
Scripts principais (todos em /usr/src/adm/scripts/):
------------------------------------------------------------
adm.sh              - script principal (cli, executável)
env.sh              - define variáveis globais, cria todos os diretórios do sistema com as devidas permissões 
deps.sh             - verifica dependências de compilação do pacote (lendo DEPEND= do build.pkg), resolve recursivamente e ordena
fetch.sh            - baixa múltiplos código-fonte em todos os formatos em todos os tipos de links checa sha256sum e guarda em cache
patch.sh            - aplica correções automaticamente
build.sh            - compila automaticamente e instala na árvore temporária e gera registro
install.sh          - instala para / ou diretório qualquer ou binário em cache ou diretório e registra
package.sh          - empacota resultados e strip e guarda em cache
boot.sh             - cria mkinitramfs, mkinitramfs
bootstrap.sh        - cria o bootstrap,stage0, stage1, stage2, stage3, atualiza, gerência o toolchain e no final cria um rootfs de cada um stage
log.sh              - registra tudo (timestamps e erros)
recover.sh          - retoma builds interrompidos
ui.sh               - interface limpa (progresso e status), define funções de cor (para terminais reais) e barra de progresso pra downloads
scheduler.sh        - cordena a ordem de build otimizações,perfis de construção (agressive,conservador,básico) define com comando
integrity.sh        - verifica hashes, assinaturas, permissões, verifica se o toolchain está funcional, se um programa está correto, se tem lib quebrada
diff.sh             - mostra, compara, cria, edita, remove, aplica diffs com cores manipulação completa 
clean.sh            - limpa diretórios de trabalho, caches, logs, limpa tudo
update.sh           - verifica no upstream se há nova versão do pacote definido no build.pkg, compara e cria build.conf no diretório de update
uninstall.sh        - desinstala pacotes instalados, executa hooks pre/post uninstall e remove dependências órfãs 

------------------------------------------------------------
Repositório de pacotes (/usr/src/adm/repo/):
------------------------------------------------------------
toolchain/
  binutils/build.pkg
  gcc/build.pkg
  glibc/build.pkg

base/
  coreutils/build.pkg
  bash/build.pkg

desktop/
  gnome/meta_build.pkg (contém somente as dependências para instalar tudo)
  

xorg/
  xorg/xorg_build.pkg (contém somente as dependências para instalar tudo)

apps/
  firefox/build.pkg
  chromium/build.pkg

Cada arquivo build.pkg contém apenas metadados, por exemplo:

NAME=firefox
VERSION=130.0
RELEASE=1
DESC=Navegador web
URL=https://ftp.mozilla.org/pub/$NAME/releases/$VERSION/$NAME-$VERSION-source.tar.xz
DEPEND=gtk3,cairo,rust
BUILD_DEPEND=
BUILD=autotools,python,go,rust,make,ninja,todos os compiladores,custom

custom_build ()
{# Aparecer somente se opção BUILD=custom estiver selecionada}



------------------------------------------------------------
Fluxo automático (sem comandos manuais):
------------------------------------------------------------
1. Executar apenas:
   sudo adm --install <programa>

2. O sistema faz automaticamente:
   - Carrega ambiente (env.sh)
   - Checa dependências de compilação (deps.sh)
   - Le perfil ativo (agressive,conservador,básico) aplica
   - Monta plano de compilação (scheduler.sh)
   - Para cada pacote:
       fetch.sh     - baixa
       integrity.sh - verifica
       patch.sh     - aplica automaticamente
       hooks.sh     - aplica automaticamente
       build.sh     - compila e instala em diretório temporário 
       package.sh   - empacota e strip
       install.sh   - instalação final
   - log.sh registra tudo
   - ui.sh exibe progresso e status no terminal

------------------------------------------------------------
Etapas de desenvolvimento (roadmap cronológico):
------------------------------------------------------------
Fase 1: Base estrutural
  - Criar /usr/src/adm/ com pastas scripts, repo, logs, update, bootstrap, cache com sources/ e packages/
  - Resultado: estrutura limpa e organizada

Fase 2: Core scripts
  - Implementar env.sh, log.sh, colors.sh
  - Resultado: ambiente e sistema de logs prontos

Fase 3: Fetch + Integrity
  - Adicionar fetch.sh e integrity.sh
  - Resultado: download e verificação automáticas 

Fase 4: Build engine
  - Criar build.sh, install.sh, package.sh
  - Resultado: compilação automatizada

Fase 5: Scheduler
  - Adicionar scheduler.sh
  - Resultado: ordem automática de construção otimizado

Fase 6: UI e cores
  - Adicionar ui.sh para progresso e feedback visual
  - Implementar painel dinâmico de status (exibição contínua durante a construção)
  - O log completo é redirecionado para arquivo, e a tela exibe somente o painel padronizado:
      e Mostra pacote, versão, etapa atual, progresso, dependências, status e tempo decorrido
      e Atualiza em tempo real a cada etapa (fetch, patch, build, package, install)
      e Ao final, transforma-se na tela de finalização (sucesso/erro) com resumo e caminhos
  - Resultado: interface limpa, dinâmica e informativa

Fase 7: Repositório de pacotes
  - Criar /repo/ com arquivos build.pkg
  - Resultado: base funcional de pacotes

Fase 8: Recuperação automática 
  - Implementar recover.sh
  - Resultado: retoma builds interrompidos

Fase 9: Perfis de compilação 
  - Criar /config/ com perfis (desktop, minimal, xorg)
  - Resultado: perfis de build gerenciáveis 

Fase 10: Atualização e remoção
  - Adicionar update.sh e uninstall.sh
  - Resultado: sistema capaz de atualizar e remover pacotes automaticamente
