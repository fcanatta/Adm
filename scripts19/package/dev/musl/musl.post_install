#!/usr/bin/env bash
# Hook de pós-instalação para musl-1.2.5
# Sanity checks:
#   - headers em ${ADM_ROOTFS}/usr/include
#   - loader /lib/ld-musl-*.so.1 em ${ADM_ROOTFS}
#   - ${TARGET_TRIPLET}-gcc consegue compilar um dummy.c
#   - ${TARGET_TRIPLET}-readelf mostra o program interpreter correto

set -euo pipefail

echo "==> [musl-1.2.5 post_install] Iniciando sanity checks da musl..."

# --------------------------------------------------------------------
# 1. Validar TARGET_TRIPLET, ADM_ROOTFS, CROSS_SYSROOT
# --------------------------------------------------------------------

TARGET="${TARGET_TRIPLET:-}"
if [[ -z "$TARGET" ]]; then
  echo "ERRO: TARGET_TRIPLET não está definido."
  echo "      Carregue o profile (ex.: 'source profile-musl.sh') antes de usar o admV2."
  exit 1
fi

ROOTFS="${ADM_ROOTFS:-/}"
case "$ROOTFS" in
  /) ;;
  */) ROOTFS="${ROOTFS%/}" ;;
esac

: "${CROSS_SYSROOT:=$ROOTFS}"

echo "    TARGET_TRIPLET = ${TARGET}"
echo "    ADM_ROOTFS     = ${ROOTFS}"
echo "    CROSS_SYSROOT  = ${CROSS_SYSROOT}"

# --------------------------------------------------------------------
# 2. Verificar headers e loader da musl no ROOTFS
# --------------------------------------------------------------------

if [[ ! -d "${ROOTFS}/usr/include" ]]; then
  echo "ERRO: diretório ${ROOTFS}/usr/include não existe."
  echo "      A instalação da musl parece incompleta (headers)."
  exit 1
fi

if [[ ! -f "${ROOTFS}/usr/include/stdio.h" ]]; then
  echo "ERRO: ${ROOTFS}/usr/include/stdio.h não existe."
  echo "      Algo está errado com a instalação dos headers da musl."
  exit 1
fi

echo "    OK: headers básicos encontrados em ${ROOTFS}/usr/include"

shopt -s nullglob
musl_ld=( "${ROOTFS}"/lib/ld-musl-*.so.1 )
shopt -u nullglob

if [[ ${#musl_ld[@]} -eq 0 ]]; then
  echo "ERRO: não encontrei loader da musl em ${ROOTFS}/lib/ld-musl-*.so.1"
  exit 1
fi

echo "    OK: loader(es) musl encontrados:"
for f in "${musl_ld[@]}"; do
  echo "      ${f}"
done

# --------------------------------------------------------------------
# 3. Localizar ${TARGET}-gcc e ${TARGET}-readelf
# --------------------------------------------------------------------

GCC_BIN="${TARGET}-gcc"
READELF_BIN="${TARGET}-readelf"

if ! command -v "$GCC_BIN" >/dev/null 2>&1; then
  echo "ERRO: Não encontrei '${GCC_BIN}' no PATH."
  echo "      Esse binário deve vir do gcc pass1/pass2 para alvo musl (${TARGET})."
  exit 1
fi

echo "    Encontrado ${GCC_BIN}: $(command -v "$GCC_BIN")"

if ! command -v "$READELF_BIN" >/dev/null 2>&1; then
  echo "ERRO: Não encontrei '${READELF_BIN}' no PATH."
  echo "      Essa ferramenta deve vir do binutils para o alvo ${TARGET}."
  exit 1
fi

echo "    Encontrado ${READELF_BIN}: $(command -v "$READELF_BIN")"

# --------------------------------------------------------------------
# 4. Compilar dummy.c com ${TARGET}-gcc e linkar contra a musl
# --------------------------------------------------------------------

tmpdir="$(mktemp -d -t musl-sanity-XXXXXX 2>/dev/null || echo "/tmp/musl-sanity-$$")"
mkdir -p "$tmpdir"

cleanup() {
  rm -rf -- "$tmpdir"
}
trap cleanup EXIT

cat > "${tmpdir}/dummy.c" << 'EOF'
#include <stdio.h>

int main(void) {
    puts("musl sanity OK");
    return 0;
}
EOF

echo "    Compilando dummy.c com ${GCC_BIN}..."

(
  cd "$tmpdir"
  # Se o gcc foi configurado com --with-sysroot=${CROSS_SYSROOT},
  # basta chamar sem flags extras que ele já usa a musl do sysroot.
  "$GCC_BIN" dummy.c -o dummy
)

if [[ ! -f "${tmpdir}/dummy" ]]; then
  echo "ERRO: falha ao gerar o binário dummy com ${GCC_BIN}."
  exit 1
fi

echo "    dummy gerado com sucesso: ${tmpdir}/dummy"

# --------------------------------------------------------------------
# 5. Inspecionar o program interpreter com readelf
# --------------------------------------------------------------------

interp_line="$("$READELF_BIN" -l "${tmpdir}/dummy" | awk '/Requesting program interpreter/ {print $0}')"

if [[ -z "$interp_line" ]]; then
  echo "ERRO: ${READELF_BIN} não mostrou 'Requesting program interpreter' para dummy."
  "$READELF_BIN" -l "${tmpdir}/dummy" || true
  exit 1
fi

echo "    Linha do 'program interpreter':"
echo "      $interp_line"

interp_path="$(echo "$interp_line" | sed -n 's/.*Requesting program interpreter: \[\(.*\)\].*/\1/p')"

if [[ -z "$interp_path" ]]; then
  echo "ERRO: não consegui extrair o caminho do program interpreter."
  exit 1
fi

echo "    program interpreter detectado: ${interp_path}"

# Regras:
#  - deve ser /lib/ld-musl-*.so.1
#  - não deve conter 'tools' ou 'cross-tools'
case "$interp_path" in
  /lib/ld-musl-*.so.1) ;;
  *)
    echo "ERRO: program interpreter inesperado para musl:"
    echo "      ${interp_path}"
    echo "      Esperado algo como /lib/ld-musl-<arch>.so.1"
    exit 1
    ;;
esac

case "$interp_path" in
  *tools*|*cross-tools*)
    echo "ERRO: program interpreter contém 'tools/cross-tools':"
    echo "      ${interp_path}"
    echo "      O binário ainda parece amarrado a um ambiente antigo."
    exit 1
    ;;
esac

# --------------------------------------------------------------------
# 6. Checagem informativa da libc NEEDED (não fatal)
# --------------------------------------------------------------------

echo "    Checando dependências dinâmicas (informativo)..."
if "$READELF_BIN" -d "${tmpdir}/dummy" | grep -qi 'NEEDED.*musl'; then
  echo "    readelf: dummy depende de uma libc musl (NEEDED ...musl...)."
else
  echo "    AVISO: readelf não encontrou 'NEEDED ...musl...' em dummy."
  echo "           Pode ser um link estático ou outro layout de nomes, verifique manualmente se necessário."
fi

echo "==> [musl-1.2.5 post_install] Sanity checks concluídos com SUCESSO."
