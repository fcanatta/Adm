#!/usr/bin/env bash
# Hook de pós-instalação para Glibc-2.42 Pass 1
# Faz sanity checks usando gcc-pass1 e binutils-pass1:
#   - ${TARGET_TRIPLET}-gcc
#   - ${TARGET_TRIPLET}-readelf
#
# É executado automaticamente pelo admV2 após instalar o pacote,
# desde que este arquivo exista no diretório do pacote.

set -euo pipefail

echo "==> [glibc-pass1 post_install] Iniciando sanity checks (gcc-pass1 + binutils-pass1)..."

# --------------------------------------------------------------------
# 1. Garantir que TARGET_TRIPLET e ADM_ROOTFS existem
# --------------------------------------------------------------------

TARGET="${TARGET_TRIPLET:-}"
if [[ -z "$TARGET" ]]; then
  echo "ERRO: TARGET_TRIPLET não está definido no ambiente."
  echo "      Carregue o profile (ex.: 'source profile-glibc.sh') antes de rodar o admV2."
  exit 1
fi

ROOTFS="${ADM_ROOTFS:-/}"
case "$ROOTFS" in
  /) ;;
  */) ROOTFS="${ROOTFS%/}" ;;
esac

echo "    TARGET_TRIPLET = ${TARGET}"
echo "    ADM_ROOTFS     = ${ROOTFS}"

# --------------------------------------------------------------------
# 2. Verificar se os binários esperados existem no PATH
#    (devem vir de binutils-pass1 e gcc-pass1)
# --------------------------------------------------------------------

GCC_BIN="${TARGET}-gcc"
READELF_BIN="${TARGET}-readelf"

if ! command -v "$GCC_BIN" >/dev/null 2>&1; then
  echo "ERRO: Não encontrei '${GCC_BIN}' no PATH."
  echo "      Certifique-se de que binutils-pass1 e gcc-pass1 estão instalados e o PATH foi ajustado pelo profile."
  exit 1
fi

if ! command -v "$READELF_BIN" >/dev/null 2>&1; then
  echo "ERRO: Não encontrei '${READELF_BIN}' no PATH."
  echo "      Isso deve vir do binutils-pass1 para o alvo ${TARGET}."
  exit 1
fi

echo "    Encontrado: $(command -v "$GCC_BIN")"
echo "    Encontrado: $(command -v "$READELF_BIN")"

# --------------------------------------------------------------------
# 3. Conferir se headers e libc estão onde deveriam no ROOTFS
# --------------------------------------------------------------------

if [[ ! -f "${ROOTFS}/usr/include/stdio.h" ]]; then
  echo "ERRO: ${ROOTFS}/usr/include/stdio.h não existe."
  echo "      Parece que os headers da glibc não foram instalados corretamente."
  exit 1
fi

if [[ ! -e "${ROOTFS}/usr/lib/libc.so" && ! -e "${ROOTFS}/usr/lib/libc.so.6" ]]; then
  echo "ERRO: libc.so/libc.so.6 não encontrada em ${ROOTFS}/usr/lib."
  echo "      Verifique a instalação da glibc-pass1."
  exit 1
fi

echo "    Headers e libc encontrados sob ${ROOTFS}/usr."

# --------------------------------------------------------------------
# 4. Sanity check principal: compilar um 'dummy.c' com ${TARGET}-gcc
#    e inspecionar com ${TARGET}-readelf
# --------------------------------------------------------------------

# Diretório temporário seguro
tmpdir="$(mktemp -d -t glibc-sanity-XXXXXX 2>/dev/null || echo "/tmp/glibc-sanity-$$")"
mkdir -p "$tmpdir"
echo "    Usando diretório temporário: ${tmpdir}"

cleanup() {
  rm -rf -- "$tmpdir"
}
trap cleanup EXIT

cat > "${tmpdir}/dummy.c" << 'EOF'
int main(void) {
    return 0;
}
EOF

echo "    Compilando dummy.c com ${GCC_BIN}..."
(
  cd "$tmpdir"
  # Compila para o alvo. Se o gcc-pass1 foi configurado com --with-sysroot=${ADM_ROOTFS},
  # ele já sabe procurar includes/libs dentro do ROOTFS automaticamente.
  "$GCC_BIN" dummy.c -o dummy
)

if [[ ! -f "${tmpdir}/dummy" ]]; then
  echo "ERRO: Falha ao gerar o binário dummy com ${GCC_BIN}."
  exit 1
fi

echo "    Binário dummy gerado: ${tmpdir}/dummy"

# --------------------------------------------------------------------
# 5. readelf: checar o dynamic linker (program interpreter)
# --------------------------------------------------------------------

interp_line="$("$READELF_BIN" -l "${tmpdir}/dummy" | awk '/Requesting program interpreter/ {print $0}')"

if [[ -z "$interp_line" ]]; then
  echo "ERRO: ${READELF_BIN} não mostrou 'Requesting program interpreter' para o dummy."
  "$READELF_BIN" -l "${tmpdir}/dummy" || true
  exit 1
fi

echo "    Linha do 'program interpreter' em readelf:"
echo "      $interp_line"

interp_path="$(echo "$interp_line" | sed -n 's/.*Requesting program interpreter: \[\(.*\)\].*/\1/p')"

if [[ -z "$interp_path" ]]; then
  echo "ERRO: Não consegui extrair o caminho do program interpreter a partir do readelf."
  exit 1
fi

echo "    Caminho do program interpreter: ${interp_path}"

# Regra de sanity:
#  - Ele deve apontar para algo em /lib ou /lib64 (como /lib/ld-linux-*.so.2)
#  - NÃO deve apontar para /tools, /cross-tools, etc.
case "$interp_path" in
  /lib/*|/lib64/*)
    ;;
  *)
    echo "ERRO: O program interpreter do dummy NÃO está em /lib ou /lib64:"
    echo "      ${interp_path}"
    echo "      Isso indica que o cross-compiler ainda está linkando contra o sistema host errado."
    exit 1
    ;;
esac

case "$interp_path" in
  *tools*|*cross-tools*)
    echo "ERRO: O program interpreter do dummy contém 'tools/cross-tools':"
    echo "      ${interp_path}"
    echo "      O GCC/binutils pass1 ainda parecem amarrados ao ambiente antigo."
    exit 1
    ;;
esac

# --------------------------------------------------------------------
# 6. Sanity extra: confirmar que a libc usada é a do ROOTFS (opcional)
# --------------------------------------------------------------------

# Este passo é mais "soft": não derrubamos o hook se falhar, mas mostramos info.
echo "    Tentando identificar a libc usada pelo dummy (informativo)..."
if "$READELF_BIN" -d "${tmpdir}/dummy" | grep -q 'NEEDED.*libc\.so'; then
  echo "    readelf: dummy depende de libc.so (ok)"
else
  echo "    AVISO: readelf não encontrou NEEDED libc.so em dummy (pode estar linkado estaticamente ou com outro nome)."
fi

echo "==> [glibc-pass1 post_install] Sanity checks concluídos com SUCESSO."
