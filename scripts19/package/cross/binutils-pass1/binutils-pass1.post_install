#!/usr/bin/env bash
# Hook de pós-instalação para Binutils-2.45.1 Pass 1
# Sanity checks do toolchain de binutils:
#   - ${TARGET_TRIPLET}-{as,ld,readelf,objdump}
#   - SEARCH_DIR de ld --verbose não deve apontar para libs do host
#   - (se disponível) usa ${TARGET_TRIPLET}-gcc para gerar dummy.o
#     e inspeciona com objdump/readelf.

set -euo pipefail

echo "==> [binutils-pass1 post_install] Iniciando sanity checks..."

# --------------------------------------------------------------------
# 1. Validar TARGET_TRIPLET, ADM_ROOTFS, CROSS_SYSROOT e CROSS_PREFIX
# --------------------------------------------------------------------

TARGET="${TARGET_TRIPLET:-}"
if [[ -z "$TARGET" ]]; then
  echo "ERRO: TARGET_TRIPLET não está definido."
  echo "      Carregue o profile (ex.: 'source profile-glibc.sh' ou 'source profile-musl.sh') antes de usar o admV2."
  exit 1
fi

ROOTFS="${ADM_ROOTFS:-/}"
case "$ROOTFS" in
  /) ;;
  */) ROOTFS="${ROOTFS%/}" ;;
esac

: "${CROSS_SYSROOT:=$ROOTFS}"
: "${CROSS_PREFIX:=/cross-tools}"

echo "    TARGET_TRIPLET = ${TARGET}"
echo "    ADM_ROOTFS     = ${ROOTFS}"
echo "    CROSS_SYSROOT  = ${CROSS_SYSROOT}"
echo "    CROSS_PREFIX   = ${CROSS_PREFIX}"

# --------------------------------------------------------------------
# 2. Localizar as ferramentas principais: as, ld, readelf, objdump
# --------------------------------------------------------------------

AS_BIN="${TARGET}-as"
LD_BIN="${TARGET}-ld"
READELF_BIN="${TARGET}-readelf"
OBJDUMP_BIN="${TARGET}-objdump"
GCC_BIN="${TARGET}-gcc"  # opcional, mas muito útil

missing=0

for b in "$AS_BIN" "$LD_BIN" "$READELF_BIN"; do
  if ! command -v "$b" >/dev/null 2>&1; then
    echo "ERRO: Não encontrei '${b}' no PATH."
    missing=1
  else
    echo "    Encontrado: ${b} -> $(command -v "$b")"
  fi
done

if [[ "$missing" -ne 0 ]]; then
  echo "ERRO: Uma ou mais ferramentas fundamentais de binutils não foram encontradas."
  exit 1
fi

if command -v "$OBJDUMP_BIN" >/dev/null 2>&1; then
  echo "    Encontrado: ${OBJDUMP_BIN} -> $(command -v "$OBJDUMP_BIN")"
else
  echo "    AVISO: '${OBJDUMP_BIN}' não está no PATH; alguns checks serão apenas informativos."
fi

if command -v "$GCC_BIN" >/dev/null 2>&1; then
  echo "    Encontrado GCC alvo: ${GCC_BIN} -> $(command -v "$GCC_BIN")"
else
  echo "    AVISO: '${GCC_BIN}' não está no PATH; não faremos o sanity com dummy.o via GCC."
fi

# --------------------------------------------------------------------
# 3. Checar SEARCH_DIR do ld --verbose
#     -> não pode apontar para /usr/lib, /lib do host
# --------------------------------------------------------------------

tmp_ld="$(mktemp -t binutils-pass1-ld-verbose-XXXXXX)"
cleanup_ld() { rm -f -- "$tmp_ld"; }
trap cleanup_ld EXIT

echo "    Capturando '${LD_BIN} --verbose' para inspecionar SEARCH_DIR..."
"$LD_BIN" --verbose >"$tmp_ld" 2>&1 || true

echo "    Diretórios de busca de bibliotecas (SEARCH_DIR):"
awk '/SEARCH_DIR\(\"/ {print "      " $0}' "$tmp_ld"

bad_lib_dirs=0

# Extrai o conteúdo entre aspas em SEARCH_DIR("=path")
while IFS= read -r line; do
  dir="$(echo "$line" | sed -n 's/.*SEARCH_DIR(\"=\(.*\)\"\).*/\1/p')"
  [[ -z "$dir" ]] && continue

  # Normaliza
  # Regras:
  #   - se começa com /usr ou /lib e NÃO está sob CROSS_SYSROOT nem sob CROSS_PREFIX, é suspeito.
  case "$dir" in
    /usr/*|/lib/*|/lib64/*)
      case "$dir" in
        "${CROSS_SYSROOT}"*|${CROSS_PREFIX}* )
          # ok, apontando para dentro do sysroot ou do prefixo de cross
          ;;
        *)
          echo "ERRO: SEARCH_DIR suspeito encontrado em ${LD_BIN}: $dir"
          echo "      Ele aparenta apontar para libs do host fora de ${CROSS_SYSROOT} e de ${CROSS_PREFIX}."
          bad_lib_dirs=1
          ;;
      esac
      ;;
  esac
done < <(awk '/SEARCH_DIR\(\"/ {print $0}' "$tmp_ld")

if [[ "$bad_lib_dirs" -ne 0 ]]; then
  echo "ERRO: ${LD_BIN} ainda está usando diretórios de bibliotecas do host."
  exit 1
fi

# --------------------------------------------------------------------
# 4. Teste de montagem/link básico (opcional, caso GCC exista)
# --------------------------------------------------------------------

tmp_build_dir="$(mktemp -d -t binutils-pass1-dummy-XXXXXX)"
cleanup_build() { rm -rf -- "$tmp_build_dir"; }
trap cleanup_build EXIT

if command -v "$GCC_BIN" >/dev/null 2>&1; then
  echo "    GCC alvo disponível; gerando dummy.o via ${GCC_BIN}..."

  cat > "${tmp_build_dir}/dummy.c" << 'EOF'
int main(void) {
    return 0;
}
EOF

  (
    cd "$tmp_build_dir"
    "$GCC_BIN" -c dummy.c -o dummy.o
  )

  if [[ ! -f "${tmp_build_dir}/dummy.o" ]]; then
    echo "ERRO: Falha ao gerar dummy.o com ${GCC_BIN}."
    exit 1
  fi

  echo "    dummy.o gerado com sucesso: ${tmp_build_dir}/dummy.o"

  # Se tivermos objdump, mostramos info do arquivo
  if command -v "$OBJDUMP_BIN" >/dev/null 2>&1; then
    echo "    Inspecionando dummy.o com ${OBJDUMP_BIN} -f (informativo)..."
    "$OBJDUMP_BIN" -f "${tmp_build_dir}/dummy.o" || true
  fi

else
  echo "    GCC alvo não encontrado; pulando sanity de dummy.o."
fi

echo "==> [binutils-pass1 post_install] Sanity checks concluídos com SUCESSO."
