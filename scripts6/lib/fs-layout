#!/usr/bin/env bash
# lib/fs-layout
# Gestão do layout de diretórios e operações de FS do projeto ADM.
# - Estrutura canônica sob adm.root
# - Getters com criação sob demanda
# - Locks robustos
# - Segurança em remoções (safe_rm)
# - Checagem de espaço e flags de montagem
# - Sincronização staging↔rootfs↔/ com dry-run/backup
# Sem set -e; todas as funções retornam status e reportam claramente.

# ---------- Guarda de múltiplos sources ----------
if [ -n "${__ADM_FS_SOURCED:-}" ]; then
  return 0 2>/dev/null || exit 0
fi
__ADM_FS_SOURCED=1

# ---------- Integrações opcionais ----------
__fs_has_log=0
if declare -F log::info >/dev/null 2>&1; then __fs_has_log=1; fi
fs::__log_info(){ [ "$__fs_has_log" -eq 1 ] && log::info "$@" || true; }
fs::__log_warn(){ [ "$__fs_has_log" -eq 1 ] && log::warn "$@" || printf '[WARN] %s\n' "$*" 1>&2; }
fs::__log_error(){ [ "$__fs_has_log" -eq 1 ] && log::error "$@" || printf '[ERROR] %s\n' "$*" 1>&2; }
fs::__log_event(){ [ "$__fs_has_log" -eq 1 ] && log::json EVENT "$@" || true; }

# ---------- Dependências suaves ----------
fs::require_bin() {
  local b="${1:-}"
  if [ -z "$b" ]; then fs::__log_error "fs::require_bin: comando não informado"; return 2; fi
  command -v "$b" >/dev/null 2>&1 || { fs::__log_error "comando obrigatório ausente" bin="$b"; return 127; }
}

# ---------- Estado ----------
__fs_root=""           # adm.root efetivo
__fs_umask_default="0022"
__fs_initialized=0

# ---------- Utilidades ----------
fs::ts() { date +%T 2>/dev/null || printf '00:00:00'; }

fs::assert_inside_root() {
  local p="$1"
  if [ -z "$__fs_root" ]; then
    fs::__log_error "assert_inside_root sem fs::init"; return 2
  fi
  if [ -z "$p" ]; then
    fs::__log_error "caminho vazio"; return 2
  fi
  case "$p" in
    "$__fs_root"/*) return 0 ;;
    "$__fs_root")   return 0 ;;
    *) fs::__log_error "fora de adm.root (bloqueado)" path="$p" root="$__fs_root"; return 3 ;;
  esac
}

fs::mkdirp_mode() {
  # $1 dir $2 mode(octal)
  local d="$1" m="${2:-0755}"
  [ -z "$d" ] && { fs::__log_error "mkdirp_mode: dir vazio"; return 2; }
  mkdir -p "$d" 2>/dev/null || { fs::__log_error "falha ao criar diretório" path="$d"; return 1; }
  chmod "$m" "$d" 2>/dev/null || true
  return 0
}

fs::__name_ok() {
  # valida <cat>/<pkg>/<ver> (sem espaços, sem / extras, sem ..)
  local n="$1"
  if [[ "$n" =~ (^|/)(\.|\.{2})(/|$) ]]; then return 1; fi
  if [[ "$n" =~ [[:space:]] ]]; then return 1; fi
  case "$n" in *//*|/*|*/|*"//"*) return 1;; esac
  return 0
}

fs::__tuple_ok() {
  local cat="$1" pkg="$2" ver="$3"
  [[ -n "$cat" && -n "$pkg" && -n "$ver" ]] || return 1
  fs::__name_ok "$cat/$pkg/$ver"
}

# ---------- fs::init ----------
fs::init() {
  # Resolve adm.root via lib/config ou default
  if declare -F config::get >/dev/null 2>&1; then
    __fs_root="$(config::get adm.root 2>/dev/null || echo /usr/src/adm)"
  else
    __fs_root="/usr/src/adm"
  fi
  [ -z "$__fs_root" ] && __fs_root="/usr/src/adm"

  # Umask segura
  umask "$__fs_umask_default" 2>/dev/null || true

  # Estrutura canônica mínima
  local dirs=(
    "$__fs_root"
    "$__fs_root/sources"
    "$__fs_root/build"
    "$__fs_root/staging"
    "$__fs_root/toolchain/stage0" "$__fs_root/toolchain/stage1" "$__fs_root/toolchain/stage2"
    "$__fs_root/stage0/rootfs" "$__fs_root/stage0/config"
    "$__fs_root/stage1/rootfs" "$__fs_root/stage1/config"
    "$__fs_root/stage2/rootfs" "$__fs_root/stage2/config"
    "$__fs_root/pkg"
    "$__fs_root/state/files"
    "$__fs_root/logs"
    "$__fs_root/metafile"
    "$__fs_root/update"
    "$__fs_root/tmp"
  )
  local d
  for d in "${dirs[@]}"; do
    fs::mkdirp_mode "$d" 0755 || return 1
    fs::__log_event "fs_mkdir" path="$d"
  done

  __fs_initialized=1
  fs::__log_info "fs init ok" root="$__fs_root"

  # Checks de flags de montagem para build/staging
  fs::check_mount_flags "$__fs_root/build"
  fs::check_mount_flags "$__fs_root/staging"
  return 0
}

# ---------- Checagem de espaço ----------
fs::check_space() {
  # fs::check_space <path> [--min-mib N | --min-percent P]
  local path="$1"; shift || true
  local min_mib="" min_pct=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --min-mib) shift; min_mib="${1:-}";;
      --min-percent) shift; min_pct="${1:-}";;
      *) fs::__log_error "parâmetro desconhecido" arg="$1"; return 2;;
    esac
    shift || true
  done
  [ -d "$path" ] || { fs::__log_error "path inexistente para check_space" path="$path"; return 2; }
  fs::require_bin df || return 127
  local line total used avail pct
  # POSIX-friendly: df -P (uma linha por FS)
  line="$(df -Pm "$path" 2>/dev/null | awk 'NR==2{print $2" "$3" "$4" "$5}')"
  total=$(echo "$line" | awk '{print $1}')
  used=$(echo "$line"  | awk '{print $2}')
  avail=$(echo "$line" | awk '{print $3}')
  pct=$(echo "$line"   | awk '{print $4}' | tr -dc '0-9')
  [ -z "$total" ] && { fs::__log_warn "não foi possível obter df"; return 0; }

  if [ -n "$min_mib" ] && [ "$avail" -lt "$min_mib" ]; then
    fs::__log_warn "espaço livre abaixo do mínimo (MiB)" path="$path" avail_mib="$avail" min_mib="$min_mib"
    return 1
  fi
  if [ -n "$min_pct" ]; then
    local free_pct=$(( 100 - pct ))
    if [ "$free_pct" -lt "$min_pct" ]; then
      fs::__log_warn "espaço livre abaixo do mínimo (%)" path="$path" free_pct="$free_pct" min_pct="$min_pct"
      return 1
    fi
  fi
  fs::__log_info "check_space ok" path="$path" avail_mib="$avail" used_pct="$pct"
  return 0
}

# ---------- Verificação de flags de montagem ----------
fs::check_mount_flags() {
  local path="$1"
  [ -z "$path" ] && { fs::__log_error "check_mount_flags: path vazio"; return 2; }
  [ -d "$path" ] || { fs::__log_warn "check_mount_flags: diretório não existe" path="$path"; return 0; }

  # /proc/self/mountinfo approach (mais confiável que mount | grep)
  if [ -r /proc/self/mountinfo ]; then
    local mnt
    mnt="$(awk -v p="$path" '
      function abspath(s){ if(s ~ /^\//) return s; else return ""; }
      { mountpoint=$5; opt=$6" "$7" "$8" "$9" "$10; if(index(p,mountpoint)==1){ if(length(mountpoint)>max){max=length(mountpoint); best=opt;}}}
      END{print best}' /proc/self/mountinfo)"
    case "$mnt" in
      *noexec*) fs::__log_warn "filesystem com noexec (pode falhar builds)" path="$path";;
    esac
    case "$mnt" in
      *nosuid*) fs::__log_warn "filesystem com nosuid (ok na maioria dos casos)" path="$path";;
    esac
    case "$mnt" in
      *nodev*)  fs::__log_warn "filesystem com nodev (ok para build)" path="$path";;
    esac
  else
    # Fallback
    mount 2>/dev/null | grep " on " >/dev/null 2>&1 || return 0
    mount | grep " on " | grep -F "$path" | grep -q noexec && fs::__log_warn "filesystem com noexec" path="$path"
  fi
  return 0
}

# ---------- Getters de caminho (com --mkdir) ----------
fs::__maybe_mkdir_flag() {
  local flag="${1:-}"
  [ "$flag" = "--mkdir" ]
}

fs::root() { [ -n "$__fs_root" ] || fs::init; printf '%s' "$__fs_root"; }

fs::dir_sources()  {
  [ -n "$__fs_root" ] || fs::init
  local p="$__fs_root/sources"; fs::__maybe_mkdir_flag "$1" && fs::mkdirp_mode "$p" 0755; printf '%s' "$p"
}

fs::dir_build() {
  [ -n "$__fs_root" ] || fs::init
  local cat="$1" pkg="$2" ver="$3" mk="${4:-}"
  fs::__tuple_ok "$cat" "$pkg" "$ver" || { fs::__log_error "tuple inválida"; return 2; }
  local p="$__fs_root/build/$cat/$pkg/$ver"
  fs::__maybe_mkdir_flag "$mk" && fs::mkdirp_mode "$p" 0755
  printf '%s' "$p"
}

fs::dir_staging() {
  [ -n "$__fs_root" ] || fs::init
  local cat="$1" pkg="$2" ver="$3" mk="${4:-}"
  fs::__tuple_ok "$cat" "$pkg" "$ver" || { fs::__log_error "tuple inválida"; return 2; }
  local p="$__fs_root/staging/$cat/$pkg/$ver"
  fs::__maybe_mkdir_flag "$mk" && fs::mkdirp_mode "$p" 0755
  printf '%s' "$p"
}

fs::dir_pkg() {
  [ -n "$__fs_root" ] || fs::init
  local p="$__fs_root/pkg"; fs::__maybe_mkdir_flag "$1" && fs::mkdirp_mode "$p" 0755; printf '%s' "$p"
}

fs::dir_pkg_artifact() {
  [ -n "$__fs_root" ] || fs::init
  local cat="$1" pkg="$2" ver="$3" profile="${4:-}" mk="${5:-}"
  fs::__tuple_ok "$cat" "$pkg" "$ver" || { fs::__log_error "tuple inválida"; return 2; }
  local base="$__fs_root/pkg/$cat/$pkg/$ver"
  fs::__maybe_mkdir_flag "$mk" && fs::mkdirp_mode "$base" 0755
  printf '%s' "$base"
}

fs::file_pkg_artifact() {
  local cat="$1" pkg="$2" ver="$3" profile="${4:-default}"
  fs::__tuple_ok "$cat" "$pkg" "$ver" || { fs::__log_error "tuple inválida"; return 2; }
  printf '%s/%s-%s-%s.tar.zst' "$__fs_root/pkg/$cat/$pkg/$ver" "$pkg" "$ver" "$profile"
}

fs::dir_state() {
  [ -n "$__fs_root" ] || fs::init
  local p="$__fs_root/state"; fs::__maybe_mkdir_flag "$1" && fs::mkdirp_mode "$p" 0755; printf '%s' "$p"
}

fs::dir_state_manifest() {
  [ -n "$__fs_root" ] || fs::init
  local cat="$1" pkg="$2" ver="$3" mk="${4:-}"
  fs::__tuple_ok "$cat" "$pkg" "$ver" || { fs::__log_error "tuple inválida"; return 2; }
  local d="$__fs_root/state/files/$cat/$pkg"
  local f="$d/$ver.manifest"
  if fs::__maybe_mkdir_flag "$mk"; then fs::mkdirp_mode "$d" 0755 || return 1; fi
  printf '%s' "$f"
}

fs::dir_logs_run() {
  [ -n "$__fs_root" ] || fs::init
  local cat="$1" pkg="$2" ver="$3" run="$4" mk="${5:-}"
  fs::__tuple_ok "$cat" "$pkg" "$ver" || { fs::__log_error "tuple inválida"; return 2; }
  [ -n "$run" ] || { fs::__log_error "run_id vazio"; return 2; }
  local d="$__fs_root/logs/$cat/$pkg/$ver/run-$run"
  fs::__maybe_mkdir_flag "$mk" && fs::mkdirp_mode "$d" 0755
  printf '%s' "$d"
}

fs::file_log() {
  local cat="$1" pkg="$2" ver="$3" run="$4" phase="$5" kind="${6:-log}"
  local d; d="$(fs::dir_logs_run "$cat" "$pkg" "$ver" "$run" --mkdir)" || return 2
  printf '%s/%s.%s' "$d" "$phase" "$kind"
}

fs::dir_metafile() {
  [ -n "$__fs_root" ] || fs::init
  local cat="$1" pkg="$2" mk="${3:-}"
  [ -n "$cat" ] && [ -n "$pkg" ] || { fs::__log_error "cat/pkg vazios"; return 2; }
  fs::__name_ok "$cat/$pkg" || { fs::__log_error "nome inválido" name="$cat/$pkg"; return 2; }
  local d="$__fs_root/metafile/$cat/$pkg"
  fs::__maybe_mkdir_flag "$mk" && fs::mkdirp_mode "$d" 0755
  printf '%s' "$d"
}

fs::dir_update() {
  [ -n "$__fs_root" ] || fs::init
  local cat="$1" pkg="$2" mk="${3:-}"
  [ -n "$cat" ] && [ -n "$pkg" ] || { fs::__log_error "cat/pkg vazios"; return 2; }
  fs::__name_ok "$cat/$pkg" || { fs::__log_error "nome inválido" name="$cat/$pkg"; return 2; }
  local d="$__fs_root/update/$cat/$pkg"
  fs::__maybe_mkdir_flag "$mk" && fs::mkdirp_mode "$d" 0755
  printf '%s' "$d"
}

fs::file_metafile() {
  local cat="$1" pkg="$2"
  local d; d="$(fs::dir_metafile "$cat" "$pkg" --mkdir)" || return 2
  printf '%s/metafile' "$d"
}

fs::file_update_metafile() {
  local cat="$1" pkg="$2"
  local d; d="$(fs::dir_update "$cat" "$pkg" --mkdir)" || return 2
  printf '%s/metafile' "$d"
}

fs::file_state() {
  [ -n "$__fs_root" ] || fs::init
  local cat="$1" pkg="$2"
  [ -n "$cat" ] && [ -n "$pkg" ] || { fs::__log_error "cat/pkg vazios"; return 2; }
  fs::__name_ok "$cat/$pkg" || { fs::__log_error "nome inválido" name="$cat/$pkg"; return 2; }
  printf '%s' "$__fs_root/state/$cat/$pkg.state"
}

fs::file_manifest() {
  local cat="$1" pkg="$2" ver="$3"
  fs::dir_state_manifest "$cat" "$pkg" "$ver" --mkdir
}

fs::dir_toolchain() {
  [ -n "$__fs_root" ] || fs::init
  local stage="$1" mk="${2:-}"
  case "$stage" in 0|1|2) ;; *) fs::__log_error "stage inválido"; return 2;; esac
  local d="$__fs_root/toolchain/stage$stage"
  fs::__maybe_mkdir_flag "$mk" && fs::mkdirp_mode "$d" 0755
  printf '%s' "$d"
}

fs::dir_stage_rootfs() {
  [ -n "$__fs_root" ] || fs::init
  local stage="$1" mk="${2:-}"
  case "$stage" in 0|1|2) ;; *) fs::__log_error "stage inválido"; return 2;; esac
  local d="$__fs_root/stage$stage/rootfs"
  fs::__maybe_mkdir_flag "$mk" && fs::mkdirp_mode "$d" 0755
  printf '%s' "$d"
}

fs::dir_stage_config() {
  [ -n "$__fs_root" ] || fs::init
  local stage="$1" mk="${2:-}"
  case "$stage" in 0|1|2) ;; *) fs::__log_error "stage inválido"; return 2;; esac
  local d="$__fs_root/stage$stage/config"
  fs::__maybe_mkdir_flag "$mk" && fs::mkdirp_mode "$d" 0755
  printf '%s' "$d"
}

fs::tmpdir() {
  [ -n "$__fs_root" ] || fs::init
  local d="$__fs_root/tmp"
  fs::__maybe_mkdir_flag "$1" && fs::mkdirp_mode "$d" 0777
  printf '%s' "$d"
}

fs::dir_hooks() {
  local cat="$1" pkg="$2" mk="${3:-}"
  local d; d="$(fs::dir_metafile "$cat" "$pkg" "$mk")" || return 2
  d="$d/hooks"; fs::__maybe_mkdir_flag "$mk" && fs::mkdirp_mode "$d" 0755
  printf '%s' "$d"
}

fs::dir_patches() {
  local cat="$1" pkg="$2" mk="${3:-}"
  local d; d="$(fs::dir_metafile "$cat" "$pkg" "$mk")" || return 2
  d="$d/patches"; fs::__maybe_mkdir_flag "$mk" && fs::mkdirp_mode "$d" 0755
  printf '%s' "$d"
}
# ---------- Locks ----------
fs::lock_acquire() {
  # fs::lock_acquire <name> [--timeout SEC]
  local name="$1"; shift || true
  local timeout=10
  while [ $# -gt 0 ]; do
    case "$1" in
      --timeout) shift; timeout="${1:-10}";;
      *) fs::__log_error "lock_acquire: parâmetro desconhecido" arg="$1"; return 2;;
    esac
    shift || true
  done
  [ -n "$name" ] || { fs::__log_error "lock_acquire: nome vazio"; return 2; }
  [ -n "$__fs_root" ] || fs::init

  local lfile="$__fs_root/tmp/.lock.$name"
  fs::mkdirp_mode "$__fs_root/tmp" 0777 || return 1

  if command -v flock >/dev/null 2>&1; then
    # shellcheck disable=SC2086
    exec {__fs_lock_fd}>"$lfile" 2>/dev/null || { fs::__log_error "não foi possível abrir lockfile" path="$lfile"; return 1; }
    if ! flock -w "$timeout" "$__fs_lock_fd"; then
      fs::__log_error "timeout ao adquirir lock" name="$name" timeout_s="$timeout"
      return 1
    fi
    printf '%s\n' "$$" > "$lfile.holder" 2>/dev/null || true
    fs::__log_event "lock_acquire" name="$name"
    return 0
  else
    # Fallback por diretório
    local dlock="${lfile}.d"
    local waited=0
    while ! mkdir "$dlock" 2>/dev/null; do
      sleep 1
      waited=$(( waited + 1 ))
      [ "$waited" -ge "$timeout" ] && { fs::__log_error "timeout ao adquirir lock (fallback)" name="$name"; return 1; }
    done
    echo "$$" > "${dlock}/holder" 2>/dev/null || true
    fs::__log_event "lock_acquire" name="$name"
    return 0
  fi
}

fs::lock_release() {
  # fs::lock_release <name>
  local name="$1"
  [ -n "$name" ] || { fs::__log_error "lock_release: nome vazio"; return 2; }
  [ -n "$__fs_root" ] || fs::init
  local lfile="$__fs_root/tmp/.lock.$name"
  if command -v flock >/dev/null 2>&1; then
    # não temos FD aqui; apenas remove holder
    rm -f "$lfile.holder" 2>/dev/null || true
    # Deixa a liberação do FD a cargo do processo que chamou acquire
    fs::__log_event "lock_release" name="$name"
    return 0
  else
    rmdir "${lfile}.d" 2>/dev/null || true
    fs::__log_event "lock_release" name="$name"
    return 0
  fi
}

# ---------- safe_rm ----------
fs::safe_rm() {
  # Remove recursivamente com checagem de prefixo adm.root
  local path="$1"
  [ -n "$path" ] || { fs::__log_error "safe_rm: path vazio"; return 2; }
  fs::assert_inside_root "$path" || return 3
  if [ -e "$path" ]; then
    rm -rf --one-file-system "$path" 2>/dev/null || { fs::__log_error "falha ao remover" path="$path"; return 1; }
    fs::__log_event "fs_rm" path="$path"
    return 0
  else
    fs::__log_warn "safe_rm: caminho não existe" path="$path"
    return 0
  fi
}

# ---------- ensure_mode/ensure_owner ----------
fs::ensure_mode() {
  local path="$1" mode="$2" rec="${3:-}"
  [ -e "$path" ] || { fs::__log_error "ensure_mode: path não existe" path="$path"; return 2; }
  [ -z "$mode" ] && { fs::__log_error "ensure_mode: modo vazio"; return 2; }
  if [ "$rec" = "--recurse" ]; then
    chmod -R "$mode" "$path" 2>/dev/null || { fs::__log_warn "não foi possível chmod recursivo" path="$path" mode="$mode"; return 1; }
  else
    chmod "$mode" "$path" 2>/dev/null || { fs::__log_warn "não foi possível chmod" path="$path" mode="$mode"; return 1; }
  fi
  return 0
}

fs::ensure_owner() {
  local path="$1" owner="$2" rec="${3:-}"
  [ -e "$path" ] || { fs::__log_error "ensure_owner: path não existe" path="$path"; return 2; }
  [ -z "$owner" ] && { fs::__log_error "ensure_owner: owner vazio"; return 2; }
  if ! command -v chown >/dev/null 2>&1; then
    fs::__log_warn "chown não disponível; ignorando"
    return 0
  fi
  if [ "$rec" = "--recurse" ]; then
    chown -R "$owner" "$path" 2>/dev/null || { fs::__log_warn "não foi possível chown recursivo" path="$path" owner="$owner"; return 1; }
  else
    chown "$owner" "$path" 2>/dev/null || { fs::__log_warn "não foi possível chown" path="$path" owner="$owner"; return 1; }
  fi
  return 0
}

# ---------- mkcd ----------
fs::mkcd() {
  local d="$1"
  [ -n "$d" ] || { fs::__log_error "mkcd: dir vazio"; return 2; }
  fs::mkdirp_mode "$d" 0755 || return 1
  cd "$d" 2>/dev/null || { fs::__log_error "não foi possível cd" path="$d"; return 1; }
  return 0
}

# ---------- staging prefix ----------
fs::staging_prefix() {
  # retorna o rootfs do stage (destino final para install no estágio)
  local stage="${1:-}"
  case "$stage" in 0|1|2) ;; *) fs::__log_error "stage inválido"; return 2;; esac
  fs::dir_stage_rootfs "$stage" --mkdir
}

# ---------- Sincronização staging → rootfs ----------
fs::__rsync_available() { command -v rsync >/dev/null 2>&1; }

fs::stage_sync_to_root() {
  # fs::stage_sync_to_root <stage> <cat> <pkg> <ver> [--dry-run] [--backup]
  local stage="$1" cat="$2" pkg="$3" ver="$4"; shift 4 || true
  local dry=0 backup=0
  while [ $# -gt 0 ]; do
    case "$1" in
      --dry-run) dry=1;;
      --backup)  backup=1;;
      *) fs::__log_error "parâmetro desconhecido" arg="$1"; return 2;;
    esac
    shift || true
  done
  fs::__tuple_ok "$cat" "$pkg" "$ver" || { fs::__log_error "tuple inválida"; return 2; }

  local src; src="$(fs::dir_staging "$cat" "$pkg" "$ver")" || return 2
  local dst; dst="$(fs::staging_prefix "$stage")" || return 2

  [ -d "$src" ] || { fs::__log_error "staging inexistente" path="$src"; return 1; }
  fs::assert_inside_root "$src" || return 3
  fs::assert_inside_root "$dst" || return 3

  fs::__log_info "sync staging→rootfs" stage="$stage" src="$src" dst="$dst" dry="$dry" backup="$backup"
  fs::__log_event "fs_sync_start" src="$src" dst="$dst" stage="$stage"

  if fs::__rsync_available; then
    local args="-aHAX --delete-after"
    [ "$dry" -eq 1 ] && args="$args -n"
    [ "$backup" -eq 1 ] && args="$args --backup --backup-dir=$__fs_root/tmp/backup-stage$stage-$(date +%Y%m%d-%H%M%S)"
    rsync $args "$src"/ "$dst"/ 2>/dev/null || { fs::__log_error "rsync falhou"; return 1; }
  else
    # Fallback: tar pipe (sem --delete)
    if [ "$dry" -eq 1 ]; then
      (cd "$src" && find . -type f | sed 's|^\./||') | head -n 5 >/dev/null
    else
      (cd "$src" && tar cf - .) | (cd "$dst" && tar xpf -) 2>/dev/null || { fs::__log_error "tar fallback falhou"; return 1; }
    fi
    [ "$backup" -eq 1 ] && fs::__log_warn "backup não suportado no fallback tar"
  fi

  # Manifest
  local mf; mf="$(fs::file_manifest "$cat" "$pkg" "$ver")" || return 2
  fs::mkdirp_mode "$(dirname "$mf")" 0755 || return 1
  (cd "$dst" && find . -xdev -print | sed 's|^\./|/|') > "$mf" 2>/dev/null || { fs::__log_warn "falha ao gerar manifest (parcial)"; }

  fs::__log_event "fs_sync_end" src="$src" dst="$dst" stage="$stage"
  return 0
}

# ---------- Sincronização rootfs → / (finalize) ----------
fs::root_sync_to_system() {
  # fs::root_sync_to_system <stage> [--dry-run] [--backup]
  local stage="$1"; shift || true
  local dry=0 backup=0
  while [ $# -gt 0 ]; do
    case "$1" in
      --dry-run) dry=1;;
      --backup)  backup=1;;
      *) fs::__log_error "parâmetro desconhecido" arg="$1"; return 2;;
    esac
    shift || true
  done
  case "$stage" in 0|1|2) ;; *) fs::__log_error "stage inválido"; return 2;; esac

  local src; src="$(fs::dir_stage_rootfs "$stage")" || return 2
  [ -d "$src" ] || { fs::__log_error "rootfs inexistente" path="$src"; return 1; }

  fs::__log_info "sync rootfs→/" stage="$stage" src="$src" dry="$dry" backup="$backup"
  fs::__log_event "fs_sync_start" src="$src" dst="/" stage="$stage"

  if fs::__rsync_available; then
    local args="-aHAX --delete-after"
    [ "$dry" -eq 1 ] && args="$args -n"
    [ "$backup" -eq 1 ] && args="$args --backup --backup-dir=$__fs_root/tmp/backup-system-$(date +%Y%m%d-%H%M%S)"
    rsync $args "$src"/ / 2>/dev/null || { fs::__log_error "rsync falhou (rootfs→/)"; return 1; }
  else
    if [ "$dry" -eq 1 ]; then
      (cd "$src" && find . -type f | head -n 5) >/dev/null
    else
      (cd "$src" && tar cf - .) | (cd / && tar xpf -) 2>/dev/null || { fs::__log_error "tar fallback falhou (rootfs→/)"; return 1; }
    fi
    [ "$backup" -eq 1 ] && fs::__log_warn "backup não suportado no fallback tar"
  fi

  fs::__log_event "fs_sync_end" src="$src" dst="/" stage="$stage"
  return 0
}

# ---------- Tripwire/validações de integridade ----------
fs::validate_tripwire() {
  # Procura entradas perigosas em staging (symlinks fora, .., suid inesperado)
  local cat="$1" pkg="$2" ver="$3"
  local st; st="$(fs::dir_staging "$cat" "$pkg" "$ver")" || return 2
  [ -d "$st" ] || { fs::__log_warn "staging não existe para tripwire" path="$st"; return 0; }

  local rc=0
  # Symlinks que escapam
  while IFS= read -r -d '' l; do
    local tgt; tgt="$(readlink -f "$l" 2>/dev/null || true)"
    if [ -n "$tgt" ] && ! fs::assert_inside_root "$tgt" >/dev/null 2>&1; then
      fs::__log_error "symlink escapa do root" link="$l" target="$tgt"; rc=1
    fi
  done < <(find "$st" -type l -print0 2>/dev/null)

  # SUID/SGID
  while IFS= read -r -d '' f; do
    fs::__log_warn "arquivo com suid/sgid em staging" file="$f"
  done < <(find "$st" -perm /6000 -print0 2>/dev/null)

  return "$rc"
}

# ---------- Sealing de staging ----------
fs::seal_staging() {
  local cat="$1" pkg="$2" ver="$3"
  local st; st="$(fs::dir_staging "$cat" "$pkg" "$ver")" || return 2
  [ -d "$st" ] || { fs::__log_error "staging não existe para selar" path="$st"; return 1; }
  : > "$st/.sealed" 2>/dev/null || { fs::__log_warn "não foi possível selar staging" path="$st"; return 1; }
  fs::__log_event "fs_seal" path="$st"
  return 0
}

# ---------- Fim seguro ----------
return 0 2>/dev/null || true
