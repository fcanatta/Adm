#!/usr/bin/env bash
# lib/colors-and-ui
# Biblioteca de UI padronizada para o projeto ADM.
# - Detecção de TTY, cores, Unicode, e temas
# - Saída bonita com boxes, tabelas, status-line e spinner
# - Fallback limpo para CI (sem TTY) e ASCII
# - Nenhum "set -e": funções retornam códigos de erro
# - Robustez contra erros silenciosos (checagem de argumentos, estados)
# - Namespacing por prefixo ui::
# ---------- Guardas básicas ----------
if [ -n "${__ADM_UI_SOURCED:-}" ]; then
  return 0 2>/dev/null || exit 0
fi
__ADM_UI_SOURCED=1

# ---------- Variáveis globais (somente deste módulo) ----------
# Estados
__ui_is_tty=0
__ui_use_color=0
__ui_use_unicode=0
__ui_quiet=0
__ui_verbose=0
__ui_theme="default"

# Símbolos (preenchidos após init)
__ui_sym_ok=""
__ui_sym_fail=""
__ui_sym_warn=""
__ui_sym_info=""
__ui_sym_bullet=""
__ui_sym_play=""
__ui_sym_wait=""
__ui_sym_ellipsis=""

# Cores (tokens semânticos → sequências ANSI)
# Mantemos em "variáveis" pois arrays associativos podem não existir em bash < 4 em ambientes raros.
__ui_c_reset=""
__ui_c_bold=""
__ui_c_dim=""
__ui_c_stage=""
__ui_c_path=""
__ui_c_ok=""
__ui_c_warn=""
__ui_c_err=""
__ui_c_info=""

# Spinner
__ui_spinner_pid=""
__ui_spinner_frames_basic='|/-\'
__ui_spinner_frames_unicode='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
__ui_spinner_interval=0.1
__ui_spinner_active=0
__ui_spinner_message=""
__ui_spinner_deferred_start_ms=120
__ui_spinner_started_epoch=0
__ui_spinner_defer_timer_pid=""

# Temporização
__ui_stage_started_epoch=0

# Exec context
__ui_run_id="${ADM_RUN_ID:-}"

# ---------- Utilidades internas ----------
ui::ts() {
  # HH:MM:SS
  date +%T 2>/dev/null || printf '%s' "00:00:00"
}

ui::epoch_ms() {
  # Retorna epoch em milissegundos (fallback caso date não suporte %N)
  if command -v date >/dev/null 2>&1; then
    if date +%s%3N >/dev/null 2>&1; then
      date +%s%3N
      return
    fi
    # Fallback: segundos * 1000
    printf '%s000' "$(date +%s)"
    return
  fi
  printf '0'
}

ui::duration() {
  # $1 inicio_epoch_ms  $2 fim_epoch_ms
  local start="${1:-0}" end="${2:-$(ui::epoch_ms)}" ms sec min hr
  if ! [ "$start" -ge 0 ] 2>/dev/null; then start=0; fi
  if ! [ "$end" -ge "$start" ] 2>/dev/null; then end="$start"; fi
  ms=$(( end - start ))
  sec=$(( ms / 1000 ))
  hr=$(( sec / 3600 ))
  min=$(( (sec % 3600) / 60 ))
  sec=$(( sec % 60 ))
  if [ "$hr" -gt 0 ]; then
    printf "%02d:%02d:%02d" "$hr" "$min" "$sec"
  else
    printf "%02d:%02d" "$min" "$sec"
  fi
}

ui::term_width() {
  local w
  if [ "$__ui_is_tty" -eq 1 ] && command -v tput >/dev/null 2>&1; then
    w=$(tput cols 2>/dev/null || printf '80')
  else
    w="${COLUMNS:-80}"
  fi
  # Sanitiza
  if ! [ "$w" -ge 40 ] 2>/dev/null; then w=80; fi
  printf '%s' "$w"
}

ui::repeat() {
  # repete caractere N vezes
  # $1 char $2 N
  local ch="${1:- }" n="${2:-1}" i
  if ! [ "$n" -ge 1 ] 2>/dev/null; then return 0; fi
  for i in $(seq 1 "$n"); do printf '%s' "$ch"; done
}

ui::strip_ansi() {
  # Remove sequências ANSI
  sed -E 's/\x1b\[[0-9;]*m//g'
}

ui::truncate() {
  # $1 texto $2 largura
  local text="${1-}" width="${2:-80}" len
  [ -z "$text" ] && { printf '' ; return; }
  if ! [ "$width" -ge 8 ] 2>/dev/null; then width=80; fi
  # Tira ansi para contar tamanho real
  local plain
  plain="$(printf '%s' "$text" | ui::strip_ansi)"
  len=${#plain}
  if [ "$len" -le "$width" ]; then
    printf '%s' "$text"
    return
  fi
  # Mantém sufixo (como caminhos)
  local keep=$(( width - 1 - 2 )) # "…/" = 2 (~) + 1 char de margem
  if [ "$keep" -lt 4 ]; then keep=4; fi
  printf '…%s' "$(printf '%s' "$plain" | tail -c "$keep" 2>/dev/null || printf '%s' "${plain: -$keep}")"
}

# ---------- Detecções ----------
ui::detect_tty() {
  if [ -t 1 ]; then __ui_is_tty=1; else __ui_is_tty=0; fi
}

ui::detect_unicode() {
  # Unicode se LANG/LC_* contém UTF-8 e não estiver desabilitado
  case "${LC_ALL:-${LC_CTYPE:-${LANG:-}}}" in
    *UTF-8*|*utf8*) __ui_use_unicode=1 ;;
    *) __ui_use_unicode=0 ;;
  esac
  # Força ASCII se ADM_SYMBOLS=ascii
  if [ "${ADM_SYMBOLS:-auto}" = "ascii" ]; then __ui_use_unicode=0; fi
  # Força Unicode se pedido explicitamente
  if [ "${ADM_SYMBOLS:-auto}" = "unicode" ]; then __ui_use_unicode=1; fi
}

ui::detect_color() {
  # Política: usa cor se (TTY e não ADM_NO_COLOR) ou ADM_FORCE_COLOR
  if [ "${ADM_NO_COLOR:-0}" = "1" ]; then __ui_use_color=0; return; fi
  if [ "${ADM_FORCE_COLOR:-0}" = "1" ]; then __ui_use_color=1; return; fi
  if [ "$__ui_is_tty" -eq 1 ]; then __ui_use_color=1; else __ui_use_color=0; fi
}

# ---------- Temas ----------
# Cada tema define tokens semânticos (stage/path/ok/warn/err/info/bold/dim/reset)
# Para máxima compatibilidade, usamos códigos 8/16 cores.

ui::__apply_theme_default() {
  if [ "$__ui_use_color" -eq 1 ]; then
    __ui_c_reset=$'\033[0m'
    __ui_c_bold=$'\033[1m'
    __ui_c_dim=$'\033[2m'
    __ui_c_stage=$'\033[35;1m'  # magenta bold (rosa)
    __ui_c_path=$'\033[33m'     # amarelo
    __ui_c_ok=$'\033[32m'       # verde
    __ui_c_warn=$'\033[33m'     # amarelo
    __ui_c_err=$'\033[31m'      # vermelho
    __ui_c_info=$'\033[36m'     # ciano
  else
    __ui_c_reset=""; __ui_c_bold=""; __ui_c_dim=""
    __ui_c_stage=""; __ui_c_path=""; __ui_c_ok=""
    __ui_c_warn=""; __ui_c_err=""; __ui_c_info=""
  fi
}

ui::__apply_theme_premium() {
  if [ "$__ui_use_color" -eq 1 ]; then
    __ui_c_reset=$'\033[0m'
    __ui_c_bold=$'\033[1m'
    __ui_c_dim=$'\033[2m'
    __ui_c_stage=$'\033[95;1m'  # bright magenta bold
    __ui_c_path=$'\033[93m'     # bright yellow
    __ui_c_ok=$'\033[92m'       # bright green
    __ui_c_warn=$'\033[93m'     # bright yellow
    __ui_c_err=$'\033[91m'      # bright red
    __ui_c_info=$'\033[96m'     # bright cyan
  else
    __ui_c_reset=""; __ui_c_bold=""; __ui_c_dim=""
    __ui_c_stage=""; __ui_c_path=""; __ui_c_ok=""
    __ui_c_warn=""; __ui_c_err=""; __ui_c_info=""
  fi
}

ui::__apply_theme_flat() {
  # Flat: cores discretas; bom para logs extensos
  if [ "$__ui_use_color" -eq 1 ]; then
    __ui_c_reset=$'\033[0m'
    __ui_c_bold=$'\033[1m'
    __ui_c_dim=$'\033[2m'
    __ui_c_stage=$'\033[35m'    # magenta normal
    __ui_c_path=$'\033[33m'     # amarelo
    __ui_c_ok=$'\033[32m'
    __ui_c_warn=$'\033[33m'
    __ui_c_err=$'\033[31m'
    __ui_c_info=$'\033[36m'
  else
    __ui_c_reset=""; __ui_c_bold=""; __ui_c_dim=""
    __ui_c_stage=""; __ui_c_path=""; __ui_c_ok=""
    __ui_c_warn=""; __ui_c_err=""; __ui_c_info=""
  fi
}

ui::theme() {
  # $1 default|premium|flat
  local t="${1:-default}"
  case "$t" in
    default) __ui_theme="default"; ui::__apply_theme_default ;;
    premium) __ui_theme="premium"; ui::__apply_theme_premium ;;
    flat)    __ui_theme="flat";    ui::__apply_theme_flat ;;
    *)       __ui_theme="default"; ui::__apply_theme_default ;;
  esac
}

# ---------- Símbolos ----------
ui::set_symbols() {
  if [ "$__ui_use_unicode" -eq 1 ]; then
    __ui_sym_ok="✅"; __ui_sym_fail="❌"; __ui_sym_warn="⚠️"
    __ui_sym_info="ℹ️"; __ui_sym_bullet="•"; __ui_sym_play="▶"
    __ui_sym_wait="⏳"; __ui_sym_ellipsis="…"
  else
    __ui_sym_ok="OK"; __ui_sym_fail="FAIL"; __ui_sym_warn="WARN"
    __ui_sym_info="INFO"; __ui_sym_bullet="*"; __ui_sym_play=">"
    __ui_sym_wait="..."; __ui_sym_ellipsis="..."
  fi
}

# ---------- Flags e inicialização ----------
ui::set-quiet()  { __ui_quiet=$([ "${1:-0}" = "1" ] && echo 1 || echo 0); }
ui::set-verbose(){ __ui_verbose=$([ "${1:-0}" = "1" ] && echo 1 || echo 0); }

ui::init() {
  ui::detect_tty
  ui::detect_unicode
  ui::detect_color

  # CLI → env overrides
  if [ "${ADM_QUIET:-0}" = "1" ]; then __ui_quiet=1; fi
  if [ "${ADM_VERBOSE:-0}" = "1" ]; then __ui_verbose=1; fi

  # Carrega tema via env ou default
  ui::theme "${ADM_THEME:-default}"
  ui::set_symbols

  # Carrega cores.conf se existir (permite override leve: color.path=33 etc.)
  local cfg="/usr/src/adm/config/colors.conf"
  if [ -r "$cfg" ]; then
    while IFS='=' read -r k v; do
      case "$k" in
        \#*|"") continue;;
        color.reset) [ -n "$v" ] && __ui_c_reset=$'\033'"[${v}m" ;;
        color.bold)  [ -n "$v" ] && __ui_c_bold=$'\033'"[${v}m" ;;
        color.dim)   [ -n "$v" ] && __ui_c_dim=$'\033'"[${v}m" ;;
        color.stage) [ -n "$v" ] && __ui_c_stage=$'\033'"[${v}m" ;;
        color.path)  [ -n "$v" ] && __ui_c_path=$'\033'"[${v}m" ;;
        color.ok)    [ -n "$v" ] && __ui_c_ok=$'\033'"[${v}m" ;;
        color.warn)  [ -n "$v" ] && __ui_c_warn=$'\033'"[${v}m" ;;
        color.err)   [ -n "$v" ] && __ui_c_err=$'\033'"[${v}m" ;;
        color.info)  [ -n "$v" ] && __ui_c_info=$'\033'"[${v}m" ;;
      esac
    done < "$cfg"
  fi

  # Registra trap pra limpar spinner/ANSI em interrupções
  trap 'ui::__cleanup_on_exit' INT TERM EXIT
}

ui::__cleanup_on_exit() {
  ui::spinner_stop >/dev/null 2>&1 || true
  # Garante reset de ANSI se algo ficar aberto
  printf '%b' "$__ui_c_reset" >/dev/null 2>&1 || true
}

# ---------- Tokens/estilos ----------
ui::color() {
  case "${1:-}" in
    reset) printf '%b' "$__ui_c_reset" ;;
    bold)  printf '%b' "$__ui_c_bold" ;;
    dim)   printf '%b' "$__ui_c_dim" ;;
    stage) printf '%b' "$__ui_c_stage" ;;
    path)  printf '%b' "$__ui_c_path" ;;
    ok)    printf '%b' "$__ui_c_ok" ;;
    warn)  printf '%b' "$__ui_c_warn" ;;
    err)   printf '%b' "$__ui_c_err" ;;
    info)  printf '%b' "$__ui_c_info" ;;
    *)     printf '' ;;
  esac
}

ui::reset() { printf '%b' "$__ui_c_reset"; }

ui::emph() {
  # negrito seguro
  printf '%b%s%b' "$__ui_c_bold" "${*:-}" "$__ui_c_reset"
}

ui::path() {
  local p="${*:-/}"
  printf '%b%s%b' "$__ui_c_path" "$p" "$__ui_c_reset"
}

# ---------- Seções e linhas ----------
ui::hr() {
  local w; w=$(ui::term_width)
  printf '%s\n' "$(ui::repeat '─' "$w")"
}

ui::section() {
  # Cabeçalho simples
  local title="${*:-}"
  [ "$__ui_quiet" -eq 1 ] && return 0
  printf '%b%s%b %s\n' "$(ui::color stage)" "$(ui::ts)" "$(ui::color reset)" "$(ui::emph "$title")"
}

ui::section_box() {
  # Caixa bonita
  local title="${*:-}"
  [ "$__ui_quiet" -eq 1 ] && return 0
  local w pad ln
  w=$(ui::term_width)
  ln=$(ui::repeat '━' "$(( w - 2 ))")
  printf '%b┏%s┓%b\n' "$(ui::color stage)" "$ln" "$(ui::color reset)"
  # Título truncado com emoji Play se suportado
  local tag
  tag=$([ "$__ui_use_unicode" -eq 1 ] && printf '%s' "$__ui_sym_play" || printf '>')
  pad=$(( w - 4 ))
  printf '%b┃%b %s  %s%b%*s%b┃%b\n' \
    "$(ui::color stage)" "$(ui::color bold)" "$tag" "$title" "$(ui::color reset)" 0 "" "$(ui::color stage)" "$(ui::color reset)"
  printf '%b┗%s┛%b\n' "$(ui::color stage)" "$ln" "$(ui::color reset)"
}

# key=value alinhado
ui::kv() {
  # $1 key $2 value
  [ "$__ui_quiet" -eq 1 ] && return 0
  local k="${1:-}"; shift || true
  local v="${*:-}"
  printf '   %b%-10s%b : %s\n' "$(ui::color bold)" "$k" "$(ui::color reset)" "$v"
}

# List item
ui::list_item() {
  [ "$__ui_quiet" -eq 1 ] && return 0
  local b="$__ui_sym_bullet"
  printf '   %s %s\n' "$b" "$*"
}

# ---------- Tabela simples ----------
__ui_table_active=0
__ui_table_cols=0
__ui_table_widths=""

ui::table_begin() {
  [ "$__ui_quiet" -eq 1 ] && { __ui_table_active=1; __ui_table_cols=0; __ui_table_widths=""; return 0; }
  __ui_table_active=1
  __ui_table_cols=0
  __ui_table_widths=""
  # borda superior
  local w; w=$(ui::term_width)
  local line; line=$(ui::repeat '─' "$(( w - 2 ))")
  printf '┌%s┐\n' "$line"
}

ui::table_row() {
  # Aceita N colunas, calcula largura uniforme
  [ "$__ui_table_active" -eq 0 ] && return 0
  local cols=("$@") n=${#cols[@]} i
  if [ "$n" -eq 0 ]; then return 0; fi
  local w; w=$(ui::term_width)
  local inner=$(( w - 2 ))
  local gap=$(( n - 1 ))
  [ "$gap" -lt 0 ] && gap=0
  local per=$(( (inner - gap) / n ))
  [ "$per" -lt 5 ] && per=5

  # imprime linha com truncamento por coluna
  local out="│"
  for i in $(seq 1 "$n"); do
    local c="${cols[$(( i - 1 ))]}"
    c="$(ui::truncate "$c" "$per")"
    # padding
    local pad=$(( per - ${#c} ))
    [ "$pad" -lt 0 ] && pad=0
    out+="$(printf '%s%s' "$c" "$(ui::repeat ' ' "$pad")")"
    if [ "$i" -lt "$n" ]; then out+="│"; fi
  done
  out+="│"
  printf '%s\n' "$out"
}

ui::table_sep() {
  [ "$__ui_table_active" -eq 0 ] && return 0
  local w; w=$(ui::term_width)
  local line; line=$(ui::repeat '─' "$(( w - 2 ))")
  printf '├%s┤\n' "$line"
}

ui::table_end() {
  [ "$__ui_table_active" -eq 0 ] && return 0
  __ui_table_active=0
  local w; w=$(ui::term_width)
  local line; line=$(ui::repeat '─' "$(( w - 2 ))")
  printf '└%s┘\n' "$line"
}

# ---------- Mensagens ----------
ui::info()  { [ "$__ui_quiet" -eq 1 ] && return 0; printf '%b%s%b %s\n' "$(ui::color info)" "$__ui_sym_info" "$(ui::color reset)" "$*"; }
ui::ok()    { [ "$__ui_quiet" -eq 1 ] && return 0; printf '%b%s%b %s\n' "$(ui::color ok)" "$__ui_sym_ok" "$(ui::color reset)" "$*"; }
ui::warn()  { [ "$__ui_quiet" -eq 1 ] && return 0; printf '%b%s%b %s\n' "$(ui::color warn)" "$__ui_sym_warn" "$(ui::color reset)" "$*"; }
ui::error() { printf '%b%s%b %s\n' "$(ui::color err)" "$__ui_sym_fail" "$(ui::color reset)" "$*" 1>&2; }
ui::debug() { [ "$__ui_verbose" -eq 1 ] && printf '%bDEBUG%b %s\n' "$(ui::color dim)" "$(ui::color reset)" "$*"; }

# ---------- Status-line de etapa ----------
ui::stage_start() {
  # $1 ETAPA $2 CAT $3 PKG $4 VER $5 CAMINHO [$6 THREADS]
  local step="${1:-STEP}" cat="${2:-cat}" pkg="${3:-pkg}" ver="${4:-0}" path="${5:-/}" thr="${6:-}"
  __ui_stage_started_epoch="$(ui::epoch_ms)"
  __ui_spinner_message=""
  [ "$__ui_quiet" -eq 1 ] && return 0

  local ts; ts="$(ui::ts)"
  local hdr="$(ui::emph "$step")"
  local id="$cat/$pkg $ver"
  local tinfo
  [ -n "$thr" ] && tinfo="  ($(printf '%s' "$thr" | sed 's/[^0-9]//g') threads)" || tinfo=""

  # Caminho colorido
  local pcolored; pcolored="$(ui::path "$path")"

  # Linha única
  printf '%s %b%s%b :: %s :: %s%s\n' \
    "[$ts]" "$(ui::color stage)" "$hdr" "$(ui::color reset)" "$id" "$pcolored" "$tinfo"

  # spinner
  ui::spinner_start " $step…"
}

ui::stage_update() {
  # atualiza mensagem secundaria do spinner
  __ui_spinner_message="${*:-}"
}

ui::stage_ok() {
  # imprime ✓ com duração
  local end_ms; end_ms="$(ui::epoch_ms)"
  local dur; dur="$(ui::duration "$__ui_stage_started_epoch" "$end_ms")"
  ui::spinner_stop
  [ "$__ui_quiet" -eq 1 ] && return 0
  printf '%s %b%s%b %s %s\n' \
    "[$(ui::ts)]" "$(ui::color ok)" "$__ui_sym_ok" "$(ui::color reset)" "Concluído" "($dur)"
}

ui::stage_warn() {
  local msg="${*:-}"
  ui::spinner_stop
  [ "$__ui_quiet" -eq 1 ] && return 0
  printf '%s %b%s%b %s\n' "[$(ui::ts)]" "$(ui::color warn)" "$__ui_sym_warn" "$(ui::color reset)" "$msg"
}

ui::stage_fail() {
  # $1 mensagem [ $2 rc ]
  local msg="${1:-Falha}"; local rc="${2:-1}"
  ui::spinner_stop
  printf '%s %b%s%b %s\n' "[$(ui::ts)]" "$(ui::color err)" "$__ui_sym_fail" "$(ui::color reset)" "$msg" 1>&2
  return "$rc"
}

# ---------- Spinner ----------
ui::__spinner_tick() {
  # processo em background
  # Usa frames unicode se disponível e TTY; senão ASCII; senão no-ops
  local frames interval i=0 nf msg ts
  if [ "$__ui_is_tty" -ne 1 ]; then
    # Sem TTY: não desenha spinner (noop)
    while kill -0 "$__ui_spinner_pid_parent" 2>/dev/null; do sleep 1; done
    exit 0
  fi

  if [ "$__ui_use_unicode" -eq 1 ]; then
    frames="$__ui_spinner_frames_unicode"
  else
    frames="$__ui_spinner_frames_basic"
  fi
  interval="${__ui_spinner_interval}"

  nf=${#frames}
  [ "$nf" -eq 0 ] && frames='|/-\' && nf=4

  while : ; do
    # pega frame i
    local ch
    ch="${frames:$(( i % nf )):1}"
    msg="${__ui_spinner_message}"
    ts="$(ui::ts)"
    # imprime na mesma linha
    printf '\r%b%s%b %s' "$(ui::color info)" "$ch" "$(ui::color reset)" "$msg"
    i=$(( i + 1 ))
    # flush
    printf '' 1>&1
    sleep "$interval"
  done
}

ui::spinner_start() {
  # $1 mensagem
  [ "$__ui_quiet" -eq 1 ] && return 0
  [ "$__ui_spinner_active" -eq 1 ] && return 0
  __ui_spinner_message="${*:-}"
  __ui_spinner_active=1
  __ui_spinner_started_epoch="$(ui::epoch_ms)"

  # Defer start: não mostrar spinner se a tarefa terminar muito rápido
  # Inicia um timer; se ainda ativo após defer, lança o spinner
  (
    sleep "$(awk "BEGIN{print ${__ui_spinner_deferred_start_ms}/1000}" 2>/dev/null || echo 0.12)"
    if [ "$__ui_spinner_active" -eq 1 ]; then
      __ui_spinner_pid_parent=$$
      ui::__spinner_tick &
      echo $! >"${TMPDIR:-/tmp}/.adm_spinner.$$"
    fi
  ) &
  __ui_spinner_defer_timer_pid=$!
}

ui::spinner_stop() {
  # Para spinner (e timer se ainda não iniciou o tick)
  if [ -n "$__ui_spinner_defer_timer_pid" ] && kill -0 "$__ui_spinner_defer_timer_pid" 2>/dev/null; then
    kill "$__ui_spinner_defer_timer_pid" >/dev/null 2>&1 || true
  fi
  __ui_spinner_defer_timer_pid=""

  # Se o tick já está rodando, mata o processo
  local sp_file="${TMPDIR:-/tmp}/.adm_spinner.$$"
  if [ -f "$sp_file" ]; then
    local pid
    pid="$(cat "$sp_file" 2>/dev/null || true)"
    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
      # apaga a linha do spinner
      if [ "$__ui_is_tty" -eq 1 ]; then printf '\r\033[K' ; fi
      kill "$pid" >/dev/null 2>&1 || true
      wait "$pid" 2>/dev/null || true
    fi
    rm -f "$sp_file" >/dev/null 2>&1 || true
  fi
  __ui_spinner_active=0
  __ui_spinner_message=""
  # garante limpar a linha
  if [ "$__ui_is_tty" -eq 1 ]; then printf '\r\033[K' ; fi
  return 0
}
# ---------- Caixas de sucesso/erro ----------
ui::success_box() {
  [ "$__ui_quiet" -eq 1 ] && return 0
  local msg="${*:-Sucesso}"
  local w; w=$(ui::term_width)
  local line; line=$(ui::repeat '━' "$(( w - 2 ))")
  printf '%b┏%s┓%b\n' "$(ui::color ok)" "$line" "$(ui::color reset)"
  printf '%b┃ %s  %s%b%*s┃%b\n' \
    "$(ui::color ok)" "$__ui_sym_ok" "$msg" "$(ui::color reset)" 0 "" "$(ui::color ok)" "$(ui::color reset)"
  printf '%b┗%s┛%b\n' "$(ui::color ok)" "$line" "$(ui::color reset)"
}

ui::fail_box() {
  local msg="${*:-Falha}"
  local w; w=$(ui::term_width)
  local line; line=$(ui::repeat '━' "$(( w - 2 ))")
  printf '%b┏%s┓%b\n' "$(ui::color err)" "$line" "$(ui::color reset)" 1>&2
  printf '%b┃ %s  %s%b%*s┃%b\n' \
    "$(ui::color err)" "$__ui_sym_fail" "$msg" "$(ui::color reset)" 0 "" "$(ui::color err)" "$(ui::color reset)" 1>&2
  printf '%b┗%s┛%b\n' "$(ui::color err)" "$line" "$(ui::color reset)" 1>&2
}

# ---------- Progress bar simples (opcional) ----------
ui::progress() {
  # $1 cur $2 max [label]
  [ "$__ui_quiet" -eq 1 ] && return 0
  local cur="${1:-0}" max="${2:-100}" label="${3:-}"
  if ! [ "$max" -gt 0 ] 2>/dev/null; then max=100; fi
  if ! [ "$cur" -ge 0 ] 2>/dev/null; then cur=0; fi
  if [ "$cur" -gt "$max" ]; then cur="$max"; fi

  local w; w=$(ui::term_width)
  local barw=$(( w - 12 ))
  [ "$barw" -lt 10 ] && barw=10
  local fill=$(( cur * barw / max ))
  local empty=$(( barw - fill ))
  local pct=$(( cur * 100 / max ))
  printf '\r[%s%s] %3d%% %s' \
    "$(ui::repeat '#'. "$fill")" "$(ui::repeat ' ' "$empty")" "$pct" "$label"
  if [ "$cur" -eq "$max" ]; then printf '\n'; fi
}

# ---------- Utilidades de validação ----------
ui::require() {
  # Falha elegante se um binário essencial estiver ausente
  # $1 comando
  local cmd="${1:-}"
  if [ -z "$cmd" ]; then ui::error "ui::require: comando não informado"; return 2; fi
  if ! command -v "$cmd" >/dev/null 2>&1; then
    ui::error "Comando obrigatório ausente: $cmd"
    return 127
  fi
  return 0
}

# ---------- Tema público ----------
ui::set_theme() {
  # Alias público com validação extra e log
  local t="${1:-default}"
  ui::theme "$t"
  [ "$__ui_quiet" -eq 1 ] || ui::info "Tema aplicado: $(ui::emph "$__ui_theme")"
}

# ---------- Modo CI (flat/sem ornamentos) ----------
ui::apply_ci_defaults() {
  # Para CI: força flat, sem spinner, sem unicode (opcional)
  if [ "$__ui_is_tty" -ne 1 ]; then
    ui::theme flat
    __ui_use_unicode=0
  fi
}

# ---------- Demo (opcional) ----------
ui::demo() {
  # Demonstra todas as funções rapidamente — não usado em produção
  ui::section_box "DEMO — Saída bonita"
  ui::kv "Profile" "aggressive"
  ui::kv "Path" "$(ui::path "/usr/src/adm/build/libs/zlib/1.3.1")"
  ui::list_item "Passo 1: fetch"
  ui::list_item "Passo 2: analyze"
  ui::list_item "Passo 3: build"

  ui::table_begin
  ui::table_row "Tipo" "Nome" "Versão"
  ui::table_sep
  ui::table_row "build" "cmake" ">=3.28"
  ui::table_row "build" "ninja" ">=1.11"
  ui::table_row "run" "glibc" ">=2.39"
  ui::table_end

  ui::stage_start "BUILD" "libs" "zlib" "1.3.1" "/usr/src/adm/build/libs/zlib/1.3.1" "16"
  ui::stage_update "Compilando…"
  sleep 1
  ui::stage_update "Testando…"
  sleep 1
  ui::stage_ok

  ui::success_box "Tudo certo!"
  ui::warn "Aviso de exemplo"
  ui::error "Erro de exemplo"
}

# ---------- Inicialização automática segura ----------
# ui::init NÃO é chamado automaticamente ao carregar para permitir controle do chamador.
# Recomenda-se:
#   source lib/colors-and-ui
#   ui::init
#   ui::set_theme premium|default|flat
#   ui::apply_ci_defaults (opcional)
#   ui::set-quiet 1 / ui::set-verbose 1 (opcional)

# ---------- Sanitização final ----------
# Garante que chamadas diretas não executem nada
return 0 2>/dev/null || true
