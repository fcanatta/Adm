#!/usr/bin/env bash
# lib/state
# Banco de dados de estado do ADM: runs, pacotes, artefatos, manifests, grafo, cache, GC.
# Sem set -e; todas as funções retornam status e emitem mensagens claras.

# ---------- Guarda de múltiplos sources ----------
if [ -n "${__ADM_STATE_SOURCED:-}" ]; then
  return 0 2>/dev/null || exit 0
fi
__ADM_STATE_SOURCED=1

# ---------- Integrações opcionais ----------
__st_has_log=0
if declare -F log::json >/dev/null 2>&1 && declare -F log::info >/dev/null 2>&1; then __st_has_log=1; fi
st::__log_evt(){ [ "$__st_has_log" -eq 1 ] && log::json EVENT "$@" || true; }
st::__log_info(){ [ "$__st_has_log" -eq 1 ] && log::info "$@" || printf '[INFO] %s\n' "$*" 1>&2; }
st::__log_warn(){ [ "$__st_has_log" -eq 1 ] && log::warn "$@" || printf '[WARN] %s\n' "$*" 1>&2; }
st::__log_err(){  [ "$__st_has_log" -eq 1 ] && log::error "$@" || printf '[ERROR] %s\n' "$*" 1>&2; }

__st_has_cfg=0
if declare -F config::get >/dev/null 2>&1; then __st_has_cfg=1; fi

__st_has_fs=0
if declare -F fs::assert_inside_root >/dev/null 2>&1; then __st_has_fs=1; fi

__st_has_rc=0
if declare -F rc::exit >/dev/null 2>&1; then __st_has_rc=1; fi

# ---------- Estado ----------
__st_root="/usr/src/adm"   # adm.root
__st_dir_state=""          # __st_root/state
__st_tmp=""                # __st_dir_state/tmp
__st_locks=""              # __st_dir_state/locks
__st_initialized=0

# ---------- Utilidades ----------
st::__load_root(){
  if [ "$__st_has_cfg" -eq 1 ]; then
    __st_root="$(config::get adm.root 2>/dev/null || echo /usr/src/adm)"
  fi
  [ -n "$__st_root" ] || __st_root="/usr/src/adm"
  __st_dir_state="$__st_root/state"
  __st_tmp="$__st_dir_state/tmp"
  __st_locks="$__st_dir_state/locks"
}

st::__mkdirp(){
  local d="$1" m="${2:-0755}"
  [ -z "$d" ] && { st::__log_err "mkdirp: dir vazio"; return 2; }
  mkdir -p "$d" 2>/dev/null || { st::__log_err "falha mkdir" path="$d"; return 1; }
  chmod "$m" "$d" 2>/dev/null || true
  return 0
}

st::__assert_inside_root(){
  local p="$1"
  [ -n "$p" ] || { st::__log_err "assert_inside_root: path vazio"; return 2; }
  case "$p" in
    "$__st_root"/*|"$__st_root") return 0 ;;
    *) st::__log_err "fora de adm.root" path="$p" root="$__st_root"; return 23 ;;
  esac
}

st::__now(){ date -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u; }

st::__json_validate(){
  # valida JSON se jq disponível; caso contrário, teste simples de chaves
  local f="$1"
  if command -v jq >/dev/null 2>&1; then jq -e . "$f" >/dev/null 2>&1
  else
    grep -q '[{}:\[\]]' "$f" >/dev/null 2>&1
  fi
}

st::__write_atomic(){
  # st::__write_atomic <dest> <<<'content'
  local dest="$1"
  [ -n "$dest" ] || { st::__log_err "write_atomic: dest vazio"; return 2; }
  st::__assert_inside_root "$dest" || return 23
  st::__mkdirp "$(dirname "$dest")" 0755 || return 1
  st::__mkdirp "$__st_tmp" 0755 || return 1
  local tmp="$__st_tmp/.tmp.$(date +%s%N).$$"
  cat >"$tmp" || { st::__log_err "falha ao escrever tmp" tmp="$tmp"; rm -f "$tmp"; return 1; }
  # se JSON, validar
  case "$dest" in *.json|*.jsonl) st::__json_validate "$tmp" || { st::__log_err "JSON inválido" path="$dest"; rm -f "$tmp"; return 5; };; esac
  mv -f "$tmp" "$dest" 2>/dev/null || { st::__log_err "falha mv atômico" dest="$dest"; rm -f "$tmp"; return 1; }
  return 0
}

st::__append_line_atomic(){
  # Acrescenta com segurança (gera tmp + concat)
  local dest="$1"
  [ -n "$dest" ] || { st::__log_err "append_atomic: dest vazio"; return 2; }
  st::__assert_inside_root "$dest" || return 23
  st::__mkdirp "$(dirname "$dest")" 0755 || return 1
  st::__mkdirp "$__st_tmp" 0755 || return 1
  local tmp="$__st_tmp/.tmp.$(date +%s%N).$$"
  if [ -f "$dest" ]; then
    cat "$dest" >"$tmp" || { st::__log_err "falha cat para tmp"; rm -f "$tmp"; return 1; }
  else
    : >"$tmp" || { st::__log_err "falha criar tmp"; rm -f "$tmp"; return 1; }
  fi
  cat >>"$tmp" || { st::__log_err "falha append tmp"; rm -f "$tmp"; return 1; }
  mv -f "$tmp" "$dest" || { st::__log_err "falha mv append"; rm -f "$tmp"; return 1; }
  return 0
}

# ---------- Locks ----------
st::lock_acquire(){
  # st::lock_acquire <name> [--timeout SEC]
  local name="$1"; shift || true
  local timeout=30
  while [ $# -gt 0 ]; do
    case "$1" in
      --timeout) shift; timeout="${1:-30}";;
      *) st::__log_err "lock_acquire: arg desconhecido" arg="$1"; return 2;;
    esac; shift || true
  done
  [ -n "$name" ] || { st::__log_err "lock_acquire: name vazio"; return 2; }
  st::__mkdirp "$__st_locks" 0755 || return 1
  local lfile="$__st_locks/$name.lock"

  if command -v flock >/dev/null 2>&1; then
    exec {__st_fd}>"$lfile" 2>/dev/null || { st::__log_err "falha open lock" path="$lfile"; return 1; }
    flock -w "$timeout" "$__st_fd" || { st::__log_err "timeout lock" name="$name" timeout_s="$timeout"; return 240; }
    echo "$$" > "$lfile.holder" 2>/dev/null || true
    st::__log_evt "lock_acquire" name="$name"
    return 0
  else
    local d="$lfile.d" waited=0
    while ! mkdir "$d" 2>/dev/null; do
      sleep 1; waited=$(( waited + 1 ))
      [ "$waited" -ge "$timeout" ] && { st::__log_err "timeout lock (fallback)" name="$name"; return 240; }
    done
    echo "$$" > "$d/holder" 2>/dev/null || true
    st::__log_evt "lock_acquire" name="$name"
    return 0
  fi
}

st::lock_release(){
  local name="$1"
  [ -n "$name" ] || { st::__log_err "lock_release: name vazio"; return 2; }
  local lfile="$__st_locks/$name.lock"
  if command -v flock >/dev/null 2>&1; then
    rm -f "$lfile.holder" 2>/dev/null || true
    st::__log_evt "lock_release" name="$name"
  else
    rmdir "$lfile.d" 2>/dev/null || true
    st::__log_evt "lock_release" name="$name"
  fi
  return 0
}

# ---------- Inicialização ----------
state::init(){
  st::__load_root
  local dirs=(
    "$__st_dir_state"
    "$__st_dir_state/runs"
    "$__st_dir_state/pkgs"
    "$__st_dir_state/files"
    "$__st_dir_state/graph"
    "$__st_dir_state/cache/fingerprints"
    "$__st_dir_state/cache/probes"
    "$__st_locks"
    "$__st_tmp"
  )
  local d
  for d in "${dirs[@]}"; do st::__mkdirp "$d" 0755 || return 21; done
  __st_initialized=1
  st::__log_info "state init ok" root="$__st_root"
  st::__log_evt "state_initialized" root="$__st_root"
  return 0
}

# ---------- Chaves e caminhos ----------
state::key(){
  # state::key <cat> <pkg> <ver> <profile> <stage>
  local c="$1" n="$2" v="$3" p="$4" s="$5"
  [ -n "$c" ] && [ -n "$n" ] && [ -n "$v" ] && [ -n "$p" ] && [[ "$s" =~ ^[0-2]$ ]] || { st::__log_err "key inválida"; return 2; }
  printf '%s/%s@%s#%s/stage%s' "$c" "$n" "$v" "$p" "$s"
}

state::__pkg_paths(){
  # preenche vars locais por echo "name=value" (para uso interno)
  local c="$1" n="$2" v="$3" p="$4" s="$5"
  local base="$__st_dir_state/pkgs/$c/$n/versions/$v/profile-$p/stage$s"
  echo "base=$base"
  echo "status=$base/status.json"
  echo "artefacts=$base/artefacts.json"
  echo "fp=$base/fingerprint"
  echo "lastrun=$base/last-run"
  local files_dir="$__st_dir_state/files/$c/$n/$v/$p"
  echo "manifest=$files_dir/stage$s.manifest"
}

state::paths(){
  # state::paths <cat> <pkg> <ver> <profile> <stage>
  local c="$1" n="$2" v="$3" p="$4" s="$5"
  [ -n "$c" ] && [ -n "$n" ] && [ -n "$v" ] && [ -n "$p" ] && [[ "$s" =~ ^[0-2]$ ]] || { st::__log_err "paths: parâmetros inválidos"; return 2; }
  state::__pkg_paths "$c" "$n" "$v" "$p" "$s" | sed 's/^/export /'
}

state::now(){ st::__now; }

# ---------- Runs ----------
state::begin_run(){
  # [--profile P] [--stage N]
  local profile=""; local stage=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --profile) shift; profile="${1:-}";;
      --stage) shift; stage="${1:-}";;
      *) st::__log_err "begin_run: arg desconhecido" arg="$1"; return 2;;
    esac; shift || true
  done
  [ "$__st_initialized" -eq 1 ] || state::init || return $?
  [ -n "$profile" ] || profile="$([ "$__st_has_cfg" -eq 1 ] && config::get adm.profile 2>/dev/null || echo normal)"
  [ -n "$stage" ] || stage="$([ "$__st_has_cfg" -eq 1 ] && config::get adm.stage 2>/dev/null || echo 0)"

  local run_id="$(date +%Y%m%d-%H%M%S)-$$"
  local d="$__st_dir_state/runs/$run_id"
  st::__mkdirp "$d" 0755 || return 21

  # run.json
  local host kernel
  host="$(uname -n 2>/dev/null || echo host)"
  kernel="$(uname -sr 2>/dev/null || echo kernel)"
  st::__write_atomic "$d/run.json" <<EOF || return 1
{
  "run_id":"$run_id",
  "started":"$(st::__now)",
  "ended":null,
  "profile":"$profile",
  "stage":"$stage",
  "host":"$host",
  "kernel":"$kernel",
  "rc":null
}
EOF
  : > "$d/steps.jsonl"
  st::__log_evt "run_begin" run_id="$run_id" profile="$profile" stage="$stage"
  printf '%s\n' "$run_id"
}

state::step(){
  # state::step <RUN_ID> <step> <cat> <pkg> <ver> <profile> <stage> <rc> [msg...]
  local run_id="$1" step="$2" c="$3" n="$4" v="$5" p="$6" s="$7" rc="$8"; shift 8 || true
  [ -n "$run_id" ] && [ -n "$step" ] && [ -n "$c" ] && [ -n "$n" ] && [ -n "$v" ] && [ -n "$p" ] && [[ "$s" =~ ^[0-2]$ ]] && [[ "$rc" =~ ^-?[0-9]+$ ]] || { st::__log_err "step: parâmetros inválidos"; return 2; }
  local msg="$(printf '%s' "$*" | sed -E 's/\x1b\[[0-9;]*m//g')"
  local d="$__st_dir_state/runs/$run_id"
  [ -d "$d" ] || { st::__log_err "RUN_ID não encontrado" run_id="$run_id"; return 4; }
  local key; key="$(state::key "$c" "$n" "$v" "$p" "$s")" || return 2
  st::__append_line_atomic "$d/steps.jsonl" <<EOF || return 1
{"ts":"$(st::__now)","run_id":"$run_id","step":"$step","pkg":"$key","rc":$rc,"msg":$(printf '%s' "$msg" | jq -Rs . 2>/dev/null || printf '"%s"' "$msg")}
EOF
  st::__log_evt "run_step" run_id="$run_id" step="$step" pkg="$key" rc="$rc"
  return 0
}

state::end_run(){
  # state::end_run <RUN_ID> <rc>
  local run_id="$1" rc="$2"
  [ -n "$run_id" ] && [[ "$rc" =~ ^-?[0-9]+$ ]] || { st::__log_err "end_run: parâmetros inválidos"; return 2; }
  local d="$__st_dir_state/runs/$run_id"
  [ -d "$d" ] || { st::__log_err "RUN_ID não encontrado" run_id="$run_id"; return 4; }
  # carrega run.json, atualiza ended/rc (sem jq: reescreve)
  st::__write_atomic "$d/run.json" <<EOF || return 1
{
  "run_id":"$run_id",
  "started":$(grep -o '"started":"[^"]*"' "$d/run.json" 2>/dev/null | head -n1 | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"started":/"started":/'),
  "ended":"$(st::__now)",
  "profile":$(grep -o '"profile":"[^"]*"' "$d/run.json" 2>/dev/null | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"profile":/"profile":/'),
  "stage":$(grep -o '"stage":"[^"]*"' "$d/run.json" 2>/dev/null | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"stage":/"stage":/'),
  "host":$(grep -o '"host":"[^"]*"' "$d/run.json" 2>/dev/null | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"host":/"host":/'),
  "kernel":$(grep -o '"kernel":"[^"]*"' "$d/run.json" 2>/dev/null | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"kernel":/"kernel":/'),
  "rc":$rc
}
EOF
  st::__log_evt "run_end" run_id="$run_id" rc="$rc"
  return 0
}

# ---------- FSM de pacote ----------
state::__fsm_ok(){
  # $1 from $2 to → 0 permitido, 1 negado
  local f="$1" t="$2"
  [ "$t" = "failed" ] && return 0
  case "$f:$t" in
    idle:fetched|fetched:analyzed|analyzed:built|built:installed|installed:packaged|packaged:finalized) return 0;;
    # idempotente: repetir a mesma fase
    fetched:fetched|analyzed:analyzed|built:built|installed:installed|packaged:packaged|finalized:finalized) return 0;;
    # recuperação: failed → próxima fase >= a de falha (tratado no chamador pelo fluxo)
    failed:fetched|failed:analyzed|failed:built|failed:installed|failed:packaged|failed:finalized) return 0;;
    *) return 1;;
  esac
}

state::__status_bootstrap_json(){
  # gera status.json básico
  local c="$1" n="$2" v="$3" p="$4" s="$5" run_id="$6"
  cat <<EOF
{
  "pkg":{"cat":"$c","name":"$n","ver":"$v","profile":"$p","stage":$s},
  "phase":"idle",
  "rc":0,
  "timestamps":{"created":"$(st::__now)","updated":"$(st::__now)"},
  "by_phase":{
    "fetch":{},"analyze":{},"build":{},"install":{},"package":{},"finalize":{}
  },
  "notes":"",
  "run_id":"$run_id"
}
EOF
}

state::pkg_set_phase(){
  # state::pkg_set_phase "<cat> <pkg> <ver> <profile> <stage>" <phase> [--rc N] [--note MSG]
  local tup="$1" phase="$2"; shift 2 || true
  local rc_set="" note=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --rc) shift; rc_set="${1:-}";;
      --note) shift; note="${1:-}";;
      *) st::__log_err "pkg_set_phase: arg desconhecido" arg="$1"; return 2;;
    esac; shift || true
  done
  read -r c n v p s <<<"$tup"
  [ -n "$c" ] && [ -n "$n" ] && [ -n "$v" ] && [ -n "$p" ] && [[ "$s" =~ ^[0-2]$ ]] && [ -n "$phase" ] || { st::__log_err "pkg_set_phase: parâmetros inválidos"; return 2; }

  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"
  eval "$paths" # define base status artefacts fp manifest lastrun

  st::__mkdirp "$base" 0755 || return 21

  # Carrega fase atual (se existir)
  local cur="idle" cur_rc=0
  if [ -s "$status" ]; then
    cur="$(grep -o '"phase":"[^"]*"' "$status" 2>/dev/null | head -n1 | sed -E 's/.*"phase":"([^"]*)".*/\1/')"
    cur_rc="$(grep -o '"rc":[0-9-]*' "$status" 2>/dev/null | head -n1 | awk -F: '{print $2}')"
  fi

  state::__fsm_ok "$cur" "$phase" || { st::__log_err "transição FSM inválida" from="$cur" to="$phase"; return 5; }

  local now; now="$(st::__now)"
  local rc_final="${rc_set:-$cur_rc}"
  [ "$phase" = "failed" ] && { [ -z "$rc_set" ] && rc_final=255; }

  st::__write_atomic "$status" <<EOF || return 1
{
  "pkg":{"cat":"$c","name":"$n","ver":"$v","profile":"$p","stage":$s},
  "phase":"$phase",
  "rc":$rc_final,
  "timestamps":{"created":$( [ -s "$status" ] && grep -o '"created":"[^"]*"' "$status" | head -n1 | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"created":/"created":/' || printf '"%s"' "$now" ),"updated":"$now"},
  "by_phase":{
    "fetch":$(grep -o '"fetch":[^}]*}' "$status" 2>/dev/null | head -n1 || echo "{}"),
    "analyze":$(grep -o '"analyze":[^}]*}' "$status" 2>/dev/null | head -n1 || echo "{}"),
    "build":$(grep -o '"build":[^}]*}' "$status" 2>/dev/null | head -n1 || echo "{}"),
    "install":$(grep -o '"install":[^}]*}' "$status" 2>/dev/null | head -n1 || echo "{}"),
    "package":$(grep -o '"package":[^}]*}' "$status" 2>/dev/null | head -n1 || echo "{}"),
    "finalize":$(grep -o '"finalize":[^}]*}' "$status" 2>/dev/null | head -n1 || echo "{}")
  },
  "notes":$(printf '%s' "${note:-$(grep -o '"notes":"[^"]*"' "$status" 2>/dev/null | head -n1 | sed -E 's/.*"notes":"([^"]*)".*/\1/')" | jq -Rs . 2>/dev/null || printf '"%s"' "${note:-}"),
  "run_id":$( [ -s "$status" ] && grep -o '"run_id":"[^"]*"' "$status" | head -n1 | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"run_id":/"run_id":/' || printf '"%s"' "${ADM_RUN_ID:-}" )
}
EOF

  echo "${ADM_RUN_ID:-}" > "$lastrun" 2>/dev/null || true
  st::__log_evt "pkg_phase" pkg="$(state::key "$c" "$n" "$v" "$p" "$s")" phase="$phase" rc="$rc_final"
  return 0
}

state::pkg_get_phase(){
  local c="$1" n="$2" v="$3" p="$4" s="$5"
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  [ -s "$status" ] || { echo "idle"; return 0; }
  grep -o '"phase":"[^"]*"' "$status" | head -n1 | sed -E 's/.*"phase":"([^"]*)".*/\1/'
}

state::pkg_get_rc(){
  local c="$1" n="$2" v="$3" p="$4" s="$5"
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  [ -s "$status" ] || { echo 0; return 0; }
  grep -o '"rc":[0-9-]*' "$status" | head -n1 | awk -F: '{print $2}'
}

state::pkg_touch(){
  local c="$1" n="$2" v="$3" p="$4" s="$5"
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  [ -s "$status" ] || return 4
  local now; now="$(st::__now)"
  st::__write_atomic "$status" <<EOF || return 1
{
  "pkg":{"cat":"$c","name":"$n","ver":"$v","profile":"$p","stage":$s},
  "phase":$(grep -o '"phase":"[^"]*"' "$status" | head -n1 | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"phase":/"phase":/'),
  "rc":$(grep -o '"rc":[0-9-]*' "$status" | head -n1 | awk -F: '{print $0}'),
  "timestamps":{"created":$(grep -o '"created":"[^"]*"' "$status" | head -n1 | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"created":/"created":/'),"updated":"$now"},
  "by_phase":$(grep -o '"by_phase":{.*}' "$status" | head -n1),
  "notes":$(grep -o '"notes":"[^"]*"' "$status" | head -n1 | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"notes":/"notes":/'),
  "run_id":$(grep -o '"run_id":"[^"]*"' "$status" | head -n1 | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"run_id":/"run_id":/')
}
EOF
  return 0
}
  # ---------- Artefatos, Manifest e Fingerprint ----------
state::artefact_set(){
  # state::artefact_set "<cat> <pkg> <ver> <profile> <stage>" <key> <value>
  local tup="$1" key="$2" val="$3"
  read -r c n v p s <<<"$tup"
  [ -n "$c" ] && [ -n "$n" ] && [ -n "$v" ] && [ -n "$p" ] && [[ "$s" =~ ^[0-2]$ ]] && [ -n "$key" ] || { st::__log_err "artefact_set: parâmetros inválidos"; return 2; }
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  st::__mkdirp "$(dirname "$artefacts")" 0755 || return 21
  local tmp="$__st_tmp/.art.$(date +%s%N).$$.json"
  if [ -s "$artefacts" ] && command -v jq >/dev/null 2>&1; then
    jq --arg k "$key" --arg v "$val" '. + {($k):$v}' "$artefacts" > "$tmp" 2>/dev/null || { st::__log_err "jq merge falhou"; rm -f "$tmp"; return 1; }
  else
    cat >"$tmp" <<EOF
{ "$key":"$val" }
EOF
  fi
  st::__write_atomic "$artefacts" < "$tmp" || { rm -f "$tmp"; return 1; }
  rm -f "$tmp" || true
  st::__log_evt "artefact_set" pkg="$(state::key "$c" "$n" "$v" "$p" "$s")" key="$key"
  return 0
}

state::artefact_get(){
  local c="$1" n="$2" v="$3" p="$4" s="$5" key="$6"
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  [ -s "$artefacts" ] || return 4
  if command -v jq >/dev/null 2>&1; then
    jq -r --arg k "$key" ' .[$k] // empty ' "$artefacts"
  else
    grep -o "\"$key\":\"[^\"]*\"" "$artefacts" 2>/dev/null | sed -E "s/\"$key\":\"([^\"]*)\"/\1/" | head -n1
  fi
}

state::manifest_write(){
  # state::manifest_write "<cat> <pkg> <ver> <profile> <stage>" <manifest_file>
  local tup="$1" mf_src="$2"
  read -r c n v p s <<<"$tup"
  [ -r "$mf_src" ] || { st::__log_err "manifest fonte não legível" path="$mf_src"; return 4; }
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  st::__mkdirp "$(dirname "$manifest")" 0755 || return 21
  # normalizar: garantir prefixo /
  awk '{ if ($0 ~ /^\//) print $0; else print "/"$0 }' "$mf_src" | sort -u > "$__st_tmp/.mf.$$" || { st::__log_err "falha preparar manifest"; rm -f "$__st_tmp/.mf.$$"; return 1; }
  st::__write_atomic "$manifest" < "$__st_tmp/.mf.$$" || { rm -f "$__st_tmp/.mf.$$"; return 1; }
  rm -f "$__st_tmp/.mf.$$" || true
  st::__log_evt "manifest_write" pkg="$(state::key "$c" "$n" "$v" "$p" "$s")" file="$manifest"
  return 0
}

state::manifest_read(){
  local c="$1" n="$2" v="$3" p="$4" s="$5"
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  [ -r "$manifest" ] || return 4
  cat "$manifest"
}

state::fingerprint_write(){
  local c="$1" n="$2" v="$3" p="$4" s="$5" hash="$6"
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  [ -n "$hash" ] || { st::__log_err "fingerprint vazio"; return 2; }
  st::__write_atomic "$fp" <<<"$hash" || return 1
  st::__log_evt "fingerprint_write" pkg="$(state::key "$c" "$n" "$v" "$p" "$s")"
  return 0
}

state::fingerprint_read(){
  local c="$1" n="$2" v="$3" p="$4" s="$5"
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  [ -r "$fp" ] || return 4
  cat "$fp"
}

# ---------- Cache por fingerprint ----------
state::cache_hit(){
  # state::cache_hit <hash> → imprime caminho do artefato se existir (json com pkg_tar) ou vazio
  local h="$1"
  [ -n "$h" ] || { st::__log_err "cache_hit: hash vazio"; return 2; }
  local m="$__st_dir_state/cache/fingerprints/$h.json"
  [ -r "$m" ] || return 1
  if command -v jq >/dev/null 2>&1; then
    jq -r '.pkg_tar // empty' "$m"
  else
    grep -o '"pkg_tar":"[^"]*"' "$m" | sed -E 's/.*"pkg_tar":"([^"]*)".*/\1/'
  fi
}

state::cache_link(){
  # state::cache_link "<cat> <pkg> <ver> <profile> <stage>" <hash> <pkg_tar>
  local tup="$1" h="$2" tar="$3"
  read -r c n v p s <<<"$tup"
  [ -n "$h" ] && [ -n "$tar" ] || { st::__log_err "cache_link: parâmetros inválidos"; return 2; }
  local m="$__st_dir_state/cache/fingerprints/$h.json"
  st::__mkdirp "$(dirname "$m")" 0755 || return 21
  st::__write_atomic "$m" <<EOF || return 1
{
  "hash":"$h",
  "pkg":"$(state::key "$c" "$n" "$v" "$p" "$s")",
  "pkg_tar":"$tar",
  "ts":"$(st::__now)"
}
EOF
  st::__log_evt "cache_link" hash="$h"
  return 0
}

# ---------- Grafo ----------
state::graph_load(){
  local g="$__st_dir_state/graph/graph.json"
  [ -r "$g" ] || { echo "{}"; return 0; }
  cat "$g"
}

state::graph_save(){
  # state::graph_save <json-file|->  (se '-' lê stdin)
  local src="$1"
  local g="$__st_dir_state/graph/graph.json"
  if [ "$src" = "-" ]; then
    st::__write_atomic "$g" < /dev/stdin || return 1
  else
    [ -r "$src" ] || { st::__log_err "graph_save: fonte não legível" path="$src"; return 4; }
    st::__write_atomic "$g" < "$src" || return 1
  fi
  st::__log_evt "graph_save" file="$g"
  return 0
}

state::graph_add_node(){
  local node="$1"; [ -n "$node" ] || { st::__log_err "add_node: node vazio"; return 2; }
  local g="$__st_dir_state/graph/graph.json"; st::__mkdirp "$(dirname "$g")" 0755 || return 21
  local tmp="$__st_tmp/.graph.$$"
  if command -v jq >/dev/null 2>&1 && [ -s "$g" ]; then
    jq --arg n "$node" '.nodes = (.nodes // []) | .nodes += [$n] | .nodes |= unique | .edges = (.edges // [])' "$g" > "$tmp" 2>/dev/null || { rm -f "$tmp"; return 1; }
  else
    cat >"$tmp" <<EOF
{"nodes":["$node"],"edges":[]}
EOF
  fi
  st::__write_atomic "$g" < "$tmp" || { rm -f "$tmp"; return 1; }
  rm -f "$tmp" || true
  return 0
}

state::graph_add_edge(){
  local a="$1" b="$2"
  [ -n "$a" ] && [ -n "$b" ] || { st::__log_err "add_edge: parâmetros vazios"; return 2; }
  local g="$__st_dir_state/graph/graph.json"; st::__mkdirp "$(dirname "$g")" 0755 || return 21
  local tmp="$__st_tmp/.graph.$$"
  if command -v jq >/dev/null 2>&1 && [ -s "$g" ]; then
    jq --arg a "$a" --arg b "$b" '
      .nodes = (.nodes // []) | .edges = (.edges // []) |
      .nodes |= (. + [$a,$b]) | .nodes |= unique |
      .edges |= (. + [[ $a, $b ]])' "$g" > "$tmp" 2>/dev/null || { rm -f "$tmp"; return 1; }
  else
    cat >"$tmp" <<EOF
{"nodes":["$a","$b"],"edges":[["$a","$b"]]}
EOF
  fi
  st::__write_atomic "$g" < "$tmp" || { rm -f "$tmp"; return 1; }
  rm -f "$tmp" || true
  return 0
}

state::graph_reverse_deps(){
  local target="$1"; [ -n "$target" ] || { st::__log_err "reverse_deps: alvo vazio"; return 2; }
  local g="$__st_dir_state/graph/graph.json"; [ -r "$g" ] || return 4
  if command -v jq >/dev/null 2>&1; then
    jq -r --arg t "$target" '.edges[] | select(.[1]==$t) | .[0]' "$g"
  else
    grep -o '\[.*\]' "$g" | grep "$target" | sed -E 's/\["([^"]*)","([^"]*)"\]/\1 \2/' | awk -v t="$target" '$2==t{print $1}'
  fi
}

# ---------- Rollback / Remoção ----------
state::rollback_phase(){
  # state::rollback_phase "<cat> <pkg> <ver> <profile> <stage>" <to_phase>
  local tup="$1" to="$2"; read -r c n v p s <<<"$tup"
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  [ -s "$status" ] || { st::__log_err "status inexistente para rollback"; return 4; }
  local now; now="$(st::__now)"
  st::__write_atomic "$status" <<EOF || return 1
{
  "pkg":{"cat":"$c","name":"$n","ver":"$v","profile":"$p","stage":$s},
  "phase":"$to",
  "rc":0,
  "timestamps":{"created":$(grep -o '"created":"[^"]*"' "$status" | head -n1 | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"created":/"created":/'),"updated":"$now"},
  "by_phase":$(grep -o '"by_phase":{.*}' "$status" | head -n1),
  "notes":"rollback",
  "run_id":$(grep -o '"run_id":"[^"]*"' "$status" | head -n1 | awk -F: '{print $0}' | sed 's/^/"/' | sed 's/$/"/' | sed 's/^"run_id":/"run_id":/')
}
EOF
  st::__log_evt "pkg_rollback" pkg="$(state::key "$c" "$n" "$v" "$p" "$s")" to="$to"
  return 0
}

state::remove_pkg_state(){
  # remove SOMENTE metadados de state do pacote
  local c="$1" n="$2" v="$3"
  [ -n "$c" ] && [ -n "$n" ] && [ -n "$v" ] || { st::__log_err "remove_pkg_state: parâmetros inválidos"; return 2; }
  local d="$__st_dir_state/pkgs/$c/$n/versions/$v"
  st::__assert_inside_root "$d" || return 23
  [ -d "$d" ] || return 0
  rm -rf --one-file-system "$d" 2>/dev/null || { st::__log_err "falha ao remover pkg state" path="$d"; return 1; }
  st::__log_evt "pkg_state_removed" path="$d"
  return 0
}

# ---------- GC ----------
state::gc(){
  # state::gc [--dry-run] [--keep-days N] [--preserve-needed]
  local dry=0 keep=30 preserve=0
  while [ $# -gt 0 ]; do
    case "$1" in
      --dry-run) dry=1;;
      --keep-days) shift; keep="${1:-30}";;
      --preserve-needed) preserve=1;;
      *) st::__log_err "gc: arg desconhecido" arg="$1"; return 2;;
    esac; shift || true
  done
  [ "$__st_initialized" -eq 1 ] || state::init || return $?

  local now_s; now_s="$(date +%s)"
  local cutoff=$(( now_s - keep*24*3600 ))

  # 1) limpar runs antigos
  find "$__st_dir_state/runs" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | while read -r d; do
    local t; t="$(stat -c %Y "$d" 2>/dev/null || echo 0)"
    if [ "$t" -lt "$cutoff" ]; then
      if [ "$dry" -eq 1 ]; then echo "[DRY] rm -rf $d"; else rm -rf --one-file-system "$d"; fi
    fi
  done

  # 2) fingerprints órfãos (sem arquivo de pacote)
  find "$__st_dir_state/cache/fingerprints" -type f -name '*.json' 2>/dev/null | while read -r f; do
    local tar=""
    if command -v jq >/dev/null 2>&1; then tar="$(jq -r '.pkg_tar // empty' "$f" 2>/dev/null)"; else tar="$(grep -o '"pkg_tar":"[^"]*"' "$f" | sed -E 's/.*"pkg_tar":"([^"]*)".*/\1/')" ; fi
    [ -n "$tar" ] && [ -f "$tar" ] || { [ "$dry" -eq 1 ] && echo "[DRY] rm $f" || rm -f "$f"; }
  done

  # 3) builds/staging órfãos — somente se NÃO houver status.json para o ver/profile/stage
  find "$__st_root/build" -mindepth 3 -maxdepth 3 -type d 2>/dev/null | while read -r bdir; do
    local rel="${bdir#$__st_root/build/}" cat="${rel%%/*}" rest="${rel#*/}" pkg="${rest%%/*}" ver="${rest##*/}"
    # procura status em qualquer profile/stage
    local have=0
    [ -d "$__st_dir_state/pkgs/$cat/$pkg/versions/$ver" ] && have=1
    if [ "$have" -eq 0 ]; then
      if [ "$dry" -eq 1 ]; then echo "[DRY] rm -rf $bdir"; else rm -rf --one-file-system "$bdir"; fi
    fi
  done

  find "$__st_root/staging" -mindepth 3 -maxdepth 3 -type d 2>/dev/null | while read -r sdir; do
    local rel="${sdir#$__st_root/staging/}" cat="${rel%%/*}" rest="${rel#*/}" pkg="${rest%%/*}" ver="${rest##*/}"
    local have=0
    [ -d "$__st_dir_state/pkgs/$cat/$pkg/versions/$ver" ] && have=1
    if [ "$have" -eq 0 ]; then
      if [ "$dry" -eq 1 ]; then echo "[DRY] rm -rf $sdir"; else rm -rf --one-file-system "$sdir"; fi
    fi
  done

  st::__log_evt "gc_done" dry="$dry" keep_days="$keep" preserve_needed="$preserve"
  return 0
}

# ---------- Consultas / Diagnóstico ----------
state::pkg_status(){
  # state::pkg_status "<cat> <pkg> <ver> <profile> <stage>"
  read -r c n v p s <<<"$1"
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  if [ -s "$status" ]; then
    if command -v jq >/dev/null 2>&1; then
      jq -c '{pkg:.pkg, phase:.phase, rc:.rc, ts:.timestamps, artefacts:input?}' "$status" "$artefacts" 2>/dev/null | tr -d '\n' | sed 's/}{/,"artefacts":/g' || cat "$status"
    else
      cat "$status"
    fi
  else
    echo '{"phase":"idle","rc":0}'
  fi
}

state::list_failed(){
  # [--since DAYS]
  local since=0
  while [ $# -gt 0 ]; do
    case "$1" in
      --since) shift; since="${1:-0}";;
      *) st::__log_err "list_failed: arg desconhecido" arg="$1"; return 2;;
    esac; shift || true
  done
  local cutoff=0
  if [ "$since" -gt 0 ] 2>/dev/null; then cutoff=$(( $(date +%s) - since*24*3600 )); fi
  find "$__st_dir_state/pkgs" -type f -name status.json 2>/dev/null | while read -r f; do
    local phase rc upd
    phase="$(grep -o '"phase":"[^"]*"' "$f" | head -n1 | sed -E 's/.*"phase":"([^"]*)".*/\1/')"
    [ "$phase" = "failed" ] || continue
    upd="$(grep -o '"updated":"[^"]*"' "$f" | head -n1 | sed -E 's/.*"updated":"([^"]*)".*/\1/')"
    if [ "$cutoff" -gt 0 ]; then
      local ts; ts="$(date -d "$upd" +%s 2>/dev/null || echo 0)"
      [ "$ts" -ge "$cutoff" ] || continue
    fi
    rc="$(grep -o '"rc":[0-9-]*' "$f" | head -n1 | awk -F: '{print $2}')"
    printf '%s  rc=%s  %s\n' "$f" "$rc" "$upd"
  done
}

state::list_outdated(){
  # compara fingerprint com presença e conteúdo
  find "$__st_dir_state/pkgs" -type f -name fingerprint 2>/dev/null | while read -r f; do
    [ -s "$f" ] || echo "outdated: $(dirname "$f") (fingerprint vazio)"
  done
}

state::whereis(){
  # state::whereis "<cat> <pkg> <ver> <profile> <stage>" <what>
  local tup="$1" what="$2"
  read -r c n v p s <<<"$tup"
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  case "$what" in
    manifest) echo "$manifest";;
    status)   echo "$status";;
    artefacts)echo "$artefacts";;
    pkg_tar)  state::artefact_get "$c" "$n" "$v" "$p" "$s" "pkg_tar";;
    build)    echo "$__st_root/build/$c/$n/$v";;
    staging)  echo "$__st_root/staging/$c/$n/$v";;
    rootfs)   echo "$__st_root/stage$s/rootfs";;
    logs)     state::artefact_get "$c" "$n" "$v" "$p" "$s" "logs_dir";;
    *) st::__log_err "whereis: alvo desconhecido" what="$what"; return 2;;
  esac
}

# ---------- Bootstraps convenientes ----------
state::ensure_pkg_status(){
  # Cria status.json se não existir (idle), útil antes de atualizar fases
  local c="$1" n="$2" v="$3" p="$4" s="$5"
  local run="${ADM_RUN_ID:-$(date +%Y%m%d-%H%M%S)-$$}"
  local paths; paths="$(state::__pkg_paths "$c" "$n" "$v" "$p" "$s")"; eval "$paths"
  [ -s "$status" ] && return 0
  st::__mkdirp "$base" 0755 || return 21
  state::__status_bootstrap_json "$c" "$n" "$v" "$p" "$s" "$run" | st::__write_atomic "$status" || return 1
  return 0
}

# ---------- Fim seguro ----------
return 0 2>/dev/null || true
