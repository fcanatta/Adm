#!/usr/bin/env bash
# profile
# Gerente de perfis: CRUD, herança, validação, aplicação no env e CLI `adm profile`.
# Sem set -e; todas as funções retornam status e emitem mensagens claras.

# ---------- Guarda de múltiplos sources ----------
if [ -n "${__ADM_PROFILE_SOURCED:-}" ]; then
  return 0 2>/dev/null || exit 0
fi
__ADM_PROFILE_SOURCED=1

# ---------- Integrações opcionais ----------
__pr_has_log=0
if declare -F log::json >/dev/null 2>&1 && declare -F log::info >/dev/null 2>&1; then __pr_has_log=1; fi
pr::__evt(){  [ "$__pr_has_log" -eq 1 ] && log::json EVENT "$@" || true; }
pr::__info(){ [ "$__pr_has_log" -eq 1 ] && log::info "$@" || printf '[INFO] %s\n' "$*" 1>&2; }
pr::__warn(){ [ "$__pr_has_log" -eq 1 ] && log::warn "$@" || printf '[WARN] %s\n' "$*" 1>&2; }
pr::__err(){  [ "$__pr_has_log" -eq 1 ] && log::error "$@" || printf '[ERROR] %s\n' "$*" 1>&2; }

__pr_has_cfg=0
if declare -F config::get >/dev/null 2>&1 && declare -F config::set >/dev/null 2>&1; then __pr_has_cfg=1; fi

__pr_has_env=0
if declare -F env::apply_profile_tuning >/dev/null 2>&1 && declare -F env::activate_stage >/dev/null 2>&1; then __pr_has_env=1; fi

__pr_has_rc=0
if declare -F rc::exit >/dev/null 2>&1; then __pr_has_rc=1; fi

# ---------- Estado ----------
__pr_root="/usr/src/adm"    # adm.root
__pr_dir=""                 # $__pr_root/profiles
__pr_initialized=0

# ---------- Utilidades ----------
pr::__load_root(){
  if [ "$__pr_has_cfg" -eq 1 ]; then
    __pr_root="$(config::get adm.root 2>/dev/null || echo /usr/src/adm)"
  fi
  [ -n "$__pr_root" ] || __pr_root="/usr/src/adm"
  __pr_dir="$__pr_root/profiles"
}

pr::__mkdirp(){
  local d="$1" m="${2:-0755}"
  [ -z "$d" ] && { pr::__err "mkdirp: dir vazio"; return 2; }
  mkdir -p "$d" 2>/dev/null || { pr::__err "falha mkdir" path="$d"; return 1; }
  chmod "$m" "$d" 2>/dev/null || true
}

pr::__write_atomic(){
  local dest="$1"
  [ -n "$dest" ] || { pr::__err "write_atomic: dest vazio"; return 2; }
  pr::__mkdirp "$(dirname "$dest")" 0755 || return 1
  local tmp="$__pr_dir/.tmp.$(date +%s%N).$$"
  cat >"$tmp" || { pr::__err "falha escrever tmp" tmp="$tmp"; rm -f "$tmp"; return 1; }
  mv -f "$tmp" "$dest" 2>/dev/null || { pr::__err "falha mv atômico" dest="$dest"; rm -f "$tmp"; return 1; }
}

pr::__is_valid_name(){ [[ "$1" =~ ^[a-zA-Z0-9._-]+$ ]]; }

pr::__kv_get(){ # lê key=val (ini leve, sem seções) do arquivo
  local file="$1" key="$2"
  [ -r "$file" ] || return 1
  awk -F= -v k="$key" '
    /^[[:space:]]*#/ {next}
    /^[[:space:]]*$/ {next}
    $1 ~ /^[[:space:]]*[^=]+[[:space:]]*$/ {
      gsub(/[[:space:]]+/,"",$1)
      if($1==k){ sub(/^[^=]*=/,""); gsub(/^[[:space:]]+|[[:space:]]+$/,""); print; exit }
    }' "$file"
}

pr::__kv_set(){ # grava/atualiza key=val (sem duplicar)
  local file="$1" key="$2" val="$3"
  [ -n "$key" ] || { pr::__err "kv_set: key vazia"; return 2; }
  local tmp="$file.tmp.$$"
  if [ -f "$file" ]; then
    awk -v k="$key" -v v="$val" -F= '
      BEGIN{found=0}
      /^[[:space:]]*#/ {print; next}
      /^[[:space:]]*$/ {print; next}
      {
        kline=$1; gsub(/[[:space:]]+/,"",kline)
        if(kline==k){ print k"="v; found=1; next }
        print
      }
      END{ if(found==0){ print k"="v } }
    ' "$file" > "$tmp" || { rm -f "$tmp"; return 1; }
  else
    echo "$key=$val" > "$tmp" || { rm -f "$tmp"; return 1; }
  fi
  mv -f "$tmp" "$file" || { pr::__err "kv_set: falha mv"; rm -f "$tmp"; return 1; }
}

pr::__now(){ date -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -u; }

pr::__schema_path(){ echo "$__pr_dir/schema.json"; }
pr::__active_path(){ echo "$__pr_dir/active"; }
pr::__profile_dir(){ local name="$1"; echo "$__pr_dir/$name"; }
pr::__profile_conf(){ local name="$1"; echo "$__pr_dir/$name/profile.conf"; }

# ---------- Schema embutido (documentação/validação simples) ----------
profile::schema_dump(){
  cat <<'JSON'
{
  "version": 1,
  "keys": {
    "core.name": "string",
    "core.version": "string",
    "core.libc": "enum(glibc|musl)",
    "extends": "string?",
    "build.jobs": "auto|int(1..1024)",
    "build.make_jobs": "auto|int(1..1024)",
    "build.debug": "enum(on|off)",
    "build.strip": "enum(all|bin|off)",
    "flags.march": "string",
    "flags.cflags+": "string",
    "flags.cxxflags+": "string",
    "flags.ldflags+": "string",
    "opt.level": "enum(minimal|normal|aggressive)",
    "opt.lto": "enum(off|thin|full)",
    "opt.pgo": "enum(off|gen|use)",
    "linker.impl": "enum(auto|bfd|gold|lld|mold)",
    "linker.as_needed": "enum(on|off)",
    "san.asan": "enum(on|off)",
    "san.ubsan": "enum(on|off)",
    "cache.ccache": "enum(on|off)",
    "cache.sccache": "enum(on|off)",
    "cache.distcc": "enum(on|off)",
    "network.allow_during_build": "enum(on|off)",
    "network.proxy": "string?",
    "network.no_proxy": "string?",
    "ui.theme": "enum(dracula|nord|monokai|solarized-dark|solarized-light|gruvbox|one-dark)",
    "ui.spinner": "enum(on|off)",
    "ui.no_color": "enum(on|off)",
    "stages.stage0.flags.cflags+": "string",
    "stages.stage1.flags.cflags+": "string",
    "stages.stage2.flags.cflags+": "string"
  }
}
JSON
}

# ---------- Inicialização / presets ----------
profile::init(){
  pr::__load_root
  pr::__mkdirp "$__pr_dir" 0755 || return 21
  # schema
  local schema; schema="$(pr::__schema_path)"
  if [ ! -f "$schema" ]; then profile::schema_dump > "$schema" || return 1; fi

  # presets
  profile::ensure_preset minimal || return $?
  profile::ensure_preset normal || return $?
  profile::ensure_preset aggressive || return $?

  # active
  local active; active="$(pr::__active_path)"
  if [ ! -f "$active" ]; then echo "normal" > "$active" || return 1; fi

  __pr_initialized=1
  pr::__info "profiles init ok" dir="$__pr_dir"
  pr::__evt "profiles_initialized" dir="$__pr_dir"
  return 0
}

profile::ensure_preset(){
  local name="$1"
  pr::__is_valid_name "$name" || { pr::__err "preset inválido" name="$name"; return 2; }
  local d conf; d="$(pr::__profile_dir "$name")"; conf="$(pr::__profile_conf "$name")"
  [ -d "$d" ] || pr::__mkdirp "$d" 0755 || return 21
  [ -f "$conf" ] && return 0
  case "$name" in
    minimal)
      cat > "$conf" <<'EOF'
# preset: minimal
core.name=minimal
core.version=1
core.libc=glibc
opt.level=minimal
opt.lto=off
opt.pgo=off
build.jobs=auto
build.make_jobs=auto
build.debug=off
build.strip=bin
flags.march=x86-64
linker.impl=auto
linker.as_needed=on
san.asan=off
san.ubsan=off
cache.ccache=off
cache.sccache=off
cache.distcc=off
network.allow_during_build=off
ui.theme=nord
ui.spinner=on
ui.no_color=off
EOF
      ;;
    normal)
      cat > "$conf" <<'EOF'
# preset: normal
core.name=normal
core.version=1
core.libc=glibc
opt.level=normal
opt.lto=thin
opt.pgo=off
build.jobs=auto
build.make_jobs=auto
build.debug=off
build.strip=bin
flags.march=x86-64-v3
linker.impl=auto
linker.as_needed=on
san.asan=off
san.ubsan=off
cache.ccache=on
cache.sccache=off
cache.distcc=off
network.allow_during_build=on
ui.theme=gruvbox
ui.spinner=on
ui.no_color=off
EOF
      ;;
    aggressive)
      cat > "$conf" <<'EOF'
# preset: aggressive
core.name=aggressive
core.version=1
core.libc=glibc
opt.level=aggressive
opt.lto=full
opt.pgo=use
build.jobs=auto
build.make_jobs=auto
build.debug=off
build.strip=all
flags.march=native
linker.impl=lld
linker.as_needed=on
san.asan=off
san.ubsan=off
cache.ccache=on
cache.sccache=on
cache.distcc=off
network.allow_during_build=on
ui.theme=dracula
ui.spinner=on
ui.no_color=off
EOF
      ;;
  esac
  pr::__evt "profile_preset_written" name="$name" conf="$conf"
  return 0
}

# ---------- Utilidades de perfil ----------
profile::path(){ local n="$1"; pr::__is_valid_name "$n" || return 2; pr::__profile_dir "$n"; }
profile::exists(){ local n="$1"; [ -d "$(pr::__profile_dir "$n")" ] && [ -f "$(pr::__profile_conf "$n")" ]; }
profile::active(){
  local f; f="$(pr::__active_path)"
  [ -r "$f" ] && cat "$f" || echo "normal"
}

# ---------- CRUD ----------
profile::new(){
  # profile::new <name> [--from PRESET|OTHER] [--libc glibc|musl] [--opt minimal|normal|aggressive]
  local name="$1"; shift || true
  pr::__is_valid_name "$name" || { pr::__err "nome inválido"; return 2; }
  local from="normal" libc="" opt=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --from) shift; from="${1:-normal}";;
      --libc) shift; libc="${1:-}";;
      --opt) shift; opt="${1:-}";;
      *) pr::__err "new: arg desconhecido" arg="$1"; return 1;;
    esac; shift || true
  done
  profile::init || return $?
  profile::exists "$name" && { pr::__err "perfil já existe"; return 1; }
  profile::exists "$from" || profile::ensure_preset "$from" || return $?

  local src="$(pr::__profile_conf "$from")"
  local dst; dst="$(pr::__profile_conf "$name")"
  pr::__mkdirp "$(dirname "$dst")" 0755 || return 21
  cp -f "$src" "$dst" || return 1
  pr::__kv_set "$dst" core.name "$name" || return 1
  [ -n "$libc" ] && pr::__kv_set "$dst" core.libc "$libc"
  [ -n "$opt" ]   && pr::__kv_set "$dst" opt.level "$opt"
  pr::__evt "profile_created" name="$name" from="$from"
  pr::__info "perfil criado" name="$name"
  return 0
}

profile::copy(){
  local src="$1" dst="$2"
  pr::__is_valid_name "$src" && pr::__is_valid_name "$dst" || { pr::__err "nomes inválidos"; return 2; }
  profile::exists "$src" || { pr::__err "perfil origem inexistente"; return 4; }
  profile::exists "$dst" && { pr::__err "perfil destino já existe"; return 1; }
  pr::__mkdirp "$(pr::__profile_dir "$dst")" 0755 || return 21
  cp -a "$(pr::__profile_dir "$src")/." "$(pr::__profile_dir "$dst")/" || return 1
  pr::__kv_set "$(pr::__profile_conf "$dst")" core.name "$dst"
  pr::__evt "profile_copied" src="$src" dst="$dst"
  pr::__info "perfil copiado" src="$src" dst="$dst"
  return 0
}

profile::delete(){
  # profile::delete <name> [--force]
  local name="$1" force=0
  [ "$2" = "--force" ] && force=1
  pr::__is_valid_name "$name" || { pr::__err "nome inválido"; return 2; }
  profile::exists "$name" || return 0
  local act; act="$(profile::active)"
  if [ "$name" = "$act" ] && [ "$force" -ne 1 ]; then
    pr::__err "não é permitido apagar o perfil ativo (use --force ou mude o ativo)"
    return 3
  fi
  rm -rf --one-file-system "$(pr::__profile_dir "$name")" 2>/dev/null || { pr::__err "falha ao remover perfil"; return 1; }
  pr::__evt "profile_deleted" name="$name"
  pr::__info "perfil removido" name="$name"
  return 0
}

profile::edit(){
  local name="$1"
  pr::__is_valid_name "$name" || { pr::__err "nome inválido"; return 2; }
  profile::exists "$name" || { pr::__err "perfil inexistente"; return 4; }
  local f; f="$(pr::__profile_conf "$name")"
  "${EDITOR:-vi}" "$f"
  profile::validate "$name" --strict || { pr::__warn "validação falhou após edição"; return 10; }
  pr::__info "perfil salvo e validado" name="$name"
  return 0
}

# ---------- Carregar/Resolver/Validar ----------
profile::__read_conf(){
  # imprime linhas úteis (sem comentários/vazios)
  local f="$1"; [ -r "$f" ] || return 1
  awk '
    /^[[:space:]]*#/ {next}
    /^[[:space:]]*$/ {next}
    {print}
  ' "$f"
}

profile::load(){
  # profile::load <name> [--resolve]
  local name="$1"; shift || true
  local resolve=0
  [ "$1" = "--resolve" ] && resolve=1
  profile::exists "$name" || { pr::__err "perfil inexistente"; return 4; }
  if [ "$resolve" -eq 1 ]; then
    profile::resolve "$name" || return $?
  else
    profile::__read_conf "$(pr::__profile_conf "$name")"
  fi
}

profile::__resolve_chain(){
  # resolve extends -> retorna lista do mais antigo ao mais recente
  local name="$1" seen="" order=()
  while :; do
    case ",$seen," in *,"$name",*) pr::__err "ciclo de herança detectado"; return 19;; esac
    seen="$seen,$name"
    order+=("$name")
    local parent; parent="$(pr::__kv_get "$(pr::__profile_conf "$name")" extends || true)"
    [ -n "$parent" ] || break
    profile::exists "$parent" || { pr::__err "extends refere perfil ausente" parent="$parent"; return 4; }
    name="$parent"
  done
  # imprime do mais antigo → mais novo
  for ((i=${#order[@]}-1; i>=0; i--)); do echo "${order[$i]}"; done
}

profile::resolve(){
  # aplica herança; últimas definições vencem; operadores com + acumulam (cflags+, etc.)
  local name="$1"; profile::exists "$name" || { pr::__err "perfil inexistente"; return 4; }
  local chain; chain=($(profile::__resolve_chain "$name")) || return $?
  declare -A map=()
  local k v
  for p in "${chain[@]}"; do
    while IFS='=' read -r k v; do
      [ -n "$k" ] || continue
      if [[ "$k" == *"+" ]]; then
        local base="${k%+}"
        map["$base"]="${map[$base]:-} ${v}"
      else
        map["$k"]="$v"
      fi
    done < <(profile::__read_conf "$(pr::__profile_conf "$p")")
  done
  # imprime resultado
  for k in "${!map[@]}"; do printf '%s=%s\n' "$k" "${map[$k]}"; done
}

profile::validate(){
  # profile::validate <name> [--strict]
  local name="$1" strict=0
  [ "$2" = "--strict" ] && strict=1
  profile::exists "$name" || { pr::__err "perfil inexistente"; return 4; }

  local conf; conf="$(pr::__profile_conf "$name")"
  local lc v
  # valida enums e ranges principais
  v="$(pr::__kv_get "$conf" core.libc)"; case "$v" in glibc|musl) :;; *) pr::__err "core.libc inválido"; return 10;; esac
  v="$(pr::__kv_get "$conf" opt.level)"; case "$v" in minimal|normal|aggressive) :;; *) pr::__err "opt.level inválido"; return 10;; esac
  v="$(pr::__kv_get "$conf" opt.lto)"; case "$v" in off|thin|full) :;; *) pr::__err "opt.lto inválido"; return 10;; esac
  v="$(pr::__kv_get "$conf" opt.pgo)"; case "$v" in off|gen|use) :;; *) pr::__err "opt.pgo inválido"; return 10;; esac
  v="$(pr::__kv_get "$conf" linker.impl)"; case "$v" in auto|bfd|gold|lld|mold|"") :;; *) pr::__err "linker.impl inválido"; return 10;; esac
  v="$(pr::__kv_get "$conf" build.jobs)"; case "$v" in auto|''|*[!0-9]* ) [ "$v" = "auto" ] || [ -z "$v" ] || { pr::__err "build.jobs inválido"; return 10; } ;; *) [ "$v" -ge 1 ] || { pr::__err "build.jobs<1"; return 10; };; esac
  v="$(pr::__kv_get "$conf" build.make_jobs)"; case "$v" in auto|''|*[!0-9]* ) [ "$v" = "auto" ] || [ -z "$v" ] || { pr::__err "build.make_jobs inválido"; return 10; } ;; *) [ "$v" -ge 1 ] || { pr::__err "build.make_jobs<1"; return 10; };; esac
  v="$(pr::__kv_get "$conf" ui.theme)"; case "$v" in dracula|nord|monokai|solarized-dark|solarized-light|gruvbox|one-dark|"") :;; *) pr::__err "ui.theme inválido"; return 10;; esac

  # coerência
  local pgo lto strip asan
  pgo="$(pr::__kv_get "$conf" opt.pgo)"; lto="$(pr::__kv_get "$conf" opt.lto)"; strip="$(pr::__kv_get "$conf" build.strip)"; asan="$(pr::__kv_get "$conf" san.asan)"
  if [ "$pgo" = "use" ] && [ "$lto" = "off" ]; then pr::__warn "PGO=use com LTO=off pode ser ineficiente"; fi
  if [ "$asan" = "on" ] && [ "$strip" = "all" ]; then pr::__warn "ASAN=on com strip=all pode prejudicar debug"; fi

  if [ "$strict" -eq 1 ]; then
    # recusa chaves desconhecidas
    local schema_keys; schema_keys="$(profile::schema_dump | awk -v RS= '{print}' | sed -n 's/.*"keys":{\(.*\)}.*/\1/p' | tr -d '\n' | tr ',' '\n' | sed -E 's/^[[:space:]]*"([^"]+)".*/\1/')"
    while IFS='=' read -r k v; do
      echo "$schema_keys" | grep -Fxq "$k" || { pr::__err "chave desconhecida (strict)" key="$k"; return 19; }
    done < <(profile::__read_conf "$conf")
  fi

  pr::__evt "profile_validated" name="$name" strict="$strict"
  pr::__info "perfil validado" name="$name"
  return 0
}

# ---------- Ativar / Aplicar ao ambiente ----------
profile::set_active(){
  local name="$1"; pr::__is_valid_name "$name" || { pr::__err "nome inválido"; return 2; }
  profile::exists "$name" || { pr::__err "perfil inexistente"; return 4; }
  profile::validate "$name" || return $?
  echo "$name" > "$(pr::__active_path)" || { pr::__err "falha ao gravar active"; return 1; }
  if [ "$__pr_has_cfg" -eq 1 ]; then config::set adm.profile "$name" >/dev/null 2>&1 || true; fi
  pr::__evt "profile_activated" name="$name"
  pr::__info "perfil ativo definido" name="$name"
  return 0
}

profile::apply_to_env(){
  # profile::apply_to_env <name> [--stage N]
  local name="$1"; shift || true
  local stage=""
  [ "$1" = "--stage" ] && { shift; stage="${1:-}"; shift || true; }
  profile::exists "$name" || { pr::__err "perfil inexistente"; return 4; }
  local conf; conf="$(pr::__profile_conf "$name")"
  local libc opt linker jobs mjobs theme
  libc="$(pr::__kv_get "$conf" core.libc)"; opt="$(pr::__kv_get "$conf" opt.level)"
  linker="$(pr::__kv_get "$conf" linker.impl)"; jobs="$(pr::__kv_get "$conf" build.jobs)"; mjobs="$(pr::__kv_get "$conf" build.make_jobs)"
  theme="$(pr::__kv_get "$conf" ui.theme)"

  # export flags mínimas (env fará detalhamento)
  export ADM_PROFILE_NAME="$name"
  export ADM_PROFILE_LIBC="$libc"
  export ADM_PROFILE_OPT="$opt"
  export ADM_PROFILE_LINKER="${linker:-auto}"
  export ADM_PROFILE_JOBS="${jobs:-auto}"
  export ADM_PROFILE_MAKE_JOBS="${mjobs:-auto}"
  export ADM_UI_THEME="${theme:-nord}"

  # estágio (opcional)
  if [ -n "$stage" ] && [ "$__pr_has_env" -eq 1 ]; then
    env::activate_stage "$stage" "$opt" || return 22
    env::apply_profile_tuning || true
  fi

  pr::__evt "profile_applied_to_env" name="$name" stage="${stage:-current}"
  pr::__info "perfil aplicado ao ambiente" name="$name" stage="${stage:-current}"
  return 0
}
# ---------- Diff / Show / List ----------
profile::list(){
  profile::init || return $?
  local act; act="$(profile::active)"
  for d in "$__pr_dir"/*; do
    [ -d "$d" ] || continue
    local n; n="$(basename "$d")"
    [ -f "$d/profile.conf" ] || continue
    local libc opt linker; libc="$(pr::__kv_get "$d/profile.conf" core.libc)"
    opt="$(pr::__kv_get "$d/profile.conf" opt.level)"
    linker="$(pr::__kv_get "$d/profile.conf" linker.impl)"
    printf '%s %s  (libc=%s opt=%s linker=%s)\n' "$( [ "$n" = "$act" ] && echo '*' || echo ' ' )" "$n" "${libc:-?}" "${opt:-?}" "${linker:-auto}"
  done
}

profile::show(){
  # profile::show <name> [--merge]
  local name="$1" merge=0
  [ "$2" = "--merge" ] && merge=1
  profile::exists "$name" || { pr::__err "perfil inexistente"; return 4; }
  if [ "$merge" -eq 1 ]; then profile::resolve "$name" | sort; else cat "$(pr::__profile_conf "$name")"; fi
}

profile::diff(){
  # profile::diff <a> <b> [--merged]
  local A="$1" B="$2" merged=0
  [ "$3" = "--merged" ] && merged=1
  profile::exists "$A" && profile::exists "$B" || { pr::__err "perfil inexistente"; return 4; }
  local f1 f2
  if [ "$merged" -eq 1 ]; then
    f1="$__pr_dir/.diff.$A.$$"; f2="$__pr_dir/.diff.$B.$$"
    profile::resolve "$A" | sort > "$f1"; profile::resolve "$B" | sort > "$f2"
  else
    f1="$(pr::__profile_conf "$A")"; f2="$(pr::__profile_conf "$B")"
  fi
  # diff semântico simples
  awk -F= 'FNR==NR{a[$1]=$0; next} { if(!($1 in a)) print "+ "$0; else if(a[$1]!=$0) print "~ "a[$1]"  =>  "$0; delete a[$1]} END{for(k in a) print "- "a[k]}' "$f1" "$f2"
  [ "$merged" -eq 1 ] && { rm -f "$f1" "$f2"; }
}

# ---------- Tuning / Detecção ----------
profile::detect_cpu(){
  # imprime march sugerido e cores
  local march="native" cores=2
  if command -v nproc >/dev/null 2>&1; then cores="$(nproc)"; fi
  # heurística simples por arquitetura
  case "$(uname -m 2>/dev/null)" in
    x86_64) march="x86-64-v3";;
    aarch64) march="native";;
    riscv64) march="native";;
    *) march="native";;
  esac
  printf 'march=%s\ncores=%s\n' "$march" "$cores"
}

profile::detect_libc(){
  if ldd --version 2>&1 | grep -qi musl; then echo musl; else echo glibc; fi
}

profile::tune(){
  # profile::tune <name> [--cpu-detect] [--size|--speed] [--lto thin|full|off] [--pgo gen|use|off]
  local name="$1"; shift || true
  pr::__is_valid_name "$name" || { pr::__err "nome inválido"; return 2; }
  profile::exists "$name" || { pr::__err "perfil inexistente"; return 4; }

  local cpu=0 mode="" lto="" pgo=""
  while [ $# -gt 0 ]; do
    case "$1" in
      --cpu-detect) cpu=1;;
      --size) mode="size";;
      --speed) mode="speed";;
      --lto) shift; lto="${1:-}";;
      --pgo) shift; pgo="${1:-}";;
      *) pr::__err "tune: arg desconhecido" arg="$1"; return 1;;
    esac; shift || true
  done
  local conf; conf="$(pr::__profile_conf "$name")"

  if [ "$cpu" -eq 1 ]; then
    eval "$(profile::detect_cpu)"
    pr::__kv_set "$conf" flags.march "$march" || return 1
    pr::__kv_set "$conf" build.jobs "auto" || return 1
  fi
  case "$mode" in
    size) pr::__kv_set "$conf" opt.level "normal"; pr::__kv_set "$conf" build.strip "all";;
    speed) pr::__kv_set "$conf" opt.level "aggressive";;
    "") :;;
  esac
  [ -n "$lto" ] && pr::__kv_set "$conf" opt.lto "$lto"
  [ -n "$pgo" ] && pr::__kv_set "$conf" opt.pgo "$pgo"

  profile::validate "$name" || return $?
  pr::__evt "profile_tuned" name="$name"
  pr::__info "perfil ajustado" name="$name"
  return 0
}

# ---------- Export / Import ----------
profile::export(){
  # profile::export <name> [--file path]
  local name="$1"; shift || true
  local out=""
  [ "$1" = "--file" ] && { shift; out="${1:-}"; shift || true; }
  profile::exists "$name" || { pr::__err "perfil inexistente"; return 4; }
  [ -n "$out" ] || out="$__pr_dir/${name}-profile.tar.gz"
  local base; base="$(pr::__profile_dir "$name")"
  ( cd "$base/.." && tar -czf "$out" "$name" ) || { pr::__err "falha exportar tar"; return 1; }
  pr::__evt "profile_exported" name="$name" file="$out"
  echo "$out"
}

profile::import(){
  # profile::import <file> [--as name] [--force]
  local file="$1"; shift || true
  local as="" force=0
  while [ $# -gt 0 ]; do
    case "$1" in
      --as) shift; as="${1:-}";;
      --force) force=1;;
      *) pr::__err "import: arg desconhecido" arg="$1"; return 1;;
    esac; shift || true
  done
  [ -r "$file" ] || { pr::__err "arquivo não legível"; return 4; }
  profile::init || return $?
  local tmp="$__pr_dir/.import.$$"
  mkdir -p "$tmp" || return 1
  tar -xzf "$file" -C "$tmp" || { rm -rf "$tmp"; pr::__err "tar inválido"; return 5; }
  local name; name="$(ls "$tmp" | head -n1)"
  [ -n "$as" ] && name="$as"
  pr::__is_valid_name "$name" || { rm -rf "$tmp"; pr::__err "nome inválido"; return 2; }
  if profile::exists "$name" && [ "$force" -ne 1 ]; then
    rm -rf "$tmp"; pr::__err "perfil já existe (use --force)"; return 1
  fi
  rm -rf "$(pr::__profile_dir "$name")" 2>/dev/null || true
  mv "$tmp/$(ls "$tmp" | head -n1)" "$(pr::__profile_dir "$name")" || { rm -rf "$tmp"; return 1; }
  rm -rf "$tmp" || true
  profile::validate "$name" || return $?
  pr::__evt "profile_imported" name="$name"
  pr::__info "perfil importado" name="$name"
  return 0
}

# ---------- CLI ----------
profile::usage(){
  cat <<'USAGE'
adm profile <cmd> ...

Comandos:
  list
  show <name> [--merge]
  new <name> [--from <preset|other>] [--libc glibc|musl] [--opt minimal|normal|aggressive]
  copy <src> <dst>
  edit <name>
  delete <name> [--force]
  validate <name> [--strict]
  set-active <name>
  active
  resolve <name>
  diff <a> <b> [--merged]
  apply <name> [--stage N]
  tune <name> [--cpu-detect] [--size|--speed] [--lto thin|full|off] [--pgo gen|use|off]
  export <name> [--file path]
  import <tar.gz> [--as name] [--force]
USAGE
}

# Execução direta (opcional)
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  sub="$1"; shift || true
  case "$sub" in
    list)        profile::list ;;
    show)        profile::show "$@" ;;
    new)         profile::new "$@" ;;
    copy)        profile::copy "$@" ;;
    edit)        profile::edit "$@" ;;
    delete)      profile::delete "$@" ;;
    validate)    profile::validate "$@" ;;
    set-active)  profile::set_active "$@" ;;
    active)      profile::active ;;
    resolve)     profile::resolve "$@" ;;
    diff)        profile::diff "$@" ;;
    apply)       profile::apply_to_env "$@" ;;
    tune)        profile::tune "$@" ;;
    export)      profile::export "$@" ;;
    import)      profile::import "$@" ;;
    ""|-h|--help) profile::usage ;;
    *)           pr::__err "comando desconhecido: $sub"; profile::usage; exit 1 ;;
  esac
fi

# ---------- Fim seguro ----------
return 0 2>/dev/null || true
