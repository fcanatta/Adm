#!/usr/bin/env bash
# lib/config
# Carrega, mescla, valida e expõe configurações do sistema ADM.
# Inclui criação de templates default, origem por chave, fingerprint e injeção de CLI.
# Não usa set -e; funções retornam status e reportam erros claramente.
# --------- Guarda de múltiplos sources ----------
if [ -n "${__ADM_CONFIG_SOURCED:-}" ]; then
  return 0 2>/dev/null || exit 0
fi
__ADM_CONFIG_SOURCED=1

# --------- Estado interno ----------
# Tabela efetiva (arrays paralelos)
__cfg_keys=()
__cfg_vals=()
__cfg_orig=()

# Ordem de carga registrada (para dump detalhado)
__cfg_load_log=()

# Overrides de CLI (mais alta prioridade)
__cfg_cli_keys=()
__cfg_cli_vals=()
__cfg_cli_orig=()

# Ambiente whitelist → key mapping
__cfg_env_map=()

# Opções globais
__cfg_root_default="/usr/src/adm"
__cfg_profile_default="normal"
__cfg_stage_default="0"
__cfg_csv_mode=0  # para get_list

# Diretórios base (ajustados após init)
__cfg_root="$__cfg_root_default"

# --------- Integração opcional com logging ----------
__cfg_has_log=0
if declare -F log::info >/dev/null 2>&1; then __cfg_has_log=1; fi
cfg::__log_info(){ [ "$__cfg_has_log" -eq 1 ] && log::info "$@" || true; }
cfg::__log_warn(){ [ "$__cfg_has_log" -eq 1 ] && log::warn "$@" || printf '[WARN] %s\n' "$*" 1>&2; }
cfg::__log_error(){ [ "$__cfg_has_log" -eq 1 ] && log::error "$@" || printf '[ERROR] %s\n' "$*" 1>&2; }

# --------- Utilidades ----------
cfg::trim() { sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//' ; }
cfg::is_bool() { case "${1,,}" in 1|0|true|false|on|off|yes|no) return 0;; *) return 1;; esac; }
cfg::to_bool01() { case "${1,,}" in 1|true|on|yes) echo 1;; 0|false|off|no) echo 0;; *) echo ""; return 1;; esac; }
cfg::is_int() { [[ "$1" =~ ^[0-9]+$ ]]; }
cfg::is_abs_path() { [[ "$1" == /* ]]; }
cfg::is_url() { [[ "$1" =~ ^(https?|git|rsync|ftp|file)://.+ ]]; }
cfg::uniq_csv() { # normaliza CSV: trim, remove duplicatas, mantém ordem
  awk -v RS=, -v ORS=, '{gsub(/^[ \t\r\n]+|[ \t\r\n]+$/,""); if(!seen[$0]&&$0!=""){seen[$0]=1; out=out $0 ","}} END{ sub(/,$/,"",out); print out }'
}
cfg::hash_str() {
  if command -v sha256sum >/dev/null 2>&1; then
    printf '%s' "$1" | sha256sum | awk '{print $1}'
  elif command -v md5sum >/dev/null 2>&1; then
    printf '%s' "$1" | md5sum | awk '{print $1}'
  else
    # Fallback fraco
    wc -c <<<"$1" | awk '{print "len" $1}'
  fi
}

# --------- Defaults internos (valores seguros) ----------
cfg::__load_defaults() {
  cfg::set "adm.root"               "$__cfg_root_default"      "(defaults)"
  cfg::set "adm.stage"              "$__cfg_stage_default"      "(defaults)"
  cfg::set "adm.profile"            "$__cfg_profile_default"    "(defaults)"
  cfg::set "adm.jobs"               "auto"                      "(defaults)"
  cfg::set "adm.make_jobs"          "auto"                      "(defaults)"
  cfg::set "adm.theme"              "default"                   "(defaults)"
  cfg::set "adm.no_color"           "0"                         "(defaults)"
  cfg::set "adm.verbose"            "0"                         "(defaults)"
  cfg::set "adm.quiet"              "0"                         "(defaults)"

  cfg::set "fetch.parallel"         "4"                         "(defaults)"
  cfg::set "fetch.retries"          "3"                         "(defaults)"
  cfg::set "fetch.timeout_sec"      "600"                       "(defaults)"
  cfg::set "fetch.mirrors"          ""                          "(defaults)"
  cfg::set "fetch.allowed_protocols" "http,https,git,rsync,ftp,file" "(defaults)"
  cfg::set "fetch.cache_dir"        "\$adm.root/sources"        "(defaults)"
  cfg::set "fetch.gpg_verify"       "auto"                      "(defaults)"
  cfg::set "fetch.accept_insecure"  "0"                         "(defaults)"

  cfg::set "build.env_inherit"      "PATH,HOME,USER"            "(defaults)"
  cfg::set "build.env_allowlist"    "CC,CXX,AR,RANLIB,LD,PKG_CONFIG_PATH" "(defaults)"
  cfg::set "build.cflags"           "-O2 -pipe"                 "(defaults)"
  cfg::set "build.cxxflags"         "-O2 -pipe"                 "(defaults)"
  cfg::set "build.ldflags"          ""                          "(defaults)"
  cfg::set "build.lto"              "off"                       "(defaults)"
  cfg::set "build.pgo"              "off"                       "(defaults)"
  cfg::set "build.linker"           "auto"                      "(defaults)"
  cfg::set "build.strip"            "split"                     "(defaults)"
  cfg::set "build.debug"            "0"                         "(defaults)"
  cfg::set "build.network_during_build" "off"                   "(defaults)"

  cfg::set "sandbox.mode"           "chroot"                    "(defaults)"
  cfg::set "sandbox.network"        "off"                       "(defaults)"
  cfg::set "sandbox.mount_ro"       "/proc,/sys"                "(defaults)"
  cfg::set "sandbox.mount_rw"       "/tmp"                      "(defaults)"
  cfg::set "sandbox.uidmap"         "host"                      "(defaults)"
  cfg::set "sandbox.env_clean"      "1"                         "(defaults)"

  cfg::set "solver.include_optional" "0"                        "(defaults)"
  cfg::set "solver.version_policy"   "loose"                    "(defaults)"
  cfg::set "solver.rebuild_on_abi_change" "1"                   "(defaults)"

  cfg::set "pkg.enable"             "1"                         "(defaults)"
  cfg::set "pkg.format"             "tar.zst"                   "(defaults)"
  cfg::set "pkg.dir"                "\$adm.root/pkg"            "(defaults)"

  cfg::set "cache.sources.gc_days"  "90"                        "(defaults)"
  cfg::set "cache.packages.gc_days" "180"                       "(defaults)"

  cfg::set "log.level"              "INFO"                      "(defaults)"
  cfg::set "log.json_pretty"        "0"                         "(defaults)"
  cfg::set "log.fsync_on"           "ERROR,FATAL,phase_end"     "(defaults)"

  cfg::set "ui.theme"               "default"                   "(defaults)"
  cfg::set "ui.ascii_only"          "0"                         "(defaults)"

  cfg::set "initrd.compress"        "zstd"                      "(defaults)"
  cfg::set "initrd.include_modules" ""                          "(defaults)"
  cfg::set "initrd.firmware_dir"    "/lib/firmware"             "(defaults)"
  cfg::set "initrd.extra_bins"      "/bin/busybox,/sbin/udevd"  "(defaults)"

  cfg::set "update.policy"          "major_only"                "(defaults)"
  cfg::set "update.providers"       "github,gitlab,sourceforge,dir" "(defaults)"
  cfg::set "update.concurrency"     "4"                         "(defaults)"

  cfg::set "profile.libc"           "glibc"                     "(defaults)"
  cfg::set "profile.march"          "native"                    "(defaults)"
  cfg::set "profile.aggressive"     "0"                         "(defaults)"
}

# --------- Criação de diretórios/arquivos de config ---------
config::ensure_defaults() {
  # Cria estrutura mínima e arquivos comentados se ausentes
  local root="${1:-$__cfg_root_default}"
  local cfgdir="$root/config"
  mkdir -p "$cfgdir"/{adm.conf.d,profiles,stage0/config,stage1/config,stage2/config} 2>/dev/null || true

  # adm.conf
  if [ ! -f "$cfgdir/adm.conf" ]; then
    cat >"$cfgdir/adm.conf"<<'EOF'
# ADM configuração global (adm.conf)
# Formato: chave=valor  (use \, para vírgula literal; \= para igual literal)
# Exemplos úteis:
# adm.profile=normal
# adm.stage=0
# fetch.parallel=8
# ui.theme=default
EOF
  fi

  # logging.conf
  if [ ! -f "$cfgdir/logging.conf" ]; then
    cat >"$cfgdir/logging.conf"<<'EOF'
# logging.conf
level=INFO
max_size_mb=50
keep_rotations=5
keep_runs=10
days_to_keep=90
timezone=UTC
fsync_on=ERROR,FATAL,phase_end
json_pretty=0
EOF
  fi

  # fetch.conf
  if [ ! -f "$cfgdir/fetch.conf" ]; then
    cat >"$cfgdir/fetch.conf"<<'EOF'
# fetch.conf
parallel=4
retries=3
timeout_sec=600
mirrors=
allowed_protocols=http,https,git,rsync,ftp,file
cache_dir=$adm.root/sources
gpg_verify=auto
accept_insecure=0
EOF
  fi

  # sandbox.conf
  if [ ! -f "$cfgdir/sandbox.conf" ]; then
    cat >"$cfgdir/sandbox.conf"<<'EOF'
# sandbox.conf
mode=chroot
network=off
mount_ro=/proc,/sys
mount_rw=/tmp
uidmap=host
env_clean=1
EOF
  fi

  # mkinitramfs.conf
  if [ ! -f "$cfgdir/mkinitramfs.conf" ]; then
    cat >"$cfgdir/mkinitramfs.conf"<<'EOF'
# mkinitramfs.conf
compress=zstd
include_modules=
firmware_dir=/lib/firmware
extra_bins=/bin/busybox,/sbin/udevd
EOF
  fi

  # colors.conf
  if [ ! -f "$cfgdir/colors.conf" ]; then
    cat >"$cfgdir/colors.conf"<<'EOF'
# colors.conf (opcional) — redefina tokens ANSI (ex.: 35;1 para magenta bold)
# color.stage=35;1
# color.path=33
EOF
  fi

  # Profiles builtin
  for p in minimal normal aggressive; do
    if [ ! -f "$cfgdir/profiles/$p.profile" ]; then
      case "$p" in
        minimal) cat >"$cfgdir/profiles/$p.profile"<<'EOF'
# profile: minimal (stage0/1)
libc=glibc
march=native
aggressive=0
# cflags/cxxflags/lto/pgo podem ser ajustados aqui
EOF
;;
        normal) cat >"$cfgdir/profiles/$p.profile"<<'EOF'
# profile: normal (equilíbrio)
libc=glibc
march=native
aggressive=0
EOF
;;
        aggressive) cat >"$cfgdir/profiles/$p.profile"<<'EOF'
# profile: aggressive (máx perf — use com cautela)
libc=glibc
march=native
aggressive=1
EOF
;;
      esac
    fi
  done

  # Log
  cfg::__log_info "config defaults ensured" root="$root"
}

# --------- Tabela efetiva: set/get internos ----------
cfg::set() {
  # $1 key $2 value $3 origin
  local k="$1" v="$2" o="${3:-unknown}"
  if [ -z "$k" ]; then cfg::__log_error "cfg::set key vazio"; return 2; fi
  # atualiza se já existe
  local i
  for i in "${!__cfg_keys[@]}"; do
    if [ "${__cfg_keys[$i]}" = "$k" ]; then
      __cfg_vals[$i]="$v"
      __cfg_orig[$i]="$o"
      return 0
    fi
  done
  __cfg_keys+=("$k"); __cfg_vals+=("$v"); __cfg_orig+=("$o")
  return 0
}

cfg::get_raw() {
  # imprime valor bruto (sem expand) e retorna 0 se existir
  local k="$1" i
  for i in $(seq 0 $((${#__cfg_keys[@]}-1))); do
    if [ "${__cfg_keys[$i]}" = "$k" ]; then
      printf '%s' "${__cfg_vals[$i]}"
      return 0
    fi
  done
  return 1
}

cfg::origin_of() {
  local k="$1" i
  for i in $(seq 0 $((${#__cfg_keys[@]}-1))); do
    if [ "${__cfg_keys[$i]}" = "$k" ]; then
      printf '%s' "${__cfg_orig[$i]}"
      return 0
    fi
  done
  return 1
}

# --------- Parser key=value (suporta \= e \,) ----------
cfg::__parse_line() {
  # Lê stdin, emite pares "key\037value" por linha
  # Remove comentários # fora de escape e ignora linhas vazias.
  awk '
  function ltrim(s){ sub(/^[ \t\r\n]+/, "", s); return s }
  function rtrim(s){ sub(/[ \t\r\n]+$/, "", s); return s }
  function unesc(s){ gsub(/\\,/, "\034", s); gsub(/\\=/, "\035", s); return s }
  function reesc(s){ gsub(/\034/, ",", s); gsub(/\035/, "=", s); return s }
  {
    line=$0
    # remove comentários não escapados
    gsub(/\\#/, "\036", line)
    if (match(line, /(^|[^\\])#/) ) { line=substr(line,1,RSTART-1) }
    gsub(/\036/, "#", line)

    line=ltrim(rtrim(line))
    if (line=="" ) next
    # precisa ter =
    eq=index(line,"=")
    if (eq==0) next
    k=substr(line,1,eq-1); v=substr(line,eq+1)
    k=ltrim(rtrim(k)); v=ltrim(rtrim(v))
    k=unesc(k); v=unesc(v)
    printf "%s\037%s\n", reesc(k), reesc(v)
  }'
}

# --------- Loader de arquivo simples (mapeia seções) ----------
cfg::__apply_file_map() {
  # $1 file $2 prefix (ex.: "fetch."), converte k->prefix+k
  local f="$1" pre="$2" o
  [ -r "$f" ] || { cfg::__log_warn "config file inacessível" file="$f"; return 0; }
  o="$f"
  while IFS=$'\037' read -r k v; do
    [ -z "$k" ] && continue
    cfg::set "${pre}${k}" "$v" "$o"
  done < <(cfg::__parse_line < "$f")
  __cfg_load_log+=("LOAD $f prefix=$pre")
}

# --------- Loader de arquivo monolítico (adm.conf; já tem nomes completos) ----------
cfg::__apply_file_raw() {
  # $1 file
  local f="$1" o
  [ -r "$f" ] || { cfg::__log_warn "config file inacessível" file="$f"; return 0; }
  o="$f"
  while IFS=$'\037' read -r k v; do
    [ -z "$k" ] && continue
    cfg::set "$k" "$v" "$o"
  done < <(cfg::__parse_line < "$f")
  __cfg_load_log+=("LOAD $f")
}

# --------- Carregamento em camadas ----------
config::__load_all_files() {
  local root="$__cfg_root"
  local cdir="$root/config"

  # adm.conf + drop-ins
  [ -f "$cdir/adm.conf" ] && cfg::__apply_file_raw "$cdir/adm.conf"
  if [ -d "$cdir/adm.conf.d" ]; then
    local f
    for f in "$cdir/adm.conf.d/"*.conf; do
      [ -e "$f" ] || continue
      cfg::__apply_file_raw "$f"
    done
  fi

  # Módulos mapeados: logging.conf, fetch.conf, sandbox.conf, mkinitramfs.conf, colors.conf
  [ -f "$cdir/logging.conf" ]     && cfg::__apply_file_map "$cdir/logging.conf"     "log."
  [ -f "$cdir/fetch.conf" ]       && cfg::__apply_file_map "$cdir/fetch.conf"       "fetch."
  [ -f "$cdir/sandbox.conf" ]     && cfg::__apply_file_map "$cdir/sandbox.conf"     "sandbox."
  [ -f "$cdir/mkinitramfs.conf" ] && cfg::__apply_file_map "$cdir/mkinitramfs.conf" "initrd."
  # colors.conf é consumido por UI; aqui não mapeamos

  # Profile ativo
  local prof; prof="$(cfg::get "adm.profile" || true)"
  [ -z "$prof" ] && prof="$__cfg_profile_default"
  if [ -f "$cdir/profiles/$prof.profile" ]; then
    # chaves desse arquivo são mapeadas em profile.*
    cfg::__apply_file_map "$cdir/profiles/$prof.profile" "profile."
  else
    cfg::__log_warn "profile não encontrado, usando defaults" profile="$prof"
  fi

  # Stage ativo
  local stg; stg="$(cfg::get "adm.stage" || true)"
  case "$stg" in 0|1|2) ;; *) stg="$__cfg_stage_default";; esac
  local sdir="$root/stage${stg}/config"
  if [ -d "$sdir" ]; then
    local sf
    for sf in "$sdir/"*.conf; do
      [ -e "$sf" ] || continue
      # assumimos nomes já scoping (ex: fetch.conf → fetch.*)
      case "$(basename "$sf")" in
        fetch.conf)       cfg::__apply_file_map "$sf" "fetch." ;;
        sandbox.conf)     cfg::__apply_file_map "$sf" "sandbox." ;;
        logging.conf)     cfg::__apply_file_map "$sf" "log." ;;
        mkinitramfs.conf) cfg::__apply_file_map "$sf" "initrd." ;;
        *.conf)           cfg::__apply_file_raw "$sf" ;; # generic
      esac
    done
  fi

  # Override de pacote (se ADM_PKG_PATH apontar)
  if [ -n "${ADM_PKG_PATH:-}" ] && [ -f "${ADM_PKG_PATH}/local.conf" ]; then
    cfg::__apply_file_raw "${ADM_PKG_PATH}/local.conf"
  fi
}

# --------- ENV mapeado ----------
config::__setup_env_map() {
  __cfg_env_map=(
    "ADM_STAGE=adm.stage"
    "ADM_PROFILE=adm.profile"
    "ADM_JOBS=adm.jobs"
    "ADM_MAKE_JOBS=adm.make_jobs"
    "ADM_THEME=ui.theme"
    "ADM_NO_COLOR=adm.no_color"
    "ADM_VERBOSE=adm.verbose"
    "ADM_QUIET=adm.quiet"
    "ADM_FETCH_PARALLEL=fetch.parallel"
    "ADM_FETCH_MIRRORS=fetch.mirrors"
    "ADM_SANDBOX_MODE=sandbox.mode"
    "ADM_LOG_LEVEL=log.level"
  )
}

config::__apply_env() {
  local m k v
  for m in "${__cfg_env_map[@]}"; do
    k="${m%%=*}"; v="${m#*=}"
    if [ -n "${!k:-}" ]; then
      cfg::set "$v" "${!k}" "(env:$k)"
    fi
  done
}

# --------- Injeção de CLI ----------
config::inject_cli() {
  # $1 key $2 value
  local k="$1" v="$2"
  [ -z "$k" ] && { cfg::__log_error "config::inject_cli: key vazio"; return 2; }
  __cfg_cli_keys+=("$k"); __cfg_cli_vals+=("$v"); __cfg_cli_orig+=("(cli)")
  # aplica imediatamente como topo da pilha
  cfg::set "$k" "$v" "(cli)"
  return 0
}

# --------- Expansão de variáveis ----------
config::expand_vars() {
  # Expande $adm.root e ${ENV} seguros (somente ADM_* e algumas permitidas).
  local val="$1" safety=0
  # expande adm.root -> valor efetivo
  local root; root="$(cfg::get "adm.root" 2>/dev/null || echo "$__cfg_root_default")"
  val="${val//\$adm.root/$root}"

  # restrição: somente variáveis cujo nome começa com ADM_ ou PATH/HOME/USER
  local out="" c r esc=0
  # expansão simples ${VAR}
  out="$val"
  # shellcheck disable=SC2016
  out="$(printf '%s' "$out" | sed -E 's/\$\{([A-Za-z_][A-Za-z0-9_]*)\}/@@{\1}@@/g')"
  while [[ "$out" =~ @@\{([A-Za-z_][A-Za-z0-9_]*)\}@@ ]]; do
    var="${BASH_REMATCH[1]}"
    allow=0
    case "$var" in
      ADM_*|PATH|HOME|USER) allow=1;;
    esac
    rep=""
    if [ "$allow" -eq 1 ]; then rep="$(printf '%s' "${!var:-}")"; fi
    out="${out/@@{$var}@@/$rep}"
  done
  printf '%s' "$out"
}

# --------- Getters públicos básicos ----------
config::get() {
  # imprime valor expandido; rc=0 se existe
  local k="$1" raw
  if ! raw="$(cfg::get_raw "$k")"; then return 1; fi
  config::expand_vars "$raw"
  return 0
}

config::exists() {
  cfg::get_raw "$1" >/dev/null
}

config::get_bool() {
  local v; v="$(config::get "$1" 2>/dev/null || true)"
  [ -z "$v" ] && { echo ""; return 1; }
  if cfg::is_bool "$v"; then cfg::to_bool01 "$v"; else cfg::__log_error "bool inválido" key="$1" value="$v"; return 2; fi
}

config::get_int() {
  local v; v="$(config::get "$1" 2>/dev/null || true)"
  if cfg::is_int "$v"; then echo "$v"; else cfg::__log_error "int inválido" key="$1" value="$v"; return 2; fi
}

config::get_enum() {
  # $1 key $2 csv_allowed
  local k="$1" allowed_csv="$2" v
  v="$(config::get "$k" 2>/dev/null || true)"
  [ -z "$v" ] && { cfg::__log_error "enum vazio" key="$k"; return 2; }
  local ok=1 a
  IFS=, read -r -a arr <<<"$allowed_csv"
  for a in "${arr[@]}"; do [ "$v" = "$a" ] && ok=0; done
  if [ $ok -eq 0 ]; then echo "$v"; else cfg::__log_error "enum inválido" key="$k" value="$v" allowed="$allowed_csv"; return 2; fi
}

config::as_csv() {
  __cfg_csv_mode=$([ "${1:-0}" = "1" ] && echo 1 || echo 0)
}

config::get_list() {
  local v; v="$(config::get "$1" 2>/dev/null || true)"
  v="$(printf '%s' "$v" | cfg::uniq_csv)"
  if [ "$__cfg_csv_mode" -eq 1 ]; then
    printf '%s\n' "$v"
  else
    IFS=, read -r -a arr <<<"$v"
    local it
    for it in "${arr[@]}"; do [ -n "$it" ] && printf '%s\n' "$it"; done
  fi
}

config::path() {
  # retorna caminho absoluto; se relativo, concatena adm.root
  local k="$1" p; p="$(config::get "$k" 2>/dev/null || true)"
  [ -z "$p" ] && { echo ""; return 1; }
  if cfg::is_abs_path "$p"; then echo "$p"; else
    local root; root="$(config::get "adm.root" 2>/dev/null || echo "$__cfg_root_default")"
    echo "$root/${p#/}"
  fi
}

# --------- Origem por chave ----------
config::origin() {
  local k="$1" o; o="$(cfg::origin_of "$k" 2>/dev/null || true)"
  [ -n "$o" ] && printf '%s\n' "$o" || return 1
}
# --------- Validação por chave (tipos e enums) ----------
config::__validate_key() {
  local k="$1" v="$2"
  case "$k" in
    adm.root)
      if [ -z "$v" ] || [[ "$v" != /* ]]; then cfg::__log_error "adm.root deve ser caminho absoluto" value="$v"; return 2; fi;;
    adm.stage)
      case "$v" in 0|1|2) ;; *) cfg::__log_error "adm.stage inválido (0|1|2)" value="$v"; return 2;; esac;;
    adm.profile)
      [ -z "$v" ] && { cfg::__log_error "adm.profile vazio"; return 2; };;
    adm.jobs|adm.make_jobs)
      [ "$v" = "auto" ] || cfg::is_int "$v" || { cfg::__log_error "valor inválido (auto|int)" key="$k" value="$v"; return 2; };;

    fetch.parallel|fetch.retries|fetch.timeout_sec|update.concurrency|cache.sources.gc_days|cache.packages.gc_days)
      cfg::is_int "$v" || { cfg::__log_error "precisa ser inteiro >=0" key="$k" value="$v"; return 2; };;

    fetch.mirrors)
      # CSV de URLs permitidas
      local item; IFS=, read -r -a arr <<<"$(printf '%s' "$v" | cfg::uniq_csv)"
      for item in "${arr[@]}"; do [ -z "$item" ] && continue; cfg::is_url "$item" || { cfg::__log_error "URL inválida em fetch.mirrors" url="$item"; return 2; }; done;;

    fetch.allowed_protocols)
      # valida conjunto
      local allowed="http,https,git,rsync,ftp,file"
      local item ok
      IFS=, read -r -a arr <<<"$(printf '%s' "$v" | cfg::uniq_csv)"
      for item in "${arr[@]}"; do
        ok=1; for p in ${allowed//,/ }; do [ "$item" = "$p" ] && ok=0; done
        [ $ok -eq 0 ] || { cfg::__log_error "protocolo inválido" proto="$item"; return 2; }
      done;;

    fetch.cache_dir|pkg.dir)
      # pode conter $adm.root; expansão checada depois
      [ -z "$v" ] && { cfg::__log_error "caminho vazio" key="$k"; return 2; };;

    fetch.gpg_verify)
      case "$v" in auto|on|off) ;; *) cfg::__log_error "enum inválido (auto|on|off)" key="$k" value="$v"; return 2;; esac;;
    fetch.accept_insecure|adm.no_color|adm.verbose|adm.quiet|build.debug|sandbox.env_clean|solver.include_optional|solver.rebuild_on_abi_change|ui.ascii_only|profile.aggressive|pkg.enable)
      cfg::is_bool "$v" || { cfg::__log_error "bool inválido" key="$k" value="$v"; return 2; };;

    build.lto)
      case "$v" in off|thin|full) ;; *) cfg::__log_error "enum inválido (off|thin|full)" key="$k" value="$v"; return 2;; esac;;
    build.pgo)
      case "$v" in off|gen|use) ;; *) cfg::__log_error "enum inválido (off|gen|use)" key="$k" value="$v"; return 2;; esac;;
    build.linker)
      case "$v" in auto|bfd|gold|lld|mold) ;; *) cfg::__log_error "enum inválido linker" value="$v"; return 2;; esac;;
    build.strip)
      case "$v" in split|full|none) ;; *) cfg::__log_error "enum inválido strip" value="$v"; return 2;; esac;;
    build.network_during_build)
      case "$v" in on|off) ;; *) cfg::__log_error "enum inválido (on|off)" key="$k" value="$v"; return 2;; esac;;

    sandbox.mode)
      case "$v" in chroot|bwrap|none) ;; *) cfg::__log_error "sandbox.mode inválido" value="$v"; return 2;; esac;;
    sandbox.network)
      case "$v" in on|off) ;; *) cfg::__log_error "sandbox.network inválido" value="$v"; return 2;; esac;;
    sandbox.mount_ro|sandbox.mount_rw)
      : ;; # lista de caminhos, aceitamos como texto

    solver.version_policy)
      case "$v" in loose|strict|semver) ;; *) cfg::__log_error "solver.version_policy inválido" value="$v"; return 2;; esac;;

    log.level)
      case "$v" in DEBUG|INFO|WARN|ERROR|FATAL) ;; *) cfg::__log_error "log.level inválido" value="$v"; return 2;; esac;;
    log.json_pretty)
      cfg::is_bool "$v" || { cfg::__log_error "bool inválido" key="$k" value="$v"; return 2; };;
    log.fsync_on)
      : ;; # CSV de marcadores; aceitamos

    ui.theme)
      case "$v" in default|premium|flat) ;; *) cfg::__log_error "ui.theme inválido" value="$v"; return 2;; esac;;
    initrd.compress)
      case "$v" in zstd|xz|gzip) ;; *) cfg::__log_error "initrd.compress inválido" value="$v"; return 2;; esac;;

    update.policy)
      case "$v" in major_only|any) ;; *) cfg::__log_error "update.policy inválido" value="$v"; return 2;; esac;;
    update.providers)
      : ;; # CSV de provedores conhecidos; validado em uso

    profile.libc)
      case "$v" in glibc|musl) ;; *) cfg::__log_error "profile.libc inválido (glibc|musl)" value="$v"; return 2;; esac;;
    profile.march)
      : ;; # string livre; validado pelo compilador depois

    *)
      # chave desconhecida: warn (compat), não quebra
      cfg::__log_warn "chave desconhecida (mantida)" key="$k" value="$v"
      ;;
  esac
  return 0
}

config::validate() {
  local i k v rc=0
  for i in $(seq 0 $((${#__cfg_keys[@]}-1))); do
    k="${__cfg_keys[$i]}"; v="${__cfg_vals[$i]}"
    config::__validate_key "$k" "$v" || rc=$(( rc | 1 ))
  done

  # checks de coerência pós-expansão
  local cache_dir; cache_dir="$(config::path "fetch.cache_dir" 2>/dev/null || true)"
  [ -z "$cache_dir" ] && { cfg::__log_error "fetch.cache_dir inválido após expansão"; rc=$((rc|1)); }

  return "$rc"
}

# --------- Dump e origem ----------
config::dump() {
  # --effective (default) | --all
  local mode="effective"
  if [ "${1:-}" = "--all" ]; then mode="all"; fi

  if [ "$mode" = "effective" ]; then
    # imprime KV ordenados por nome
    local i
    for i in $(seq 0 $((${#__cfg_keys[@]}-1))); do
      printf '%s=%s\n' "${__cfg_keys[$i]}" "$(config::expand_vars "${__cfg_vals[$i]}")"
    done | sort
  else
    # trilha de load
    local it
    for it in "${__cfg_load_log[@]}"; do
      printf '%s\n' "$it"
    done
    printf -- '--- effective ---\n'
    local i
    for i in $(seq 0 $((${#__cfg_keys[@]}-1))); do
      printf '%-32s = %-40s   # %s\n' \
        "${__cfg_keys[$i]}" \
        "$(config::expand_vars "${__cfg_vals[$i]}")" \
        "${__cfg_orig[$i]}"
    done | sort
  fi
}

# --------- Fingerprint ----------
config::fingerprint() {
  # hash dos KVs efetivos ordenados
  local blob; blob="$(config::dump --effective)"
  cfg::hash_str "$blob"
}

# --------- Inicialização geral ----------
config::init() {
  # 1) Defaults e ensure structure
  cfg::__load_defaults
  __cfg_root="$(config::get "adm.root" 2>/dev/null || echo "$__cfg_root_default")"
  config::ensure_defaults "$__cfg_root"

  # 2) Carregar arquivos
  config::__load_all_files

  # 3) Aplicar ENV mapeado
  config::__setup_env_map
  config::__apply_env

  # 4) Aplicar CLI (já aplica no momento da injeção também)

  # 5) Validar
  if ! config::validate; then
    cfg::__log_error "configuração inválida — verifique mensagens acima"
    return 2
  fi

  # Log resumo
  cfg::__log_info "config init ok" root="$(config::get adm.root)" profile="$(config::get adm.profile)" stage="$(config::get adm.stage)"
  return 0
}

# --------- Recarregar ----------
config::reload() {
  # limpa tabela mas preserva CLI overrides (reaplicados no fim)
  local ck=("${__cfg_cli_keys[@]}") cv=("${__cfg_cli_vals[@]}") co=("${__cfg_cli_orig[@]}")
  __cfg_keys=(); __cfg_vals=(); __cfg_orig=(); __cfg_load_log=()
  cfg::__load_defaults
  __cfg_root="$(config::get "adm.root" 2>/dev/null || echo "$__cfg_root_default")"
  config::__load_all_files
  config::__setup_env_map
  config::__apply_env
  # reaplica CLI
  local i
  for i in "${!ck[@]}"; do cfg::set "${ck[$i]}" "${cv[$i]}" "${co[$i]}"; done
  config::validate || return 2
  cfg::__log_info "config reload ok"
  return 0
}

# --------- Require ----------
config::require() {
  local k="$1" v
  if ! v="$(config::get "$k")"; then
    cfg::__log_error "chave obrigatória ausente" key="$k"
    return 3
  fi
  printf '%s' "$v"
  return 0
}

# --------- Fim seguro ----------
return 0 2>/dev/null || true
