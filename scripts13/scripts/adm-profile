#!/usr/bin/env bash
# adm-profile - gerenciamento de perfis de build para o sistema ADM
# Caminho sugerido: /usr/src/adm/scripts/adm-profile

set -o pipefail
set -o nounset

# =========[ CONFIGURAÇÃO BÁSICA ]===========================================

ADM_ROOT=${ADM_ROOT:-/usr/src/adm}
ADM_PROFILE_DIR="${ADM_ROOT}/profiles"
ADM_ETC_DIR="${ADM_ROOT}/etc"
ADM_MAIN_CONF="${ADM_ETC_DIR}/adm.conf"

DRY_RUN=0
QUIET=0

# =========[ CORES E FORMATAÇÃO ]===========================================

# Cores (compatíveis com a imagem de exemplo)
C_RESET='\033[0m'
C_BOLD='\033[1m'
C_DIM='\033[2m'

C_MAGENTA='\033[35;1m'   # cabeçalhos (igual exemplo)
C_GREEN='\033[32;1m'     # setas / OK
C_YELLOW='\033[33;1m'    # avisos
C_RED='\033[31;1m'       # erros
C_CYAN='\033[36;1m'      # info complementar

CHECK_MARK="✔"

supports_color() {
    [[ -t 1 ]] && tput colors &>/dev/null
}

colorize() {
    local color="$1"; shift
    if supports_color; then
        printf "%b%s%b" "${color}" "$*" "${C_RESET}"
    else
        printf "%s" "$*"
    fi
}

timestamp() {
    date +%H:%M:%S
}

log_header() {
    local msg="$*"
    (( QUIET )) && return 0
    printf "%b %s %b%s%b\n" \
        "$(colorize "${C_MAGENTA}" "==")" \
        "$(timestamp)" \
        "$(colorize "${C_MAGENTA}" "[PROFILE]")" \
        " ${msg}" \
        "${C_RESET}"
}

log_arrow() {
    local msg="$*"
    (( QUIET )) && return 0
    printf "%b %s %s\n" \
        "$(colorize "${C_GREEN}" "->")" \
        "$(timestamp)" \
        "${msg}"
}

log_info() {
    local msg="$*"
    (( QUIET )) && return 0
    printf "%b %s %s\n" \
        "$(colorize "${C_CYAN}" "->")" \
        "$(timestamp)" \
        "${msg}"
}

log_warn() {
    local msg="$*"
    printf "%b %s %s\n" \
        "$(colorize "${C_YELLOW}" "!!")" \
        "$(timestamp)" \
        "${msg}" 1>&2
}

log_error() {
    local msg="$*"
    printf "%b %s %s\n" \
        "$(colorize "${C_RED}" "!!")" \
        "$(timestamp)" \
        "${msg}" 1>&2
}

die() {
    log_error "$*"
    exit 1
}

# =========[ SPINNER ]======================================================

_spinner_pid=""

spinner_start() {
    local msg="$1"
    (( QUIET )) && return 0

    local spin='|/-\'
    local i=0

    printf "%s " "$(colorize "${C_GREEN}" "->")"
    printf "%s " "$(timestamp)"
    printf "%s " "${msg}"

    (
        tput civis 2>/dev/null || true
        while :; do
            printf "\r%s %s %s %b%c%b" \
                "$(colorize "${C_GREEN}" "->")" \
                "$(timestamp)" \
                "${msg}" \
                "${C_CYAN}" "${spin:i++%${#spin}:1}" "${C_RESET}"
            sleep 0.1
        done
    ) &
    _spinner_pid=$!
    disown "$_spinner_pid" 2>/dev/null || true
}

spinner_stop() {
    local status=${1:-0}
    (( QUIET )) && return "${status}"

    if [[ -n "${_spinner_pid}" ]] && kill -0 "${_spinner_pid}" &>/dev/null; then
        kill "${_spinner_pid}" &>/dev/null || true
        wait "${_spinner_pid}" 2>/dev/null || true
    fi
    _spinner_pid=""

    tput cnorm 2>/dev/null || true

    local symbol msg_color
    if (( status == 0 )); then
        symbol="${CHECK_MARK}"
        msg_color="${C_GREEN}"
    else
        symbol="✖"
        msg_color="${C_RED}"
    fi

    # Limpa a linha e imprime o símbolo final
    printf "\r%b %s %b%s%b\n" \
        "$(colorize "${msg_color}" "->")" \
        "$(timestamp)" \
        "${msg_color}" "[${symbol}]" "${C_RESET}"

    return "${status}"
}

run_with_spinner() {
    local msg="$1"; shift

    if (( DRY_RUN )); then
        log_info "[dry-run] ${msg}: $*"
        return 0
    fi

    spinner_start "${msg}"
    "$@" &
    local pid=$!

    wait "${pid}"
    local status=$?

    spinner_stop "${status}"
    return "${status}"
}

# =========[ DIRETÓRIOS E ARQUIVOS ]========================================

ensure_dirs() {
    local status=0
    if [[ ! -d "${ADM_PROFILE_DIR}" ]]; then
        (( DRY_RUN )) && log_arrow "[dry-run] mkdir -p ${ADM_PROFILE_DIR}" || mkdir -p "${ADM_PROFILE_DIR}" || status=$?
    fi
    if [[ ! -d "${ADM_ETC_DIR}" ]]; then
        (( DRY_RUN )) && log_arrow "[dry-run] mkdir -p ${ADM_ETC_DIR}" || mkdir -p "${ADM_ETC_DIR}" || status=$?
    fi
    return "${status}"
}

profile_file() {
    local name="$1"
    printf "%s/%s.profile" "${ADM_PROFILE_DIR}" "${name}"
}

default_profile_file() {
    printf "%s" "${ADM_MAIN_CONF}"
}

# =========[ TEMPLATE DE PERFIS ]===========================================

write_profile_template() {
    local name="$1"
    local type="$2"
    local file="$3"

    local chost="unknown-unknown-linux-gnu"
    if command -v gcc &>/dev/null; then
        chost="$(gcc -dumpmachine 2>/dev/null || echo "${chost}")"
    elif command -v clang &>/dev/null; then
        chost="$(clang -dumpmachine 2>/dev/null || echo "${chost}")"
    fi

    local cflags_normal="-O2 -pipe"
    local cflags_aggr="-O3 -pipe -march=native -mtune=native -flto=auto -fgraphite-identity -floop-interchange -floop-strip-mine -floop-block"
    local cflags_minimal="-O2 -pipe -fno-lto"

    local makeflags_default="-j$(nproc 2>/dev/null || echo 2)"

    local cflags
    local ldflags
    local description

    case "${type}" in
        aggressive)
            cflags="${cflags_aggr}"
            ldflags="-Wl,-O1,-z,relro,-z,now -flto=auto"
            description="Perfil agressivo: otimizações máximas, LTO, preparado para PGO."
            ;;
        minimal)
            cflags="${cflags_minimal}"
            ldflags="-Wl,-O1,-z,relro"
            description="Perfil minimal: seguro para cross-toolchain e builds críticos."
            ;;
        normal|*)
            cflags="${cflags_normal}"
            ldflags="-Wl,-O1,-z,relro,-z,now"
            description="Perfil normal: equilíbrio entre performance e segurança."
            ;;
    esac

    if (( DRY_RUN )); then
        log_info "[dry-run] escrever template de profile ${name} (${type}) em ${file}"
        return 0
    fi

    cat > "${file}" <<EOF
# ADM profile: ${name}
# Tipo: ${type}
# Descrição: ${description}
PROFILE_NAME="${name}"
PROFILE_TYPE="${type}"

# Toolchain básico detectado (pode ser atualizado por detect-toolchain)
CHOST="${chost}"
CBUILD="${chost}"
CTARGET="${chost}"

CC="gcc"
CXX="g++"
AR="ar"
NM="nm"
RANLIB="ranlib"
STRIP="strip"
PKG_CONFIG="pkg-config"

CFLAGS="${cflags}"
CXXFLAGS="${cflags}"
FFLAGS="${cflags}"
LDFLAGS="${ldflags}"

# Otimizações adicionais (especialmente usadas no perfil aggressive)
LTO_FLAGS="-flto=auto"
PGO_GENERATE_FLAGS="-fprofile-generate"
PGO_USE_FLAGS="-fprofile-use -fprofile-correction"

# Paralelismo
MAKEFLAGS="${makeflags_default}"

# Diretórios padrão
ADM_ROOT="${ADM_ROOT}"
ADM_PROFILE_DIR="${ADM_PROFILE_DIR}"

# Espaço para flags específicas de linguagens
RUSTFLAGS=""
GOFLAGS=""
LLVM_FLAGS=""
EOF
}

# =========[ LEITURA E APLICAÇÃO DE PERFIS ]================================

load_profile() {
    local name="$1"
    local file
    file="$(profile_file "${name}")"

    [[ -f "${file}" ]] || die "Profile '${name}' não existe em ${file}"

    # shellcheck disable=SC1090
    source "${file}"
}

print_profile_exports() {
    local name="$1"
    local file
    file="$(profile_file "${name}")"

    [[ -f "${file}" ]] || die "Profile '${name}' não existe em ${file}"

    # Imprime export KEY="VALUE" para ser usado com: eval "\$(adm-profile apply NAME)"
    while IFS='=' read -r key value; do
        # Ignora comentários e linhas vazias
        [[ -z "${key}" ]] && continue
        [[ "${key}" =~ ^# ]] && continue

        # Remove possíveis espaços
        key="$(echo "${key}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
        value="${value#\"}"; value="${value%\"}"

        printf 'export %s="%s"\n' "${key}" "${value}"
    done < "${file}"
}
# =========[ DETECÇÃO DE TOOLCHAIN ]========================================

detect_toolchain_for_profile() {
    local name="$1"
    local file
    file="$(profile_file "${name}")"
    [[ -f "${file}" ]] || die "Profile '${name}' não existe em ${file}"

    log_header "Detectando toolchain para profile '${name}'"

    local cc cxx ar ranlib strip nm chost

    if command -v gcc &>/dev/null; then
        cc="gcc"
        cxx="g++"
        chost="$(gcc -dumpmachine 2>/dev/null || echo "unknown-unknown-linux-gnu")"
    elif command -v musl-gcc &>/dev/null; then
        cc="musl-gcc"
        cxx="g++"
        chost="$(musl-gcc -dumpmachine 2>/dev/null || echo "unknown-unknown-linux-musl")"
    elif command -v clang &>/dev/null; then
        cc="clang"
        cxx="clang++"
        chost="$(clang -dumpmachine 2>/dev/null || echo "unknown-unknown-linux-gnu")"
    else
        log_warn "Nenhum compilador C padrão encontrado (gcc/musl-gcc/clang)."
        cc=""
        cxx=""
        chost="unknown-unknown-linux-gnu"
    fi

    for bin in ar ranlib strip nm; do
        if command -v "${bin}" &>/dev/null; then
            eval "${bin}='${bin}'"
        else
            eval "${bin}='${bin}'"  # deixa nome padrão mesmo assim
        fi
    done

    if (( DRY_RUN )); then
        log_info "[dry-run] Atualizaria ${file} com:"
        log_info "  CHOST=${chost}"
        log_info "  CC=${cc}"
        log_info "  CXX=${cxx}"
        log_info "  AR=${ar}"
        log_info "  RANLIB=${ranlib}"
        log_info "  STRIP=${strip}"
        log_info "  NM=${nm}"
        return 0
    fi

    # Atualiza as linhas relevantes do arquivo
    tmpfile="${file}.tmp.$$"
    cp "${file}" "${tmpfile}" || die "Falha ao copiar profile para edição temporária."

    sed -i \
        -e "s/^CHOST=.*/CHOST=\"${chost//\//\\/}\"/" \
        -e "s/^CBUILD=.*/CBUILD=\"${chost//\//\\/}\"/" \
        -e "s/^CTARGET=.*/CTARGET=\"${chost//\//\\/}\"/" \
        -e "s/^CC=.*/CC=\"${cc}\"/" \
        -e "s/^CXX=.*/CXX=\"${cxx}\"/" \
        -e "s/^AR=.*/AR=\"${ar}\"/" \
        -e "s/^RANLIB=.*/RANLIB=\"${ranlib}\"/" \
        -e "s/^STRIP=.*/STRIP=\"${strip}\"/" \
        -e "s/^NM=.*/NM=\"${nm}\"/" \
        "${tmpfile}" || die "Falha ao atualizar parâmetros de toolchain."

    mv "${tmpfile}" "${file}" || die "Falha ao substituir profile atualizado."

    log_arrow "Toolchain detectado e gravado no profile '${name}'."
}

# =========[ COMANDOS ]=====================================================

cmd_create() {
    local name="${1:-}"
    local type="${2:-normal}"

    [[ -z "${name}" ]] && die "Uso: adm-profile create <nome> [aggressive|normal|minimal]"

    case "${type}" in
        aggressive|normal|minimal) ;;
        *) die "Tipo de profile inválido: ${type}. Use aggressive|normal|minimal." ;;
    esac

    ensure_dirs || die "Falha ao garantir diretórios base."

    local file
    file="$(profile_file "${name}")"

    if [[ -f "${file}" ]]; then
        die "Profile '${name}' já existe em ${file}"
    fi

    log_header "Criando profile '${name}' (${type})"
    run_with_spinner "Gerando template de profile" write_profile_template "${name}" "${type}" "${file}" || die "Erro ao criar profile."

    # Detecção automática de toolchain para perfis recém-criados
    run_with_spinner "Detectando toolchain para '${name}'" detect_toolchain_for_profile "${name}" || die "Erro ao detectar toolchain."

    log_arrow "Profile '${name}' criado com sucesso."
}

cmd_list() {
    ensure_dirs || die "Falha ao garantir diretórios base."
    log_header "Listando profiles disponíveis"

    local default_profile=""
    if [[ -f "$(default_profile_file)" ]]; then
        # shellcheck disable=SC1090
        source "$(default_profile_file)"
        default_profile="${DEFAULT_PROFILE:-}"
    fi

    local f name type
    shopt -s nullglob
    for f in "${ADM_PROFILE_DIR}"/*.profile; do
        name="$(basename "${f}" .profile)"
        type="$(grep -E '^PROFILE_TYPE=' "${f}" 2>/dev/null | head -n1 | cut -d'"' -f2 || echo "desconhecido")"
        if [[ "${name}" == "${default_profile}" ]]; then
            printf "%b %s (tipo=%s) [default]%b\n" "${C_GREEN}" "${name}" "${type}" "${C_RESET}"
        else
            printf "%s (tipo=%s)\n" "${name}" "${type}"
        fi
    done
    shopt -u nullglob
}

cmd_show() {
    local name="${1:-}"
    [[ -z "${name}" ]] && die "Uso: adm-profile show <nome>"

    local file
    file="$(profile_file "${name}")"
    [[ -f "${file}" ]] || die "Profile '${name}' não existe."

    log_header "Exibindo profile '${name}'"
    cat "${file}"
}

cmd_delete() {
    local name="${1:-}"
    [[ -z "${name}" ]] && die "Uso: adm-profile delete <nome>"

    local file
    file="$(profile_file "${name}")"
    [[ -f "${file}" ]] || die "Profile '${name}' não existe."

    log_header "Removendo profile '${name}'"

    if (( DRY_RUN )); then
        log_arrow "[dry-run] rm -f ${file}"
        return 0
    fi

    rm -f "${file}" || die "Falha ao remover profile '${name}'."
    log_arrow "Profile '${name}' removido."
}

cmd_set_default() {
    local name="${1:-}"
    [[ -z "${name}" ]] && die "Uso: adm-profile set-default <nome>"

    local file
    file="$(profile_file "${name}")"
    [[ -f "${file}" ]] || die "Profile '${name}' não existe."

    ensure_dirs || die "Falha ao garantir diretórios base."

    log_header "Definindo profile padrão '${name}'"

    if (( DRY_RUN )); then
        log_arrow "[dry-run] DEFAULT_PROFILE=${name} em $(default_profile_file)"
        return 0
    fi

    cat > "$(default_profile_file)" <<EOF
# Configuração principal do ADM
DEFAULT_PROFILE="${name}"
EOF

    log_arrow "Profile padrão definido para '${name}'."
}

cmd_get_default() {
    if [[ -f "$(default_profile_file)" ]]; then
        # shellcheck disable=SC1090
        source "$(default_profile_file)"
        echo "${DEFAULT_PROFILE:-}"
    else
        die "Nenhum profile padrão definido."
    fi
}

cmd_apply() {
    local name="${1:-}"
    [[ -z "${name}" ]] && die "Uso: adm-profile apply <nome>"

    # Não usar spinner aqui; a saída deve ser limpa para eval
    print_profile_exports "${name}"
}

cmd_detect_toolchain() {
    local name="${1:-}"
    [[ -z "${name}" ]] && die "Uso: adm-profile detect-toolchain <nome>"

    ensure_dirs || die "Falha ao garantir diretórios base."
    detect_toolchain_for_profile "${name}" || exit 1
}

cmd_help() {
    cat <<EOF
Uso: adm-profile [OPÇÕES] <comando> [args]

OPÇÕES:
  -n, --dry-run     Não modifica nada, apenas mostra o que faria
  -q, --quiet       Modo silencioso (apenas erros)
  -h, --help        Mostra esta ajuda

COMANDOS:
  create <nome> [aggressive|normal|minimal]
      Cria um novo profile com o tipo especificado.

  list
      Lista todos os profiles disponíveis e indica o padrão.

  show <nome>
      Mostra o conteúdo bruto de um profile.

  delete <nome>
      Remove um profile existente.

  set-default <nome>
      Define o profile padrão do sistema.

  get-default
      Mostra o nome do profile padrão atual.

  apply <nome>
      Imprime "export VAR=..." do profile (use com: eval "\$(adm-profile apply <nome>)").

  detect-toolchain <nome>
      Detecta o toolchain disponível (gcc/clang/musl) e atualiza o profile.
EOF
}

# =========[ PARSE DE ARGUMENTOS GLOBAIS ]==================================

parse_global_opts() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--dry-run)
                DRY_RUN=1
                shift
                ;;
            -q|--quiet)
                QUIET=1
                shift
                ;;
            -h|--help)
                cmd_help
                exit 0
                ;;
            --)
                shift
                break
                ;;
            -*)
                die "Opção desconhecida: $1"
                ;;
            *)
                break
                ;;
        esac
    done

    # Retorna o resto dos argumentos
    echo "$#"
}

# =========[ MAIN ]=========================================================

main() {
    local argc
    argc=$(parse_global_opts "$@")
    # Recupera os argumentos restantes após o parse
    local args=("$@")
    local consumed=$(( ${#args[@]} - argc ))
    args=("${args[@]:${consumed}}")

    if [[ ${#args[@]} -lt 1 ]]; then
        cmd_help
        exit 1
    fi

    local cmd="${args[0]}"
    shift || true

    case "${cmd}" in
        create)          cmd_create "$@" ;;
        list)            cmd_list "$@" ;;
        show)            cmd_show "$@" ;;
        delete)          cmd_delete "$@" ;;
        set-default)     cmd_set_default "$@" ;;
        get-default)     cmd_get_default "$@" ;;
        apply)           cmd_apply "$@" ;;
        detect-toolchain) cmd_detect_toolchain "$@" ;;
        help|-h|--help)  cmd_help ;;
        *)
            die "Comando desconhecido: ${cmd}"
            ;;
    esac
}

trap 'spinner_stop 1 >/dev/null 2>&1 || true' INT TERM

main "$@"
