#!/usr/bin/env bash
# adm-construct - compila e instala em DESTDIR usando dados do adm-source

set -o pipefail
set -o nounset

# =========[ CONFIG BÁSICA ]================================================

ADM_ROOT=${ADM_ROOT:-/usr/src/adm}
ADM_REPO="${ADM_ROOT}/repo"
ADM_WORK_BASE="${ADM_ROOT}/work"
ADM_DESTDIR_BASE="${ADM_ROOT}/destdir"
ADM_LOG_DIR="${ADM_ROOT}/logs"
ADM_DB_DIR="${ADM_ROOT}/db"
ADM_PROFILE_CMD="${ADM_ROOT}/scripts/adm-profile"

DRY_RUN=0
QUIET=0
CHROOT_DIR=""

# =========[ CORES / LOG ]==================================================

C_RESET='\033[0m'
C_BOLD='\033[1m'

C_MAGENTA='\033[35;1m'
C_GREEN='\033[32;1m'
C_YELLOW='\033[33;1m'
C_RED='\033[31;1m'
C_CYAN='\033[36;1m'

CHECK_MARK="✔"

supports_color() {
    [[ -t 1 ]] && tput colors &>/dev/null
}

colorize() {
    local color="$1"; shift
    if supports_color; then
        printf "%b%s%b" "${color}" "$*" "${C_RESET}"
    else
        printf "%s" "$*"
    fi
}

timestamp() {
    date +%H:%M:%S
}

log_header() {
    local msg="$*"
    (( QUIET )) && return 0
    printf "%b %s %b%s%b\n" \
        "$(colorize "${C_MAGENTA}" "==")" \
        "$(timestamp)" \
        "$(colorize "${C_MAGENTA}" "[BUILD]")" \
        " ${msg}" \
        "${C_RESET}"
}

log_arrow() {
    local msg="$*"
    (( QUIET )) && return 0
    printf "%b %s %s\n" \
        "$(colorize "${C_GREEN}" "->")" \
        "$(timestamp)" \
        "${msg}"
}

log_info() {
    local msg="$*"
    (( QUIET )) && return 0
    printf "%b %s %s\n" \
        "$(colorize "${C_CYAN}" "->")" \
        "$(timestamp)" \
        "${msg}"
}

log_warn() {
    local msg="$*"
    printf "%b %s %s\n" \
        "$(colorize "${C_YELLOW}" "!!")" \
        "$(timestamp)" \
        "${msg}" 1>&2
}

log_error() {
    local msg="$*"
    printf "%b %s %s\n" \
        "$(colorize "${C_RED}" "!!")" \
        "$(timestamp)" \
        "${msg}" 1>&2
}

die() {
    log_error "$*"
    exit 1
}

# =========[ SPINNER ]======================================================

_spinner_pid=""

spinner_start() {
    local msg="$1"
    (( QUIET )) && return 0

    local spin='|/-\'
    local i=0

    printf "%s %s %s " "$(colorize "${C_GREEN}" "->")" "$(timestamp)" "${msg}"

    (
        tput civis 2>/dev/null || true
        while :; do
            printf "\r%s %s %s %b%c%b" \
                "$(colorize "${C_GREEN}" "->")" \
                "$(timestamp)" \
                "${msg}" \
                "${C_CYAN}" "${spin:i++%${#spin}:1}" "${C_RESET}"
            sleep 0.1
        done
    ) &
    _spinner_pid=$!
    disown "$_spinner_pid" 2>/dev/null || true
}

spinner_stop() {
    local status=${1:-0}
    (( QUIET )) && return "${status}"

    if [[ -n "${_spinner_pid}" ]] && kill -0 "${_spinner_pid}" &>/dev/null; then
        kill "${_spinner_pid}" &>/dev/null || true
        wait "${_spinner_pid}" 2>/dev/null || true
    fi
    _spinner_pid=""

    tput cnorm 2>/dev/null || true

    local symbol msg_color
    if (( status == 0 )); then
        symbol="${CHECK_MARK}"
        msg_color="${C_GREEN}"
    else
        symbol="✖"
        msg_color="${C_RED}"
    fi

    printf "\r%b %s %b%s%b\n" \
        "$(colorize "${msg_color}" "->")" \
        "$(timestamp)" \
        "${msg_color}" "[${symbol}]" "${C_RESET}"

    return "${status}"
}

run_with_spinner() {
    local msg="$1"; shift

    if (( DRY_RUN )); then
        log_info "[dry-run] ${msg}: $*"
        return 0
    fi

    spinner_start "${msg}"
    "$@" &
    local pid=$!

    wait "${pid}"
    local status=$?

    spinner_stop "${status}"
    return "${status}"
}

# =========[ DIRETÓRIOS / LOG / DB ]========================================

ensure_dirs() {
    local d
    for d in "${ADM_WORK_BASE}" "${ADM_DESTDIR_BASE}" "${ADM_LOG_DIR}" "${ADM_DB_DIR}"; do
        if [[ ! -d "${d}" ]]; then
            if (( DRY_RUN )); then
                log_arrow "[dry-run] mkdir -p ${d}"
            else
                mkdir -p "${d}" || die "Falha ao criar diretório ${d}"
            fi
        fi
    done
}

log_file_for() {
    local category="$1" pkg="$2"
    printf "%s/build-%s-%s.%s.log" "${ADM_LOG_DIR}" "${category}" "${pkg}" "$(date +%Y%m%d-%H%M%S)"
}

# =========[ PROFILE / DETECTION ]=========================================

apply_profile_env() {
    local profile="$1"

    [[ -x "${ADM_PROFILE_CMD}" ]] || die "adm-profile não encontrado em ${ADM_PROFILE_CMD}"

    # shellcheck disable=SC2046
    eval "$("${ADM_PROFILE_CMD}" apply "${profile}")" || die "Falha ao aplicar profile '${profile}'"
}

meta_path() {
    local category="$1" pkg="$2"
    printf "%s/%s/%s/metafile" "${ADM_REPO}" "${category}" "${pkg}"
}

meta_get() {
    local category="$1" pkg="$2" key="$3"
    local file
    file="$(meta_path "${category}" "${pkg}")"
    [[ -f "${file}" ]] || die "Metafile não encontrado: ${file}"

    local line
    line="$(grep -E "^${key}=" "${file}" 2>/dev/null || true)"
    [[ -z "${line}" ]] && return 1
    echo "${line#${key}=}"
}

meta_name()    { meta_get "$1" "$2" "name";    }
meta_version() { meta_get "$1" "$2" "version"; }

detect_file_path() {
    local category="$1" pkg="$2"
    local name version
    name="$(meta_name "${category}" "${pkg}")"
    version="$(meta_version "${category}" "${pkg}")"
    printf "%s/%s/%s-%s/.adm-detect.env" "${ADM_WORK_BASE}" "${category}" "${name}" "${version}"
}

ensure_detection() {
    local category="$1" pkg="$2" profile="$3"
    local dfile
    dfile="$(detect_file_path "${category}" "${pkg}")"

    if [[ -f "${dfile}" ]]; then
        echo "${dfile}"
        return 0
    fi

    # chama adm-source prepare
    if [[ -x "${ADM_ROOT}/scripts/adm-source" ]]; then
        log_header "Detecção ainda não existe, chamando adm-source prepare"
        if (( DRY_RUN )); then
            log_info "[dry-run] adm-source prepare ${category} ${pkg} --profile ${profile}"
            echo "${dfile}"
            return 0
        fi
        "${ADM_ROOT}/scripts/adm-source" prepare "${category}" "${pkg}" --profile "${profile}" || die "adm-source prepare falhou."
        [[ -f "${dfile}" ]] || die "adm-source concluiu mas arquivo de detecção não foi encontrado: ${dfile}"
        echo "${dfile}"
        return 0
    fi

    die "Arquivo de detecção não existe e adm-source não foi encontrado."
}

load_detection() {
    local dfile="$1"
    [[ -f "${dfile}" ]] || die "Arquivo de detecção não encontrado: ${dfile}"
    # shellcheck disable=SC1090
    source "${dfile}"
}

# =========[ CHROOT / EXECUÇÃO LOGADA ]====================================

run_logged() {
    local log_file="$1"; shift

    if (( DRY_RUN )); then
        log_info "[dry-run] $*"
        return 0
    fi

    {
        echo "=== $(date) ==="
        echo "CMD: $*"
    } >> "${log_file}"

    "$@" >> "${log_file}" 2>&1
}

run_in_chroot() {
    local log_file="$1"; shift

    if [[ -z "${CHROOT_DIR}" ]]; then
        run_logged "${log_file}" "$@"
        return $?
    fi

    if (( DRY_RUN )); then
        log_info "[dry-run] chroot ${CHROOT_DIR} $*"
        return 0
    fi

    {
        echo "=== $(date) ==="
        echo "CHROOT: ${CHROOT_DIR}"
        echo "CMD: $*"
    } >> "${log_file}"

    chroot "${CHROOT_DIR}" /usr/bin/env bash -lc "$*" >> "${log_file}" 2>&1
}

# =========[ PATCHES / HOOKS ]=============================================

patch_dir_for() {
    local category="$1" pkg="$2"
    printf "%s/%s/%s/patch" "${ADM_REPO}" "${category}" "${pkg}"
}

hook_dir_for() {
    local category="$1" pkg="$2"
    printf "%s/%s/%s/hook" "${ADM_REPO}" "${category}" "${pkg}"
}

apply_patches() {
    local category="$1" pkg="$2" srcdir="$3" log_file="$4"

    local pdir
    pdir="$(patch_dir_for "${category}" "${pkg}")"
    [[ -d "${pdir}" ]] || { log_info "Sem patches para ${category}/${pkg}."; return 0; }

    local patch
    shopt -s nullglob
    for patch in "${pdir}"/*.patch; do
        if (( DRY_RUN )); then
            log_info "[dry-run] patch -p1 < ${patch}"
            continue
        fi
        log_arrow "Aplicando patch $(basename "${patch}")"
        run_logged "${log_file}" bash -c "cd '${srcdir}' && patch -p1 < '${patch}'" || die "Falha ao aplicar patch ${patch}"
    done
    shopt -u nullglob
}

run_hooks() {
    local stage="$1" category="$2" pkg="$3" srcdir="$4" destdir="$5" log_file="$6"

    local hdir
    hdir="$(hook_dir_for "${category}" "${pkg}")"
    [[ -d "${hdir}" ]] || return 0

    local hook
    shopt -s nullglob
    for hook in "${hdir}/${stage}"*; do
        [[ -x "${hook}" ]] || continue
        if (( DRY_RUN )); then
            log_info "[dry-run] HOOK(${stage}): ${hook}"
            continue
        fi
        log_arrow "Executando hook ${stage}: $(basename "${hook}")"
        run_logged "${log_file}" bash -c "cd '${srcdir}'; DESTDIR='${destdir}' '${hook}'" || die "Hook ${hook} falhou."
    done
    shopt -u nullglob
}

# =========[ DESTDIR / REGISTRO ]==========================================

destdir_for() {
    local category="$1" pkg="$2"
    local name version
    name="$(meta_name "${category}" "${pkg}")"
    version="$(meta_version "${category}" "${pkg}")"
    printf "%s/%s/%s-%s" "${ADM_DESTDIR_BASE}" "${category}" "${name}" "${version}"
}

register_build_success() {
    local category="$1" pkg="$2" destdir="$3" log_file="$4"

    if (( DRY_RUN )); then
        log_info "[dry-run] registraria build de ${category}/${pkg} em ${ADM_DB_DIR}"
        return 0
    fi

    mkdir -p "${ADM_DB_DIR}" || die "Falha ao criar DB dir."

    local dbfile="${ADM_DB_DIR}/builds.log"
    printf "%s %s/%s %s %s\n" "$(date +%Y-%m-%dT%H:%M:%S)" "${category}" "${pkg}" "${destdir}" "${log_file}" >> "${dbfile}" || \
        log_warn "Não foi possível registrar build em ${dbfile}"

    # incrementar num_builds no metafile
    local meta
    meta="$(meta_path "${category}" "${pkg}")"
    if [[ -f "${meta}" ]]; then
        local nb
        nb="$(grep -E '^num_builds=' "${meta}" 2>/dev/null | head -n1 | cut -d'=' -f2 || echo 0)"
        nb=$(( nb + 1 ))
        sed -i "s/^num_builds=.*/num_builds=${nb}/" "${meta}" 2>/dev/null || log_warn "Falha ao atualizar num_builds em ${meta}"
    fi
}
# =========[ PIPELINES DE BUILD ]===========================================

build_autotools() {
    local srcdir="$1" destdir="$2" log_file="$3"
    local cfg_opts="--prefix=/usr"

    run_logged "${log_file}" bash -c "
        set -e
        cd '${srcdir}'
        ./configure ${cfg_opts}
    " || die "configure (autotools) falhou."

    run_logged "${log_file}" bash -c "
        set -e
        cd '${srcdir}'
        make
    " || die "make (autotools) falhou."

    run_logged "${log_file}" bash -c "
        set -e
        cd '${srcdir}'
        make DESTDIR='${destdir}' install
    " || die "make install (autotools) falhou."
}

build_make_only() {
    local srcdir="$1" destdir="$2" log_file="$3"

    run_logged "${log_file}" bash -c "
        set -e
        cd '${srcdir}'
        make
    " || die "make falhou."

    run_logged "${log_file}" bash -c "
        set -e
        cd '${srcdir}'
        if grep -Eq 'install:' Makefile GNUmakefile makefile 2>/dev/null; then
            make DESTDIR='${destdir}' install
        else
            echo 'Nenhum alvo install encontrado, copiando binários manualmente (best effort).'
            mkdir -p '${destdir}/usr/bin'
            find . -maxdepth 2 -type f -perm -u+x -exec cp -v '{}' '${destdir}/usr/bin/' \;
        fi
    " || die "fase de instalação (make-only) falhou."
}

build_cmake() {
    local srcdir="$1" destdir="$2" log_file="$3"
    local bdir="${srcdir}/build-adm"

    run_logged "${log_file}" bash -c "
        set -e
        mkdir -p '${bdir}'
        cd '${bdir}'
        cmake '${srcdir}' -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_BUILD_TYPE=Release
        cmake --build .
        DESTDIR='${destdir}' cmake --install .
    " || die "build cmake falhou."
}

build_meson() {
    local srcdir="$1" destdir="$2" log_file="$3"
    local bdir="${srcdir}/build-adm"

    run_logged "${log_file}" bash -c "
        set -e
        meson setup '${bdir}' '${srcdir}' --prefix=/usr
        ninja -C '${bdir}'
        DESTDIR='${destdir}' ninja -C '${bdir}' install
    " || die "build meson falhou."
}

build_python() {
    local srcdir="$1" destdir="$2" log_file="$3"

    run_logged "${log_file}" bash -c "
        set -e
        cd '${srcdir}'
        if [[ -f setup.py ]]; then
            python3 setup.py build
            python3 setup.py install --root='${destdir}' --prefix=/usr
        elif [[ -f pyproject.toml ]]; then
            python3 -m pip install . --prefix=/usr --root='${destdir}' --no-deps
        fi
    " || die "build python falhou."
}

build_cargo() {
    local srcdir="$1" destdir="$2" log_file="$3"

    run_logged "${log_file}" bash -c "
        set -e
        cd '${srcdir}'
        cargo build --release
        mkdir -p '${destdir}/usr/bin'
        find target/release -maxdepth 1 -type f -perm -u+x -exec cp -v '{}' '${destdir}/usr/bin/' \;
    " || die "build cargo falhou."
}

build_kernel_like() {
    local srcdir="$1" destdir="$2" log_file="$3"

    run_logged "${log_file}" bash -c "
        set -e
        cd '${srcdir}'
        make
        mkdir -p '${destdir}/lib/modules'
        find . -name '*.ko' -exec cp -v '{}' '${destdir}/lib/modules/' \; || true
    " || die "build kernel/driver falhou."
}

build_docs() {
    local srcdir="$1" destdir="$2" log_file="$3" docs_types="$4"

    [[ -n "${docs_types}" ]] || return 0

    run_logged "${log_file}" bash -c "
        set -e
        cd '${srcdir}'
        if [[ '${docs_types}' == *doxygen* && -f Doxyfile ]]; then
            doxygen Doxyfile || true
        fi
        if [[ '${docs_types}' == *sphinx* ]] && find . -name conf.py -path '*docs*' -print -quit | grep -q .; then
            ( cd docs && make html || true )
        fi
        if [[ '${docs_types}' == *manpages* ]]; then
            mkdir -p '${destdir}/usr/share/man'
            find . -name '*.1' -o -name '*.8' -exec cp -v '{}' '${destdir}/usr/share/man/' \; || true
        fi
    " || log_warn "Falha leve na construção de documentação (ignorando)."
}

# =========[ BUILD ÚNICO ]==================================================

build_single() {
    local category="$1" pkg="$2" profile="$3" destdir_opt="$4"

    ensure_dirs
    apply_profile_env "${profile}"

    local dfile
    dfile="$(ensure_detection "${category}" "${pkg}" "${profile}")"
    load_detection "${dfile}"

    local srcdir="${SOURCE_DIR}"
    [[ -d "${srcdir}" ]] || die "SOURCE_DIR inválido em detecção: ${srcdir}"

    local destdir
    if [[ -n "${destdir_opt}" ]]; then
        destdir="${destdir_opt}"
    else
        destdir="$(destdir_for "${category}" "${pkg}")"
    fi

    local log_file
    log_file="$(log_file_for "${category}" "${pkg}")"

    log_header "Construindo ${category}/${pkg}"
    log_info "Source:  ${srcdir}"
    log_info "Destdir: ${destdir}"
    log_info "Profile: ${profile}"
    log_info "Log:     ${log_file}"
    [[ -n "${CHROOT_DIR}" ]] && log_info "Chroot:  ${CHROOT_DIR}"

    if (( DRY_RUN )); then
        log_info "[dry-run] criaria DESTDIR ${destdir}"
    else
        mkdir -p "${destdir}" || die "Falha ao criar DESTDIR ${destdir}"
    fi

    apply_patches "${category}" "${pkg}" "${srcdir}" "${log_file}"

    run_hooks "pre-configure" "${category}" "${pkg}" "${srcdir}" "${destdir}" "${log_file}"

    # escolha do pipeline
    local used=""

    if [[ "${BUILD_SYSTEM}" == *"autotools"* || "${BUILD_SYSTEM}" == *"autoconf"* ]]; then
        used="autotools"
    elif [[ "${BUILD_SYSTEM}" == *"cmake"* ]]; then
        used="cmake"
    elif [[ "${BUILD_SYSTEM}" == *"meson"* ]]; then
        used="meson"
    elif [[ "${BUILD_SYSTEM}" == *"python"* ]]; then
        used="python"
    elif [[ "${BUILD_SYSTEM}" == *"make"* || -f "${srcdir}/Makefile" ]]; then
        used="make"
    fi

    # kernel / drivers prioridade
    if [[ "${IS_KERNEL:-0}" -eq 1 || "${IS_DRIVER:-0}" -eq 1 ]]; then
        used="kernel"
    fi

    log_arrow "BUILD_SYSTEM selecionado: ${used:-<desconhecido>}"

    case "${used}" in
        autotools)
            run_hooks "pre-build"  "${category}" "${pkg}" "${srcdir}" "${destdir}" "${log_file}"
            run_in_chroot "${log_file}" bash -lc "cd '${srcdir}' && : autotools" # marca no log
            build_autotools "${srcdir}" "${destdir}" "${log_file}"
            ;;
        cmake)
            run_hooks "pre-build"  "${category}" "${pkg}" "${srcdir}" "${destdir}" "${log_file}"
            build_cmake "${srcdir}" "${destdir}" "${log_file}"
            ;;
        meson)
            run_hooks "pre-build"  "${category}" "${pkg}" "${srcdir}" "${destdir}" "${log_file}"
            build_meson "${srcdir}" "${destdir}" "${log_file}"
            ;;
        python)
            run_hooks "pre-build"  "${category}" "${pkg}" "${srcdir}" "${destdir}" "${log_file}"
            build_python "${srcdir}" "${destdir}" "${log_file}"
            ;;
        kernel)
            run_hooks "pre-build"  "${category}" "${pkg}" "${srcdir}" "${destdir}" "${log_file}"
            build_kernel_like "${srcdir}" "${destdir}" "${log_file}"
            ;;
        make|"")
            run_hooks "pre-build"  "${category}" "${pkg}" "${srcdir}" "${destdir}" "${log_file}"
            build_make_only "${srcdir}" "${destdir}" "${log_file}"
            ;;
    esac

    run_hooks "post-build" "${category}" "${pkg}" "${srcdir}" "${destdir}" "${log_file}"
    build_docs "${srcdir}" "${destdir}" "${log_file}" "${DOCS_TYPES:-}"

    run_hooks "pre-install"  "${category}" "${pkg}" "${srcdir}" "${destdir}" "${log_file}"
    # Instalação já feita dentro dos pipelines (make install / ninja install etc.)
    run_hooks "post-install" "${category}" "${pkg}" "${srcdir}" "${destdir}" "${log_file}"

    register_build_success "${category}" "${pkg}" "${destdir}" "${log_file}"

    log_arrow "Construção concluída de ${category}/${pkg}. DESTDIR pronto em: ${destdir}"
}

# =========[ FILA DE BUILD / RESUME ]======================================

queue_state_file() {
    local qfile="$1"
    mkdir -p "${ADM_DB_DIR}" || true
    printf "%s/queue-%s.state" "${ADM_DB_DIR}" "$(basename "${qfile}")"
}

cmd_queue() {
    local qfile="$1"; shift || true
    [[ -z "${qfile}" ]] && die "Uso: adm-construct queue <arquivo-fila> [--profile NOME] [--chroot DIR]"
    [[ -f "${qfile}" ]] || die "Arquivo de fila não encontrado: ${qfile}"

    local profile="normal"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --profile) profile="$2"; shift 2 ;;
            --chroot)  CHROOT_DIR="$2"; shift 2 ;;
            *)
                die "Parâmetro desconhecido em queue: $1"
                ;;
        esac
    done

    ensure_dirs
    apply_profile_env "${profile}"

    local state
    state="$(queue_state_file "${qfile}")"
    local start_index=0
    if [[ -f "${state}" ]]; then
        start_index="$(cat "${state}" 2>/dev/null || echo 0)"
    fi

    log_header "Processando fila ${qfile} (start_index=${start_index})"

    local line idx=0
    while IFS= read -r line || [[ -n "${line}" ]]; do
        line="${line%%#*}"
        line="$(echo "${line}" | tr -s ' ' )"
        [[ -z "${line}" ]] && continue

        local category pkg
        category="$(echo "${line}" | cut -d' ' -f1)"
        pkg="$(echo "${line}" | cut -d' ' -f2)"

        [[ -z "${category}" || -z "${pkg}" ]] && { log_warn "Linha inválida na fila: ${line}"; continue; }

        if (( idx < start_index )); then
            log_info "Pulando (já construído): ${category}/${pkg}"
            idx=$(( idx + 1 ))
            continue
        fi

        log_header "Fila item #${idx}: ${category}/${pkg}"

        if build_single "${category}" "${pkg}" "${profile}" ""; then
            idx=$(( idx + 1 ))
            if (( DRY_RUN )); then
                log_info "[dry-run] estado da fila continuaria em ${idx}"
            else
                echo "${idx}" > "${state}"
            fi
        else
            log_error "Build falhou em ${category}/${pkg}. Próxima execução retomará deste item."
            exit 1
        fi
    done < "${qfile}"

    log_arrow "Fila concluída."
}

# =========[ COMANDOS / HELP ]=============================================

cmd_build() {
    local category="$1"; shift || true
    local pkg="$1"; shift || true
    [[ -z "${category}" || -z "${pkg}" ]] && die "Uso: adm-construct build <categoria> <programa> [--profile NOME] [--destdir PATH] [--chroot DIR]"

    local profile="normal"
    local destdir=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --profile) profile="$2"; shift 2 ;;
            --destdir) destdir="$2"; shift 2 ;;
            --chroot)  CHROOT_DIR="$2"; shift 2 ;;
            *)
                die "Parâmetro desconhecido em build: $1"
                ;;
        esac
    done

    build_single "${category}" "${pkg}" "${profile}" "${destdir}"
}

cmd_help() {
    cat <<EOF
Uso: adm-construct [OPÇÕES] <comando> [args]

OPÇÕES:
  -n, --dry-run      Não executa, apenas mostra o que faria
  -q, --quiet        Menos saída (apenas erros)
  -h, --help         Mostra esta ajuda

COMANDOS:
  build <categoria> <programa> [--profile NOME] [--destdir PATH] [--chroot DIR]
      Compila um único programa usando o .adm-detect.env do adm-source,
      aplica patches, hooks e instala em DESTDIR.

  queue <arquivo-fila> [--profile NOME] [--chroot DIR]
      Lê uma fila de "<categoria> <programa>" por linha, constrói em ordem
      e registra o índice do último sucesso para retomar em caso de falha.

  help
      Esta ajuda.
EOF
}

# =========[ PARSE GLOBAL / MAIN ]=========================================

parse_global_opts() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--dry-run)
                DRY_RUN=1; shift ;;
            -q|--quiet)
                QUIET=1; shift ;;
            -h|--help)
                cmd_help; exit 0 ;;
            --)
                shift; break ;;
            -*)
                die "Opção desconhecida: $1" ;;
            *)
                break ;;
        esac
    done

    echo "$#"
}

main() {
    local argc
    argc=$(parse_global_opts "$@")
    local args=("$@")
    local consumed=$(( ${#args[@]} - argc ))
    args=("${args[@]:${consumed}}")

    if [[ ${#args[@]} -lt 1 ]]; then
        cmd_help
        exit 1
    fi

    local cmd="${args[0]}"
    shift || true

    case "${cmd}" in
        build)        cmd_build "$@" ;;
        queue)        cmd_queue "$@" ;;
        help|-h|--help) cmd_help ;;
        *)
            die "Comando desconhecido: ${cmd}"
            ;;
    esac
}

trap 'spinner_stop 1 >/dev/null 2>&1 || true' INT TERM

main "$@"
