#!/usr/bin/env bash
# adm-update - detectar versões novas no upstream e gerar metafiles em /usr/src/adm/updates

set -o pipefail
set -o nounset

# =========[ CONFIG BÁSICA ]================================================

ADM_ROOT=${ADM_ROOT:-/usr/src/adm}
ADM_REPO="${ADM_ROOT}/repo"
ADM_UPDATES="${ADM_ROOT}/updates"
ADM_LOG_DIR="${ADM_ROOT}/logs"

ADM_SOURCE_CMD="${ADM_ROOT}/scripts/adm-source"
ADM_CROSS_CMD="${ADM_ROOT}/scripts/adm-cross-toolchain"

DRY_RUN=0
QUIET=0

DEFAULT_PROFILE="minimal"   # para detecções, seguro

# =========[ CORES / LOG ]==================================================

C_RESET='\033[0m'
C_BOLD='\033[1m'

C_MAGENTA='\033[35;1m'
C_GREEN='\033[32;1m'
C_YELLOW='\033[33;1m'
C_RED='\033[31;1m'
C_CYAN='\033[36;1m'

CHECK_MARK="✔"

supports_color() {
    [[ -t 1 ]] && tput colors &>/dev/null
}

colorize() {
    local color="$1"; shift
    if supports_color; then
        printf "%b%s%b" "${color}" "$*" "${C_RESET}"
    else
        printf "%s" "$*"
    fi
}

timestamp() {
    date +%H:%M:%S
}

log_header() {
    local msg="$*"
    (( QUIET )) && return 0
    printf "%b %s %b%s%b\n" \
        "$(colorize "${C_MAGENTA}" "==")" \
        "$(timestamp)" \
        "$(colorize "${C_MAGENTA}" "[UPDATE]")" \
        " ${msg}" \
        "${C_RESET}"
}

log_arrow() {
    local msg="$*"
    (( QUIET )) && return 0
    printf "%b %s %s\n" \
        "$(colorize "${C_GREEN}" "->")" \
        "$(timestamp)" \
        "${msg}"
}

log_info() {
    local msg="$*"
    (( QUIET )) && return 0
    printf "%b %s %s\n" \
        "$(colorize "${C_CYAN}" "->")" \
        "$(timestamp)" \
        "${msg}"
}

log_warn() {
    local msg="$*"
    printf "%b %s %s\n" \
        "$(colorize "${C_YELLOW}" "!!")" \
        "$(timestamp)" \
        "${msg}" 1>&2
}

log_error() {
    local msg="$*"
    printf "%b %s %s\n" \
        "$(colorize "${C_RED}" "!!")" \
        "$(timestamp)" \
        "${msg}" 1>&2
}

die() {
    log_error "$*"
    exit 1
}

# =========[ SPINNER ]======================================================

_spinner_pid=""

spinner_start() {
    local msg="$1"
    (( QUIET )) && return 0

    local spin='|/-\'
    local i=0

    printf "%s %s %s " "$(colorize "${C_GREEN}" "->")" "$(timestamp)" "${msg}"

    (
        tput civis 2>/dev/null || true
        while :; do
            printf "\r%s %s %s %b%c%b" \
                "$(colorize "${C_GREEN}" "->")" \
                "$(timestamp)" \
                "${msg}" \
                "${C_CYAN}" "${spin:i++%${#spin}:1}" "${C_RESET}"
            sleep 0.1
        done
    ) &
    _spinner_pid=$!
    disown "$_spinner_pid" 2>/dev/null || true
}

spinner_stop() {
    local status=${1:-0}
    (( QUIET )) && return "${status}"

    if [[ -n "${_spinner_pid}" ]] && kill -0 "${_spinner_pid}" &>/dev/null; then
        kill "${_spinner_pid}" &>/dev/null || true
        wait "${_spinner_pid}" 2>/dev/null || true
    fi
    _spinner_pid=""

    tput cnorm 2>/dev/null || true

    local symbol msg_color
    if (( status == 0 )); then
        symbol="${CHECK_MARK}"
        msg_color="${C_GREEN}"
    else
        symbol="✖"
        msg_color="${C_RED}"
    fi

    printf "\r%b %s %b%s%b\n" \
        "$(colorize "${msg_color}" "->")" \
        "$(timestamp)" \
        "${msg_color}" "[${symbol}]" "${C_RESET}"

    return "${status}"
}

run_with_spinner() {
    local msg="$1"; shift

    if (( DRY_RUN )); then
        log_info "[dry-run] ${msg}: $*"
        return 0
    fi

    spinner_start "${msg}"
    "$@" &
    local pid=$!

    wait "${pid}"
    local status=$?

    spinner_stop "${status}"
    return "${status}"
}

# =========[ DIRETÓRIOS / LOG ]=============================================

ensure_dirs() {
    local d
    for d in "${ADM_LOG_DIR}" "${ADM_UPDATES}"; do
        if [[ ! -d "${d}" ]]; then
            if (( DRY_RUN )); then
                log_arrow "[dry-run] mkdir -p ${d}"
            else
                mkdir -p "${d}" || die "Falha ao criar diretório ${d}"
            fi
        fi
    done
}

log_file_for() {
    local category="$1" pkg="$2"
    printf "%s/update-%s-%s.%s.log" "${ADM_LOG_DIR}" "${category}" "${pkg}" "$(date +%Y%m%d-%H%M%S)"
}

# =========[ METAFILE / REPO / UPDATES ]====================================

meta_path() {
    local category="$1" pkg="$2"
    printf "%s/%s/%s/metafile" "${ADM_REPO}" "${category}" "${pkg}"
}

meta_get() {
    local category="$1" pkg="$2" key="$3"
    local file
    file="$(meta_path "${category}" "${pkg}")"
    [[ -f "${file}" ]] || return 1

    local line
    line="$(grep -E "^${key}=" "${file}" 2>/dev/null || true)"
    [[ -z "${line}" ]] && return 1
    echo "${line#${key}=}"
}

meta_name()        { meta_get "$1" "$2" "name";        }
meta_version()     { meta_get "$1" "$2" "version";     }
meta_category()    { meta_get "$1" "$2" "category";    }
meta_run_deps()    { meta_get "$1" "$2" "run_deps";    }
meta_build_deps()  { meta_get "$1" "$2" "build_deps";  }
meta_opt_deps()    { meta_get "$1" "$2" "opt_deps";    }
meta_sources()     { meta_get "$1" "$2" "sources";     }
meta_homepage()    { meta_get "$1" "$2" "homepage";    }

updates_meta_path() {
    # por design do pedido: /usr/src/adm/updates/programa/metafile (sem categoria)
    local pkg="$1"
    printf "%s/%s/metafile" "${ADM_UPDATES}" "${pkg}"
}

# =========[ LOCALIZAR CATEGORIA PELO PROGRAMA ]============================

find_category_for_pkg() {
    local pkg="$1"
    [[ -d "${ADM_REPO}" ]] || die "Repositório não encontrado em ${ADM_REPO}"

    local matches=()
    local f
    while IFS= read -r -d '' f; do
        # .../repo/<category>/<pkg>/metafile
        local cat dirpkg
        cat="$(basename "$(dirname "${f}")")"
        dirpkg="$(basename "$(dirname "$(dirname "${f}")")")"
        if [[ "${dirpkg}" == "${pkg}" ]]; then
            matches+=("${cat}")
        fi
    done < <(find "${ADM_REPO}" -mindepth 3 -maxdepth 5 -type f -name 'metafile' -print0 2>/dev/null || true)

    if (( ${#matches[@]} == 0 )); then
        die "Nenhum metafile encontrado para programa '${pkg}'."
    elif (( ${#matches[@]} > 1 )); then
        log_error "Metafiles múltiplos encontrados para '${pkg}':"
        local m
        for m in "${matches[@]}"; do
            echo "  - ${m}/${pkg}"
        done
        die "Especifique a categoria explicitamente."
    else
        echo "${matches[0]}"
    fi
}

split_cat_pkg_arg() {
    local arg="$1"
    local category pkg

    if [[ "${arg}" == *"/"* ]]; then
        category="${arg%%/*}"
        pkg="${arg#*/}"
        [[ -z "${category}" || -z "${pkg}" ]] && die "Formato inválido: '${arg}' (use categoria/programa)"
    else
        pkg="${arg}"
        category="$(find_category_for_pkg "${pkg}")"
    fi

    printf "%s %s\n" "${category}" "${pkg}"
}

split_list() {
    local s="$1"
    [[ -z "${s}" ]] && return 0
    echo "${s}" | tr ',' '\n' | sed '/^[[:space:]]*$/d'
}

# =========[ DETECÇÃO DE TIPO DE SOURCE ]===================================

detect_scheme() {
    local url="$1"
    case "${url}" in
        git+http://*|git+https://*|git+ssh://*|git://*)
            echo "git"
            ;;
        http://*|https://*)
            if [[ "${url}" == *.git ]]; then
                echo "git"
            else
                echo "http"
            fi
            ;;
        rsync://*)
            echo "rsync" ;;
        ftp://*|ftps://*)
            echo "ftp" ;;
        file://*)
            echo "file" ;;
        /*|./*|../*)
            if [[ -d "${url}" ]]; then
                echo "dir"
            else
                echo "file"
            fi
            ;;
        *)
            echo "http" ;;
    esac
}

# =========[ COMPARAÇÃO DE VERSÃO (semver-like) ]==========================

version_max() {
    # imprime a maior de duas versões, usando sort -V
    printf "%s\n%s\n" "$1" "$2" | sort -V | tail -n1
}

version_is_newer() {
    local current="$1" latest="$2"
    local max
    max="$(version_max "${current}" "${latest}")"
    [[ "${max}" == "${latest}" && "${latest}" != "${current}" ]]
}

strip_v_prefix() {
    local v="$1"
    echo "${v#v}" | sed 's/^V//'
}

# =========[ DETECTAR VERSÃO MAIS NOVA EM GIT ]============================

have_cmd() { command -v "$1" &>/dev/null; }

detect_latest_from_git() {
    local url="$1" current="$2" log_file="$3"

    have_cmd git || { log_warn "git não encontrado; não dá pra checar upstream git."; return 1; }

    if (( DRY_RUN )); then
        log_info "[dry-run] git ls-remote --tags ${url}"
        return 1
    fi

    {
        echo "=== $(date) ==="
        echo "GIT-LS-REMOTE: ${url}"
    } >> "${log_file}"

    # normaliza url tipo git+https://
    [[ "${url}" == git+* ]] && url="${url#git+}"

    local tags
    tags="$(git ls-remote --tags "${url}" 2>>"${log_file}" | awk '{print $2}' | sed 's#refs/tags/##; s/\^{}$//' || true)"
    [[ -z "${tags}" ]] && { log_warn "Nenhuma tag encontrada em ${url}"; return 1; }

    # filtra tags tipo v1.2.3 ou 1.2.3
    local v
    local candidates=()
    while IFS= read -r v; do
        [[ -z "${v}" ]] && continue
        if [[ "${v}" =~ ^[vV]?[0-9] ]]; then
            candidates+=("$(strip_v_prefix "${v}")")
        fi
    done <<< "${tags}"

    [[ ${#candidates[@]} -eq 0 ]] && { log_warn "Nenhuma tag semver-ish em ${url}"; return 1; }

    local latest
    latest="$(printf "%s\n" "${candidates[@]}" | sort -V | tail -n1)"

    log_arrow "Versão mais alta nas tags de git: ${latest}"

    if version_is_newer "${current}" "${latest}"; then
        printf "%s\n" "${latest}"
        return 0
    else
        return 1
    fi
}

# =========[ HEURÍSTICA HTTP (BEM CONSERVADORA) ]==========================

detect_latest_from_http() {
    # Heurística simples: por padrão, não tenta adivinhar. Apenas loga.
    # Você pode extender depois pra olhar 'index of' com curl, grep etc.
    local url="$1" current="$2" log_file="$3"

    if (( DRY_RUN )); then
        log_info "[dry-run] (http) checaria upstream em ${url} (não implementado)."
        return 1
    fi

    {
        echo "=== $(date) ==="
        echo "HTTP-CHECK: ${url}"
    } >> "${log_file}"

    log_warn "Heurística de update HTTP ainda não implementada; upstream manual necessário."
    return 1
}

# =========[ ESCOLHER SOURCE PRINCIPAL E BUSCAR VERSÃO ]===================

detect_latest_upstream_version() {
    local category="$1" pkg="$2" log_file="$3"

    local name version sources homepage
    name="$(meta_name "${category}" "${pkg}")"
    version="$(meta_version "${category}" "${pkg}")"
    sources="$(meta_sources "${category}" "${pkg}" 2>/dev/null || echo "")"
    homepage="$(meta_homepage "${category}" "${pkg}" 2>/dev/null || echo "")"

    [[ -n "${sources}" || -n "${homepage}" ]] || { log_warn "Metafile sem sources/homepage, não dá pra checar upstream."; return 1; }

    local primary=""
    # pega primeiro source da lista
    if [[ -n "${sources}" ]]; then
        primary="$(echo "${sources}" | cut -d',' -f1)"
    fi

    if [[ -z "${primary}" && -n "${homepage}" ]]; then
        primary="${homepage}"
    fi

    [[ -n "${primary}" ]] || { log_warn "Nenhuma URL de upstream para verificar."; return 1; }

    local scheme
    scheme="$(detect_scheme "${primary}")"

    log_arrow "Upstream principal: ${primary} (tipo=${scheme})"

    local latest=""
    case "${scheme}" in
        git)
            latest="$(detect_latest_from_git "${primary}" "${version}" "${log_file}" || true)"
            ;;
        http|ftp)
            latest="$(detect_latest_from_http "${primary}" "${version}" "${log_file}" || true)"
            ;;
        *)
            log_warn "Tipo de source ${scheme} ainda sem heurística de update; ajuste manual."
            ;;
    esac

    [[ -n "${latest}" ]] || return 1

    printf "%s\n" "${latest}"
}
# =========[ GERAR METAFILE DE UPDATE ]=====================================

generate_update_metafile() {
    local category="$1" pkg="$2" new_version="$3"

    ensure_dirs

    local name version run_deps build_deps opt_deps desc home sources
    name="$(meta_name "${category}" "${pkg}")"
    version="$(meta_version "${category}" "${pkg}")"
    run_deps="$(meta_run_deps "${category}" "${pkg}" 2>/dev/null || echo "")"
    build_deps="$(meta_build_deps "${category}" "${pkg}" 2>/dev/null || echo "")"
    opt_deps="$(meta_opt_deps "${category}" "${pkg}" 2>/dev/null || echo "")"
    desc="$(meta_get "${category}" "${pkg}" "description" 2>/dev/null || echo "")"
    home="$(meta_homepage "${category}" "${pkg}" 2>/dev/null || echo "")"
    sources="$(meta_sources "${category}" "${pkg}" 2>/dev/null || echo "")"

    local upath
    upath="$(updates_meta_path "${pkg}")"
    local udir
    udir="$(dirname "${upath}")"

    if (( DRY_RUN )); then
        log_info "[dry-run] geraria metafile de update em ${upath} com versão=${new_version}"
        return 0
    fi

    mkdir -p "${udir}" || die "Falha ao criar diretório de updates ${udir}"

    cat > "${upath}" <<EOF
name=${name}
version=${new_version}
category=${category}
run_deps=${run_deps}
build_deps=${build_deps}
opt_deps=${opt_deps}
num_builds=0
description=${desc}
homepage=${home}
sha256sums=
sources=${sources}
EOF

    log_arrow "Metafile de update criado em: ${upath}"
}

# =========[ DETECTAR TOOLCHAIN / CHAMAR CROSS-TOOLCHAIN ]==================

detect_toolchain_from_category() {
    local category="$1"
    if [[ "${category}" == "cross-toolchain" || "${category}" == "sys" ]]; then
        return 0
    fi
    return 1
}

maybe_trigger_cross_toolchain() {
    local category="$1" pkg="$2"

    [[ -x "${ADM_CROSS_CMD}" ]] || { log_info "adm-cross-toolchain não encontrado; pulando integração de toolchain."; return 0; }

    if detect_toolchain_from_category "${category}"; then
        log_arrow "Pacote ${category}/${pkg} parece ser relacionado a toolchain; chamando adm-cross-toolchain."

        if (( DRY_RUN )); then
            log_info "[dry-run] ${ADM_CROSS_CMD} auto ${category} ${pkg}"
            return 0
        fi

        "${ADM_CROSS_CMD}" auto "${category}" "${pkg}" || log_warn "adm-cross-toolchain retornou erro (continuando)."
    fi
}

# =========[ UPDATES DE DEPENDÊNCIAS (RECURSIVO) ]=========================

declare -A UPDATE_VISITED

update_deps_recursive() {
    local category="$1" pkg="$2" profile="$3"

    local key="${category}/${pkg}"
    if [[ -n "${UPDATE_VISITED[${key}]:-}" ]]; then
        return 0
    fi
    UPDATE_VISITED["${key}"]=1

    local run build opt
    run="$(meta_run_deps "${category}" "${pkg}" 2>/dev/null || echo "")"
    build="$(meta_build_deps "${category}" "${pkg}" 2>/dev/null || echo "")"
    opt="$(meta_opt_deps "${category}" "${pkg}" 2>/dev/null || echo "")"

    local deps=()
    local d
    while IFS= read -r d; do
        [[ -z "${d}" ]] && continue
        deps+=("${d}")
    done < <(printf "%s\n%s\n%s\n" "${run}" "${build}" "${opt}" | tr ',' '\n' | sed '/^[[:space:]]*$/d' | sort -u)

    (( ${#deps[@]} == 0 )) && return 0

    log_arrow "Atualizando dependências de ${category}/${pkg}: ${deps[*]}"

    local dep dep_cat dep_pkg
    for dep in "${deps[@]}"; do
        if [[ "${dep}" == */* ]]; then
            dep_cat="${dep%%/*}"
            dep_pkg="${dep#*/}"
        else
            dep_pkg="${dep}"
            dep_cat="$(find_category_for_pkg "${dep_pkg}" 2>/dev/null || echo "")"
            [[ -z "${dep_cat}" ]] && { log_warn "Categoria de dep '${dep_pkg}' não encontrada; pulando."; continue; }
        fi

        # chama update só para gerar metafile de update do dep
        cmd_update_one "${dep_cat}" "${dep_pkg}" "${profile}" 0 || log_warn "Falha ao atualizar dep ${dep_cat}/${dep_pkg} (continuando)."
    done
}

# =========[ COMANDOS PRINCIPAIS ]==========================================

cmd_check() {
    local arg="$1"; shift || true
    local profile="${DEFAULT_PROFILE}"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --profile) profile="$2"; shift 2 ;;
            *)
                die "Parâmetro desconhecido em check: $1"
                ;;
        esac
    done

    local category pkg
    read -r category pkg < <(split_cat_pkg_arg "${arg}")

    ensure_dirs

    local log_file
    log_file="$(log_file_for "${category}" "${pkg}")"

    log_header "Checando upstream para ${category}/${pkg}"
    local name version
    name="$(meta_name "${category}" "${pkg}")"
    version="$(meta_version "${category}" "${pkg}")"

    log_info "Name:    ${name}"
    log_info "Version: ${version}"
    log_info "Log:     ${log_file}"

    local latest
    latest="$(detect_latest_upstream_version "${category}" "${pkg}" "${log_file}" || true)"

    if [[ -z "${latest}" ]]; then
        log_arrow "Não foi possível descobrir uma versão mais nova automaticamente."
        return 1
    fi

    if version_is_newer "${version}" "${latest}"; then
        log_arrow "Nova versão disponível: ${latest} (atual=${version})"
        echo "${latest}"
        return 0
    else
        log_arrow "Já está na versão mais recente conhecida: ${version}"
        return 0
    fi
}

cmd_update_one() {
    local category="$1" pkg="$2" profile="$3" recursive="$4"

    ensure_dirs

    local log_file
    log_file="$(log_file_for "${category}" "${pkg}")"

    log_header "Atualizando ${category}/${pkg}"
    local name version
    name="$(meta_name "${category}" "${pkg}")"
    version="$(meta_version "${category}" "${pkg}")"

    log_info "Name:    ${name}"
    log_info "Version: ${version}"
    log_info "Log:     ${log_file}"

    local latest
    latest="$(detect_latest_upstream_version "${category}" "${pkg}" "${log_file}" || true)"

    if [[ -z "${latest}" ]]; then
        log_warn "Não foi possível determinar versão nova para ${category}/${pkg}. Mantendo versão atual."
        return 1
    fi

    if ! version_is_newer "${version}" "${latest}"; then
        log_arrow "Nenhuma versão maior encontrada (upstream=${latest}, atual=${version})."
        return 0
    fi

    log_arrow "Versão nova detectada: ${latest} (atual=${version})"

    generate_update_metafile "${category}" "${pkg}" "${latest}"

    maybe_trigger_cross_toolchain "${category}" "${pkg}"

    if (( recursive == 1 )); then
        update_deps_recursive "${category}" "${pkg}" "${profile}"
    fi

    return 0
}

cmd_update() {
    local arg="$1"; shift || true
    local profile="${DEFAULT_PROFILE}"
    local recursive=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --profile) profile="$2"; shift 2 ;;
            --recursive|-r) recursive=1; shift ;;
            *)
                die "Parâmetro desconhecido em update: $1"
                ;;
        esac
    done

    local category pkg
    read -r category pkg < <(split_cat_pkg_arg "${arg}")

    # reseta mapa de visited para sessão deste update
    UPDATE_VISITED=()

    cmd_update_one "${category}" "${pkg}" "${profile}" "${recursive}"
}

cmd_show() {
    local arg="$1"

    local category pkg
    read -r category pkg < <(split_cat_pkg_arg "${arg}")

    local upath
    upath="$(updates_meta_path "${pkg}")"

    if [[ ! -f "${upath}" ]]; then
        echo "Nenhum metafile de update encontrado em ${upath}"
        return 1
    fi

    echo "== Metafile de update para ${category}/${pkg} =="
    cat "${upath}"
}

cmd_help() {
    cat <<EOF
Uso: adm-update [OPÇÕES] <comando> [args]

OPÇÕES:
  -n, --dry-run      Não modifica nada, apenas mostra o que faria
  -q, --quiet        Menos saída (apenas erros)
  -h, --help         Mostra esta ajuda

COMANDOS:
  check <categoria/programa | programa> [--profile NOME]
      Verifica se existe uma versão maior no upstream (git/https) e mostra
      qual seria a versão nova, sem criar metafile novo.

  update <categoria/programa | programa> [--profile NOME] [--recursive|-r]
      Detecta uma versão maior, se existir, e gera um metafile novo em:
        /usr/src/adm/updates/<programa>/metafile
      Com:
        name=...
        version=<nova>
        category=<categoria>
        deps iguais ao metafile atual, num_builds=0, sha256sums vazio.

      Se --recursive/-r for usado, tenta repetir o processo para todas as
      dependências (run_deps, build_deps, opt_deps), criando metafiles
      de update para elas também.

  show <categoria/programa | programa>
      Mostra o metafile de update existente em /usr/src/adm/updates/<programa>/metafile.

Notas:
  - A detecção automática de versão nova está focada em upstream via git
    (tags). Para HTTP/FTP e outros protocolos, a heurística é conservadora
    e normalmente vai pedir ajuste manual.
  - Quando o pacote parece ser de toolchain (categoria cross-toolchain/sys),
    adm-update tenta chamar adm-cross-toolchain para ajustar a toolchain
    correspondente (se o script estiver disponível).
EOF
}

# =========[ PARSE GLOBAL / MAIN ]=========================================

parse_global_opts() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--dry-run)
                DRY_RUN=1; shift ;;
            -q|--quiet)
                QUIET=1; shift ;;
            -h|--help)
                cmd_help; exit 0 ;;
            --)
                shift; break ;;
            -*)
                die "Opção desconhecida: $1" ;;
            *)
                break ;;
        esac
    done

    echo "$#"
}

main() {
    ensure_dirs

    local argc
    argc=$(parse_global_opts "$@")
    local args=("$@")
    local consumed=$(( ${#args[@]} - argc ))
    args=("${args[@]:${consumed}}")

    if [[ ${#args[@]} -lt 1 ]]; then
        cmd_help
        exit 1
    fi

    local cmd="${args[0]}"
    shift || true

    case "${cmd}" in
        check)   [[ $# -ge 1 ]] || die "Uso: adm-update check <categoria/programa | programa>"; cmd_check "$@" ;;
        update)  [[ $# -ge 1 ]] || die "Uso: adm-update update <categoria/programa | programa> [--recursive]"; cmd_update "$@" ;;
        show)    [[ $# -ge 1 ]] || die "Uso: adm-update show <categoria/programa | programa>"; cmd_show "$1" ;;
        help|-h|--help) cmd_help ;;
        *)
            die "Comando desconhecido: ${cmd}"
            ;;
    esac
}

trap 'spinner_stop 1 >/dev/null 2>&1 || true' INT TERM

main "$@"
