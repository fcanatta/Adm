#!/usr/bin/env bash
# adm-build - hardened, complete (Part 1/3)
# Responsibilities in this part:
#  - global configuration and env defaults
#  - safe logging (adm-logger fallback)
#  - basic host-tool validation
#  - module loading (adm-meta, adm-deps, adm-downloader, adm-patches, adm-hooks, adm-chroot)
#  - timers, summary helpers
#  - toolchain / compiler detection
#  - binary cache index utilities
#  - inference of build dependencies from source (autotools, cmake, meson, python, cargo, go, node, pkg-config)
#
# IMPORTANT:
#  - This file is Part 1/3. Do NOT run it alone. Concatenate Part1 + Part2 + Part3 in order.
#  - Many destructive operations and chroot enter/install steps are commented in later parts with
#    clear markers: "# UNCOMMENT FOR REAL EXECUTION (in chroot only)". Remove the comment only when running
#    inside a secure VM/chroot and after auditing the code.
#
set -euo pipefail
shopt -s extglob

# -------------------------
# CONFIGURATION (overrides via env OK)
# -------------------------
: "${ADM_ROOT:=/usr/src/adm}"
: "${ADM_BIN_DIR:=$ADM_ROOT/bin}"
: "${ADM_WORKDIR:=$ADM_ROOT/state/builds}"
: "${ADM_CACHE_BIN:=$ADM_ROOT/cache/bin}"
: "${ADM_CACHE_SRC:=$ADM_ROOT/cache/sources}"
: "${ADM_LOG_DIR:=$ADM_ROOT/logs/builds}"
: "${ADM_PROFILE_DIR:=$ADM_ROOT/profiles}"
: "${ADM_TMPDIR:=$ADM_ROOT/cache/tmp}"
: "${ADM_MANIFEST_DIR:=$ADM_ROOT/state/manifests}"
: "${ADM_STATE_DIR:=$ADM_ROOT/state}"
: "${ADM_DRY_RUN:=0}"
: "${ADM_FORCE:=0}"
: "${ADM_JOBS:=$(nproc 2>/dev/null || echo 1)}"
: "${ADM_PROFILE:=normal}"
: "${ADM_CHROOT:=}"     # must be supplied via CLI (we'll enforce chroot usage)
: "${ADM_RETRIES:=2}"
: "${ADM_DETAILED:=0}"
: "${ADM_VERBOSE:=1}"

# create required dirs (non-destructive)
mkdir -p "$ADM_WORKDIR" "$ADM_CACHE_BIN" "$ADM_CACHE_SRC" "$ADM_LOG_DIR" "$ADM_TMPDIR" "$ADM_MANIFEST_DIR" "$ADM_STATE_DIR" 2>/dev/null || true

# -------------------------
# LOGGER (use adm-logger if present; fallback to safe functions)
# -------------------------
if [ -x "$ADM_BIN_DIR/adm-logger" ]; then
  # shellcheck source=/usr/src/adm/bin/adm-logger
  source "$ADM_BIN_DIR/adm-logger"
else
  # fallback lightweight colored logger (POSIX-safe)
  _ansi() { printf '\033[%sm' "$1"; }
  _ansi_reset() { printf '\033[0m'; }
  adm_log_info() { printf "%s %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "[\033[1;35mINFO\033[0m]" "$*"; }
  adm_log_error() { printf "%s %s %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "[\033[1;31mERROR\033[0m]" "$*" >&2; }
  adm_log_correct() { printf "%s %s %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "[\033[1;33mOK\033[0m]" "$*"; }
  adm_log_debug() { [ "${ADM_VERBOSE:-1}" -ge 2 ] && printf "%s %s %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "[DEBUG]" "$*"; }
  adm_start_spinner() { :; }  # spinner is optional; external logger may implement
  adm_stop_spinner() { :; }
  adm_progress_init() { :; }
  adm_progress_update() { :; }
  adm_progress_finish() { :; }
  adm_time_start() { date +%s; }
  adm_time_end() { date +%s; }
  adm_package_log() { :; }
fi

# -------------------------
# Basic host tool checks (required & optional bins)
# -------------------------
_required_bins=(tar sha256sum awk sed grep find sort xargs)
_missing_tools=()
for b in "${_required_bins[@]}"; do
  if ! command -v "$b" >/dev/null 2>&1; then _missing_tools+=("$b"); fi
done

_optional_bins=(curl wget git zstd xz jq cmake meson ninja make gcc g++ clang rustc cargo go python3 npm)
_missing_optional=()
for b in "${_optional_bins[@]}"; do
  if ! command -v "$b" >/dev/null 2>&1; then _missing_optional+=("$b"); fi
done

if [ "${#_missing_tools[@]}" -gt 0 ] && [ "$ADM_DRY_RUN" != "1" ]; then
  adm_log_error "Missing essential system tools: ${_missing_tools[*]}. Install them before running adm-build."
  exit 1
fi

if [ "${#_missing_optional[@]}" -gt 0 ]; then
  adm_log_info "Optional tools not found (features degraded): ${_missing_optional[*]}"
fi

# -------------------------
# Load ADM helper modules if present (best-effort)
# -------------------------
for m in adm-meta adm-deps adm-downloader adm-patches adm-hooks adm-chroot adm-install; do
  if [ -x "$ADM_BIN_DIR/$m" ]; then
    # shellcheck source=/usr/src/adm/bin/adm-meta
    source "$ADM_BIN_DIR/$m"
    adm_log_debug "Loaded module: $m"
  else
    adm_log_debug "Module missing or not executable: $m"
  fi
done

# -------------------------
# Safety trap + cleanup
# -------------------------
_adm_tmp_created=()
_adm_cleanup() {
  adm_log_debug "Running cleanup..."
  # stop spinner if implemented
  adm_stop_spinner || true
  # remove tmp dirs created in this run (only ones we created)
  for d in "${_adm_tmp_created[@]:-}"; do
    if [ -d "$d" ]; then
      # be conservative: only remove if inside ADM_TMPDIR
      case "$d" in
        "$ADM_TMPDIR"/*) rm -rf "$d" 2>/dev/null || true ;;
        *) adm_log_debug "Not removing unsafe tmp: $d" ;;
      esac
    fi
  done
  adm_log_debug "Cleanup done."
}
trap _adm_cleanup EXIT INT TERM

# -------------------------
# Utility functions
# -------------------------
_adm_mktemp_dir() {
  local d
  d=$(mktemp -d "${ADM_TMPDIR}/adm-build-XXXXXX")
  _adm_tmp_created+=("$d")
  echo "$d"
}

_adm_pkg_safe() { echo "$1" | sed -E 's/[^A-Za-z0-9._+-]/_/g'; }
_adm_arch() { uname -m 2>/dev/null || echo "unknown"; }

# timer utilities (per package and step)
declare -A _ADM_STEP_STARTS
adm_time_start_pack() {
  local pkg="$1" step="$2"
  _ADM_STEP_STARTS["$pkg:$step"]=$(date +%s)
}
adm_time_end_pack() {
  local pkg="$1" step="$2"
  local s=${_ADM_STEP_STARTS["$pkg:$step"]:-0}
  if [ "$s" -eq 0 ]; then echo "00:00:00"; return; fi
  local now=$(date +%s); local diff=$((now - s))
  printf "%02d:%02d:%02d" $((diff/3600)) $(((diff%3600)/60)) $((diff%60))
}

# summary logging helper
_adm_summary_add() {
  local pkg="$1" step="$2" dur="$3" ok="$4"
  mkdir -p "$ADM_LOG_DIR/summary" 2>/dev/null || true
  printf "%s|%s|%s|%s\n" "$(date '+%Y-%m-%dT%H:%M:%S')" "$pkg" "$step" "$dur" >> "$ADM_LOG_DIR/summary/build-summary.log"
  if [ "${ADM_DETAILED:-0}" -eq 1 ]; then
    printf "%s %-20s %-12s %s\n" "$(date '+%H:%M:%S')" "$pkg" "$step" "$dur"
  fi
}

# safe-run wrapper for commands with logging
_safe_run() {
  local pkg="$1"; shift
  local logfile="$ADM_LOG_DIR/${pkg}.log"
  mkdir -p "$(dirname "$logfile")" 2>/dev/null || true
  if [ "$ADM_DRY_RUN" = "1" ]; then
    adm_log_info "[DRY-RUN] (pkg=$pkg) $*"
    return 0
  fi
  adm_log_info "(pkg=$pkg) Running: $*"
  # timestamped command header
  printf "[%s] CMD: %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$*" >> "$logfile"
  # execute
  ( set -o pipefail; "$@" ) >> "$logfile" 2>&1
  local rc=$?
  if [ "$rc" -ne 0 ]; then
    adm_log_error "(pkg=$pkg) Command failed (rc=$rc) — see $logfile"
  else
    adm_log_correct "(pkg=$pkg) Command succeeded"
  fi
  return $rc
}

# join helper
_adm_join() {
  local sep="${1:- }"
  shift
  local out=""
  for v in "$@"; do
    if [ -z "$out" ]; then out="$v"; else out="${out}${sep}${v}"; fi
  done
  printf "%s" "$out"
}

# -------------------------
# Compiler & toolchain detection (robust)
# -------------------------
declare -A ADMBUILD_COMPILERS_FOUND
_adm_detect_compilers() {
  adm_log_info "Detecting system compilers and build tools..."
  local cands=(gcc g++ clang clang++ cc c++ ld ld.lld ar ranlib strip rustc cargo go javac java python3 pip3 perl node npm meson ninja cmake autoconf automake make pkg-config pkgconf nasm yasm zstd xz)
  for c in "${cands[@]}"; do
    if command -v "$c" >/dev/null 2>&1; then
      local ver
      # some tools support --version, others not; guard it
      ver=$("$c" --version 2>/dev/null | head -n1 || echo "ok")
      ADMBUILD_COMPILERS_FOUND["$c"]="$ver"
      adm_log_debug "Detected $c -> ${ver}"
    fi
  done
  adm_log_info "Tool detection complete: found ${#ADMBUILD_COMPILERS_FOUND[@]} tools"
}

_adm_preferred_c_compiler() {
  if [ -n "${ADMBUILD_COMPILERS_FOUND[gcc]:-}" ]; then echo "gcc"; return; fi
  if [ -n "${ADMBUILD_COMPILERS_FOUND[clang]:-}" ]; then echo "clang"; return; fi
  if command -v cc >/dev/null 2>&1; then echo "cc"; return; fi
  echo ""
}

# -------------------------
# Binary cache index utilities
#  index: ADM_CACHE_BIN/index.txt lines:
#    pkg|version|arch|path|sha256|timestamp
# -------------------------
_ADM_CACHE_INDEX="$ADM_CACHE_BIN/index.txt"
_adm_cache_index_load() { mkdir -p "$ADM_CACHE_BIN" 2>/dev/null || true; touch "$_ADM_CACHE_INDEX"; }
_adm_cache_index_add() {
  local pkg="$1" ver="$2" arch="$3" path="$4" sha="$5"
  local ts
  ts=$(date +%s)
  printf "%s|%s|%s|%s|%s|%s\n" "$pkg" "$ver" "$arch" "$path" "$sha" "$ts" >> "$_ADM_CACHE_INDEX"
}
_adm_cache_find() {
  local pkg="$1"
  awk -F'|' -v pkg="$pkg" '$1==pkg {print $0}' "$_ADM_CACHE_INDEX" 2>/dev/null | sort -t'|' -k6 -n | tail -n1 || true
}
_adm_cache_verify_and_get_path() {
  local line="$1"
  [ -z "$line" ] && return 1
  IFS='|' read -r pkg ver arch path sha ts <<< "$line"
  if [ -f "$path" ]; then
    if [ -n "$sha" ] && command -v sha256sum >/dev/null 2>&1; then
      local got
      got=$(sha256sum "$path" | awk '{print $1}')
      if [ "$got" != "$sha" ]; then adm_log_error "Cached package checksum mismatch for $path"; return 1; fi
    fi
    echo "$path"
    return 0
  fi
  return 1
}

# -------------------------
# Dependency inference from source (detailed, robust)
# -------------------------
_adm_infer_deps_from_source() {
  local src="$1"
  local outfile
  outfile="$(_adm_mktemp_dir)/infer.txt"
  : >"$outfile"
  [ -d "$src" ] || { adm_log_error "Source directory not found: $src"; return 1; }

  adm_log_info "Inferring build dependencies from source: $src"

  # AUTOTOOLS: PKG_CHECK_MODULES, AC_CHECK_LIB, AC_CHECK_HEADER
  if [ -f "$src/configure.ac" ] || [ -f "$src/configure" ]; then
    grep -RHo "PKG_CHECK_MODULES\([^)]*\)" "$src" 2>/dev/null | sed -E 's/PKG_CHECK_MODULES\(([^ ,)]+).*/\1/' | tr -d '"' >> "$outfile" || true
    grep -RHo "AC_CHECK_LIB\([^,)]*" "$src" 2>/dev/null | sed -E 's/AC_CHECK_LIB\(([^,)]*).*/\1/' >> "$outfile" || true
    grep -RHo "AC_CHECK_HEADER\([^,)]*" "$src" 2>/dev/null | sed -E 's/AC_CHECK_HEADER\(([^,)]*).*/\1/' >> "$outfile" || true
  fi

  # CMake: find_package, pkg_check_modules
  if [ -f "$src/CMakeLists.txt" ]; then
    grep -RHoE "find_package\([[:space:]]*[A-Za-z0-9_:\-]+" "$src" 2>/dev/null | sed -E 's/.*find_package\(([[:space:]]*([A-Za-z0-9_:\-]+)).*/\2/' >> "$outfile" || true
    grep -RHo "pkg_check_modules\([^)]*\)" "$src" 2>/dev/null | sed -E 's/pkg_check_modules\(([^ ,)]+).*/\1/' >> "$outfile" || true
  fi

  # Meson: dependency('x')
  if [ -f "$src/meson.build" ] || grep -q "meson.build" <<<"$(ls -A "$src" 2>/dev/null)"; then
    grep -RHoE "dependency\s*\(\s*['\"][^'\"]+['\"]\s*\)" "$src" 2>/dev/null | sed -E "s/.*dependency\(['\"]([^'\"]+)['\"].*/\1/" >> "$outfile" || true
  fi

  # Python: pyproject.toml or setup.py
  if [ -f "$src/pyproject.toml" ]; then
    grep -E "requires-dist|dependencies" -n "$src/pyproject.toml" 2>/dev/null | sed -E 's/.*=//' | tr ',' '\n' | sed -E "s/['\"]//g" >> "$outfile" || true
  fi
  if [ -f "$src/setup.py" ]; then
    grep -E "install_requires|requires" -n "$src/setup.py" 2>/dev/null | sed -E 's/.*=//' | tr ',' '\n' | sed -E "s/['\"]//g" >> "$outfile" || true
  fi

  # Cargo (Rust)
  if [ -f "$src/Cargo.toml" ]; then
    sed -n '/\[dependencies\]/,/\[/{/^\[/q;p}' "$src/Cargo.toml" 2>/dev/null | grep -E '^[a-zA-Z0-9_-]+' -o >> "$outfile" || true
  fi

  # Go: go.mod
  if [ -f "$src/go.mod" ]; then
    sed -n 's/^require //p' "$src/go.mod" 2>/dev/null | awk '{print $1}' >> "$outfile" || true
  fi

  # Node: package.json
  if [ -f "$src/package.json" ]; then
    if command -v jq >/dev/null 2>&1; then
      jq -r '.dependencies // {} | keys[]' "$src/package.json" 2>/dev/null >> "$outfile" || true
    else
      sed -n '/"dependencies"/,/"}/p' "$src/package.json" 2>/dev/null | grep -E '"[a-zA-Z0-9_\-]+"' -o | sed 's/"//g' >> "$outfile" || true
    fi
  fi

  # pkg-config references generic scanning
  grep -RHo "pkg-config --cflags|pkg-config\([^)]+\)" "$src" 2>/dev/null | sed -E 's/.*pkg-config[^[:alnum:]]*([a-zA-Z0-9_.-]+).*/\1/' >> "$outfile" || true

  # Normalize output: remove quotes, parentheses, whitespace; lower-case; unique
  awk '{gsub(/["'\''()]/,""); print tolower($0)}' "$outfile" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sort -u | sed '/^$/d'

  rm -f "$outfile" || true
  return 0
}

# -------------------------
# _adm_read_metafile_deps
#  - reads build_deps and run_deps from metafile
#  - returns arrays by name reference
# -------------------------
_adm_read_metafile_deps() {
  local metafile="$1"
  local -n out_build="$2"
  local -n out_run="$3"
  out_build=()
  out_run=()
  [ -f "$metafile" ] || return 0
  # prefer adm-meta if available
  if declare -f adm_meta_load >/dev/null 2>&1; then
    adm_meta_load "$metafile"
    local b r
    b="$(adm_meta_get build_deps 2>/dev/null || echo '')"
    r="$(adm_meta_get run_deps 2>/dev/null || echo '')"
    IFS=',' read -ra arrb <<< "$b"
    for x in "${arrb[@]}"; do x="$(echo "$x" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"; [ -n "$x" ] && out_build+=("$x"); done
    IFS=',' read -ra arrr <<< "$r"
    for x in "${arrr[@]}"; do x="$(echo "$x" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"; [ -n "$x" ] && out_run+=("$x"); done
    return 0
  fi

  # crude parse fallback
  local line
  line=$(grep -E "^build_deps:" "$metafile" 2>/dev/null || true)
  line="${line#build_deps:}"
  IFS=',' read -ra arrb <<< "$line"
  for x in "${arrb[@]}"; do x="$(echo "$x" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"; [ -n "$x" ] && out_build+=("$x"); done

  line=$(grep -E "^run_deps:" "$metafile" 2>/dev/null || true)
  line="${line#run_deps:}"
  IFS=',' read -ra arrr <<< "$line"
  for x in "${arrr[@]}"; do x="$(echo "$x" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"; [ -n "$x" ] && out_run+=("$x"); done

  return 0
}

# End of Part 1/3
# -------------------------
# adm-build - Part 2/3
# Build system detection, chroot wrapper, runners and dependency resolution with cache integration
# -------------------------

# Guard variable: set to 1 only if you deliberately want to allow real system-modifying actions.
# Recommended: leave 0 and run in dry-run first, then set to 1 inside secure VM/chroot before real execution.
: "${ADM_ALLOW_EXECUTION:=0}"

# -------------------------
# Build system detection
# -------------------------
_adm_detect_build_system() {
  local srcdir="$1"
  if [ -f "$srcdir/meson.build" ]; then echo "meson"; return 0; fi
  if [ -f "$srcdir/CMakeLists.txt" ]; then echo "cmake"; return 0; fi
  if [ -f "$srcdir/Cargo.toml" ]; then echo "cargo"; return 0; fi
  if [ -f "$srcdir/pyproject.toml" ] || [ -f "$srcdir/setup.py" ]; then echo "python"; return 0; fi
  if [ -f "$srcdir/configure" ] || [ -f "$srcdir/configure.ac" ]; then echo "autotools"; return 0; fi
  if [ -f "$srcdir/Makefile" ]; then echo "make"; return 0; fi
  if [ -f "$srcdir/go.mod" ]; then echo "go"; return 0; fi
  if [ -f "$srcdir/package.json" ]; then echo "node"; return 0; fi
  if [ -x "$srcdir/build.sh" ]; then echo "script"; return 0; fi
  echo "unknown"
}

# -------------------------
# chroot wrapper (strict)
# -------------------------
_adm_require_chroot() {
  local chrootname="$1"
  if [ -z "$chrootname" ]; then
    adm_log_error "adm-build requires a chroot name (--chroot <name>)."
    return 2
  fi
  if ! [ -x "$ADM_BIN_DIR/adm-chroot" ]; then
    adm_log_error "adm-chroot not found at $ADM_BIN_DIR/adm-chroot; required for chroot operation."
    return 2
  fi
  # check exists via adm-chroot; adm-chroot interface assumed to support 'exists' command
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    if ! "$ADM_BIN_DIR/adm-chroot" exists "$chrootname" >/dev/null 2>&1; then
      adm_log_info "Chroot '$chrootname' not present; attempting to create it via adm-chroot..."
      # UNCOMMENT FOR REAL EXECUTION (in chroot only):
      # "$ADM_BIN_DIR/adm-chroot" create "$chrootname" || { adm_log_error "Failed to create chroot $chrootname"; return 1; }
      adm_log_info "[SIMULATION] Would run: adm-chroot create $chrootname"
    fi
  else
    adm_log_info "[chroot-check] ADM_ALLOW_EXECUTION=0 — simulating chroot existence check for '$chrootname'."
  fi
  return 0
}

# Execute a command inside chroot using adm-chroot enter wrapper.
# If ADM_ALLOW_EXECUTION=0, we will simulate/log but not actually enter chroot.
_adm_chroot_exec() {
  local chrootname="$1"; shift
  local cmd=( "$@" )
  if [ "$ADM_DRY_RUN" = "1" ] || [ "$ADM_ALLOW_EXECUTION" -eq 0 ]; then
    adm_log_info "[SIMULATION] chroot:$chrootname -> ${cmd[*]}"
    return 0
  fi
  # Real execution path (only if ADM_ALLOW_EXECUTION=1)
  "$ADM_BIN_DIR/adm-chroot" enter "$chrootname" -- "${cmd[@]}"
  return $?
}

# -------------------------
# Build runners (each must result in files installed under DESTDIR)
# Runners call _safe_run for commands that execute on host; installation steps use _adm_chroot_exec
# -------------------------
_adm_build_autotools() {
  local pkg="$1" src="$2" pkgdir="$3" destdir="$4" chrootname="$5"
  adm_log_info "Autotools runner: pkg=$pkg src=$src"
  adm_time_start_pack "$pkg" "configure"
  # autoreconf if needed
  if [ -f "$src/configure.ac" ] && [ ! -f "$src/configure" ]; then
    _safe_run "$pkg" bash -lc "cd '$src' && autoreconf -fi" || return $?
  fi
  adm_time_end_pack "$pkg" "configure"

  adm_time_start_pack "$pkg" "build"
  _safe_run "$pkg" bash -lc "cd '$src' && ./configure --prefix=/usr CFLAGS='${CFLAGS:-}' CXXFLAGS='${CXXFLAGS:-}' LDFLAGS='${LDFLAGS:-}'" || return $?
  _safe_run "$pkg" bash -lc "cd '$src' && make -j${ADM_JOBS}" || return $?
  adm_time_end_pack "$pkg" "build"

  adm_time_start_pack "$pkg" "install"
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    # Real install inside chroot:
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # _adm_chroot_exec "$chrootname" bash -lc "cd '$src' && make DESTDIR='$destdir' install"
    _adm_chroot_exec "$chrootname" bash -lc "echo '[SIM] make DESTDIR=$destdir install'" || return $?
  else
    adm_log_info "[SIMULATION] Would run inside chroot: cd '$src' && make DESTDIR='$destdir' install"
  fi
  adm_time_end_pack "$pkg" "install"
  return 0
}

_adm_build_cmake() {
  local pkg="$1" src="$2" pkgdir="$3" destdir="$4" chrootname="$5"
  adm_log_info "CMake runner: pkg=$pkg src=$src"
  adm_time_start_pack "$pkg" "configure"
  _safe_run "$pkg" bash -lc "cd '$src' && cmake -S . -B build -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS='${CFLAGS:-}' -DCMAKE_CXX_FLAGS='${CXXFLAGS:-}' -DCMAKE_EXE_LINKER_FLAGS='${LDFLAGS:-}'" || return $?
  adm_time_end_pack "$pkg" "configure"
  adm_time_start_pack "$pkg" "build"
  _safe_run "$pkg" bash -lc "cd '$src' && cmake --build build -- -j${ADM_JOBS}" || return $?
  adm_time_end_pack "$pkg" "build"

  adm_time_start_pack "$pkg" "install"
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # _adm_chroot_exec "$chrootname" bash -lc "cd '$src' && cmake --install build --prefix /usr --destdir '$destdir'"
    _adm_chroot_exec "$chrootname" bash -lc "echo '[SIM] cmake --install build --destdir $destdir'" || return $?
  else
    adm_log_info "[SIMULATION] Would run inside chroot: cmake --install build --destdir $destdir"
  fi
  adm_time_end_pack "$pkg" "install"
  return 0
}

_adm_build_meson() {
  local pkg="$1" src="$2" pkgdir="$3" destdir="$4" chrootname="$5"
  adm_log_info "Meson runner: pkg=$pkg src=$src"
  adm_time_start_pack "$pkg" "configure"
  _safe_run "$pkg" bash -lc "cd '$src' && meson setup builddir --prefix=/usr -Dc_args='${CFLAGS:-}' -Dcxx_args='${CXXFLAGS:-}'" || return $?
  adm_time_end_pack "$pkg" "configure"
  adm_time_start_pack "$pkg" "build"
  _safe_run "$pkg" bash -lc "cd '$src' && ninja -C builddir -j${ADM_JOBS}" || return $?
  adm_time_end_pack "$pkg" "build"

  adm_time_start_pack "$pkg" "install"
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # _adm_chroot_exec "$chrootname" bash -lc "cd '$src' && ninja -C builddir install DESTDIR='$destdir'"
    _adm_chroot_exec "$chrootname" bash -lc "echo '[SIM] ninja -C builddir install DESTDIR=$destdir'" || return $?
  else
    adm_log_info "[SIMULATION] Would run inside chroot: ninja -C builddir install DESTDIR=$destdir"
  fi
  adm_time_end_pack "$pkg" "install"
  return 0
}

_adm_build_python() {
  local pkg="$1" src="$2" pkgdir="$3" destdir="$4" chrootname="$5"
  adm_log_info "Python runner: pkg=$pkg src=$src"
  adm_time_start_pack "$pkg" "build"
  if [ -f "$src/pyproject.toml" ]; then
    _safe_run "$pkg" bash -lc "cd '$src' && python3 -m pip wheel -w dist ." || adm_log_info "(pkg=$pkg) Wheel build may not be available"
  elif [ -f "$src/setup.py" ]; then
    _safe_run "$pkg" bash -lc "cd '$src' && python3 setup.py build" || return $?
  fi
  adm_time_end_pack "$pkg" "build"

  adm_time_start_pack "$pkg" "install"
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # _adm_chroot_exec "$chrootname" bash -lc "cd '$src' && python3 -m pip install --no-deps --prefix=/usr --root='$destdir' ."
    _adm_chroot_exec "$chrootname" bash -lc "echo '[SIM] python3 -m pip install --no-deps --prefix=/usr --root=$destdir .'" || return $?
  else
    adm_log_info "[SIMULATION] Would run inside chroot: python3 -m pip install --no-deps --prefix=/usr --root=$destdir ."
  fi
  adm_time_end_pack "$pkg" "install"
  return 0
}

_adm_build_cargo() {
  local pkg="$1" src="$2" pkgdir="$3" destdir="$4" chrootname="$5"
  adm_log_info "Cargo runner: pkg=$pkg src=$src"
  adm_time_start_pack "$pkg" "build"
  _safe_run "$pkg" bash -lc "cd '$src' && cargo build --release" || return $?
  adm_time_end_pack "$pkg" "build"

  # Install: copy binaries from target/release to destdir/usr/bin inside chroot
  adm_time_start_pack "$pkg" "install"
  if [ -d "$src/target/release" ]; then
    if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
      # UNCOMMENT FOR REAL EXECUTION (in chroot only):
      # _adm_chroot_exec "$chrootname" bash -lc "mkdir -p '$destdir/usr/bin' && cp -a '$src/target/release/'* '$destdir/usr/bin/' || true"
      _adm_chroot_exec "$chrootname" bash -lc "echo '[SIM] cp -a $src/target/release/* -> $destdir/usr/bin/'" || return $?
    else
      adm_log_info "[SIMULATION] Would copy target/release/* to $destdir/usr/bin inside chroot"
    fi
  else
    adm_log_info "No target/release directory found; cargo may have built libraries only."
  fi
  adm_time_end_pack "$pkg" "install"
  return 0
}

_adm_build_go() {
  local pkg="$1" src="$2" pkgdir="$3" destdir="$4" chrootname="$5"
  adm_log_info "Go runner: pkg=$pkg src=$src"
  adm_time_start_pack "$pkg" "build"
  _safe_run "$pkg" bash -lc "cd '$src' && go build ./..." || true
  adm_time_end_pack "$pkg" "build"

  adm_time_start_pack "$pkg" "install"
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # _adm_chroot_exec "$chrootname" bash -lc "mkdir -p '$destdir/usr/bin' && find "$src" -maxdepth 1 -type f -executable -exec cp {} "$destdir/usr/bin/" \; 2>/dev/null || true"
    _adm_chroot_exec "$chrootname" bash -lc "echo '[SIM] find "$src" -maxdepth 1 -type f -executable -exec cp {} "$destdir/usr/bin/" \;'" || return $?
  else
    adm_log_info "[SIMULATION] Would copy Go binaries to $destdir/usr/bin inside chroot"
  fi
  adm_time_end_pack "$pkg" "install"
  return 0
}

_adm_build_node() {
  local pkg="$1" src="$2" pkgdir="$3" destdir="$4" chrootname="$5"
  adm_log_info "Node runner: pkg=$pkg src=$src"
  adm_time_start_pack "$pkg" "install_deps"
  _safe_run "$pkg" bash -lc "cd '$src' && npm ci" || return $?
  adm_time_end_pack "$pkg" "install_deps"

  adm_time_start_pack "$pkg" "build"
  if grep -q '"build"' "$src/package.json" 2>/dev/null; then
    _safe_run "$pkg" bash -lc "cd '$src' && npm run build" || return $?
  fi
  adm_time_end_pack "$pkg" "build"

  adm_time_start_pack "$pkg" "install"
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # _adm_chroot_exec "$chrootname" bash -lc "mkdir -p '$destdir/usr/share/$pkg' && cp -a '$src/dist'/* '$destdir/usr/share/$pkg/' || true"
    _adm_chroot_exec "$chrootname" bash -lc "echo '[SIM] cp -a $src/dist/* -> $destdir/usr/share/$pkg/'" || return $?
  else
    adm_log_info "[SIMULATION] Would copy build output from $src/dist to $destdir/usr/share/$pkg in chroot"
  fi
  adm_time_end_pack "$pkg" "install"
  return 0
}

_adm_build_make() {
  local pkg="$1" src="$2" pkgdir="$3" destdir="$4" chrootname="$5"
  adm_log_info "Make runner: pkg=$pkg src=$src"
  adm_time_start_pack "$pkg" "build"
  _safe_run "$pkg" bash -lc "cd '$src' && make -j${ADM_JOBS}" || return $?
  adm_time_end_pack "$pkg" "build"

  adm_time_start_pack "$pkg" "install"
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # _adm_chroot_exec "$chrootname" bash -lc "cd '$src' && make DESTDIR='$destdir' install"
    _adm_chroot_exec "$chrootname" bash -lc "echo '[SIM] make DESTDIR=$destdir install'" || return $?
  else
    adm_log_info "[SIMULATION] Would run make DESTDIR=$destdir install inside chroot"
  fi
  adm_time_end_pack "$pkg" "install"
  return 0
}

_adm_build_script() {
  local pkg="$1" src="$2" pkgdir="$3" destdir="$4" chrootname="$5"
  adm_log_info "Script runner: pkg=$pkg src=$src"
  local script="$src/build.sh"
  if [ -x "$script" ]; then
    adm_time_start_pack "$pkg" "script"
    _safe_run "$pkg" bash -lc "cd '$src' && ./build.sh '$destdir'" || return $?
    adm_time_end_pack "$pkg" "script"
  else
    adm_log_error "Custom build script not found or not executable: $script"
    return 1
  fi
  return 0
}

_adm_build_unknown() {
  local pkg="$1" src="$2" pkgdir="$3" destdir="$4" chrootname="$5"
  adm_log_info "Unknown build system: performing data-only install for pkg=$pkg"
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # _adm_chroot_exec "$chrootname" bash -lc "mkdir -p '$destdir/usr/share/$pkg' && cp -a '$src'/* '$destdir/usr/share/$pkg/'"
    _adm_chroot_exec "$chrootname" bash -lc "echo '[SIM] cp -a $src/* -> $destdir/usr/share/$pkg/'" || return $?
  else
    adm_log_info "[SIMULATION] Would copy $src to $destdir/usr/share/$pkg inside chroot"
  fi
  return 0
}

# -------------------------
# Dispatch to correct runner
# -------------------------
_adm_dispatch_build() {
  local pkg="$1" src="$2" pkgdir="$3" destdir="$4" chrootname="$5"
  local bs
  bs=$(_adm_detect_build_system "$src")
  adm_log_info "Dispatching build system: $bs"
  case "$bs" in
    meson) _adm_build_meson "$pkg" "$src" "$pkgdir" "$destdir" "$chrootname" ;;
    cmake) _adm_build_cmake "$pkg" "$src" "$pkgdir" "$destdir" "$chrootname" ;;
    cargo) _adm_build_cargo "$pkg" "$src" "$pkgdir" "$destdir" "$chrootname" ;;
    python) _adm_build_python "$pkg" "$src" "$pkgdir" "$destdir" "$chrootname" ;;
    autotools) _adm_build_autotools "$pkg" "$src" "$pkgdir" "$destdir" "$chrootname" ;;
    go) _adm_build_go "$pkg" "$src" "$pkgdir" "$destdir" "$chrootname" ;;
    node) _adm_build_node "$pkg" "$src" "$pkgdir" "$destdir" "$chrootname" ;;
    make) _adm_build_make "$pkg" "$src" "$pkgdir" "$destdir" "$chrootname" ;;
    script) _adm_build_script "$pkg" "$src" "$pkgdir" "$destdir" "$chrootname" ;;
    unknown) _adm_build_unknown "$pkg" "$src" "$pkgdir" "$destdir" "$chrootname" ;;
    *) adm_log_error "Unsupported build system: $bs"; return 1 ;;
  esac
}

# -------------------------
# Dependency resolution (cache + source inference + recursive build)
# Ensures build_deps are available via cache or builds them from metafiles.
# -------------------------
_adm_resolve_and_ensure_deps() {
  local pkgname="$1" metafile="$2" chrootname="$3" out_array_name="$4"
  local -n _out="$out_array_name"
  _out=()

  # read explicit deps (metafile)
  local -a meta_build meta_run
  _adm_read_metafile_deps "$metafile" meta_build meta_run || true

  # try to get source (via adm_meta_get if available)
  local srcurl=""
  if declare -f adm_meta_get >/dev/null 2>&1; then
    srcurl=$(adm_meta_get source 2>/dev/null || true)
  fi

  # download source to temp if possible, to infer deps
  local cached_src_dir=""
  if [ -n "$srcurl" ] && declare -f adm_cache_download >/dev/null 2>&1; then
    if [ "$ADM_DRY_RUN" = "1" ]; then
      adm_log_info "[DRY-RUN] Would download source $srcurl for inference"
    else
      local arc
      arc=$(adm_cache_download "$srcurl" "$(adm_meta_get sha256 2>/dev/null || echo '')" 2>/dev/null || true)
      if [ -n "$arc" ]; then
        # extract into tmp dir for inspection
        cached_src_dir=$(_adm_mktemp_dir)
        if file "$arc" | grep -qi 'tar archive'; then
          tar -C "$cached_src_dir" -xf "$arc" --strip-components=1 2>/dev/null || true
        else
          adm_log_debug "Downloaded source is not a tar archive; skipping extract"
        fi
      fi
    fi
  fi

  # inferred deps from source
  local -a inferred=()
  if [ -n "$cached_src_dir" ] && [ -d "$cached_src_dir" ]; then
    mapfile -t inferred < <(_adm_infer_deps_from_source "$cached_src_dir" 2>/dev/null || true)
  fi

  # merge unique names (meta_build + inferred)
  declare -A uniq
  local d
  for d in "${meta_build[@]}" "${inferred[@]}"; do
    d="$(echo "$d" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [ -z "$d" ] && continue
    uniq["$d"]=1
  done

  # for each dep, try cache then try build via metafile
  for d in "${!uniq[@]}"; do
    _out+=("$d")
    adm_log_info "Resolving dependency: $d"
    _adm_cache_index_load
    local entry
    entry=$(_adm_cache_find "$d" || true)
    local path=""
    if [ -n "$entry" ]; then
      path=$(_adm_cache_verify_and_get_path "$entry" || true)
    fi
    if [ -n "$path" ]; then
      adm_log_info "Dependency $d satisfied by cached binary: $path"
      # optional: offer auto-install into chroot (not performed unless ADM_ALLOW_EXECUTION=1)
      if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
        adm_log_info "Optionally installing cached binary into chroot (not automatic by default)"
        # Implementation note: To auto-install, you would extract the tar into the chroot's filesystem.
        # UNCOMMENT FOR REAL EXECUTION (in chroot only):
        # _adm_chroot_exec "$chrootname" bash -lc "tar -C / -x --strip-components=0 -f '$path'"
      else
        adm_log_info "[SIMULATION] Would install cached package $path into chroot $chrootname"
      fi
      continue
    fi

    # not in cache -> find metafile and build
    local dep_meta=""
    if declare -f find_metafile_by_name >/dev/null 2>&1; then
      dep_meta=$(find_metafile_by_name "$d" 2>/dev/null || true)
    fi
    if [ -n "$dep_meta" ]; then
      adm_log_info "Found metafile for dep $d: $dep_meta -> building recursively"
      if [ "$ADM_DRY_RUN" = "1" ]; then
        adm_log_info "[DRY-RUN] Would call adm-build on $dep_meta"
      else
        # call adm-build recursively as a separate process to avoid state bleeding
        "$ADM_BIN_DIR/adm-build" "$dep_meta" --chroot "$chrootname" --profile "$ADM_PROFILE" --jobs "$ADM_JOBS" || {
          adm_log_error "Recursive build failed for dependency $d"
          return 1
        }
      fi
    else
      adm_log_error "Dependency $d not found in cache and no metafile located. Manual intervention required."
    fi
  done

  # cleanup downloaded source temp
  if [ -n "$cached_src_dir" ] && [ -d "$cached_src_dir" ]; then
    rm -rf "$cached_src_dir" 2>/dev/null || true
  fi

  return 0
}

# End of Part 2/3
# -------------------------
# adm-build - Part 3/3
# Orchestration, packaging, summary, and CLI entrypoint
# -------------------------

# -------------------------
# Packaging and manifest utilities
# -------------------------
_adm_package_install_tree() {
  local pkg="$1" version="$2" destdir="$3" arch="$(_adm_arch)"
  local outdir="$ADM_CACHE_BIN"
  mkdir -p "$outdir" 2>/dev/null || true
  local outfile="$outdir/${pkg}-${version}-${arch}.tar.zst"
  adm_log_info "Packaging $pkg -> $outfile"
  local t0=$(date +%s)
  if command -v zstd >/dev/null 2>&1; then
    tar -C "$destdir" -cf - . | zstd -19 -T0 -o "$outfile" || {
      adm_log_error "zstd packaging failed; trying xz fallback"
      tar -C "$destdir" -cJf "${outfile%.zst}.tar.xz" .
      outfile="${outfile%.zst}.tar.xz"
    }
  else
    tar -C "$destdir" -cJf "${outfile%.zst}.tar.xz" .
    outfile="${outfile%.zst}.tar.xz"
  fi
  local t1=$(date +%s)
  local diff=$((t1 - t0))
  local sha=""
  if command -v sha256sum >/dev/null 2>&1; then
    sha=$(sha256sum "$outfile" | awk '{print $1}')
  fi
  _adm_cache_index_load
  _adm_cache_index_add "$pkg" "$version" "$arch" "$outfile" "$sha"
  adm_log_correct "Packaged $pkg in $diff seconds -> $outfile"
  echo "$outfile"
}

_adm_write_manifest() {
  local pkg="$1" version="$2" destdir="$3"
  local manfile="$ADM_MANIFEST_DIR/${pkg}.manifest"
  adm_log_info "Writing manifest: $manfile"
  find "$destdir" -type f | sort > "$manfile" 2>/dev/null || true
  echo "pkg=$pkg" >> "$manfile"
  echo "version=$version" >> "$manfile"
  echo "built_at=$(date -Iseconds)" >> "$manfile"
  echo "profile=$ADM_PROFILE" >> "$manfile"
  echo "arch=$(_adm_arch)" >> "$manfile"
  return 0
}

# -------------------------
# Main build orchestration
# -------------------------
adm_build_package() {
  local metafile="$1"; shift
  local chrootname="$ADM_CHROOT"
  local pkg name version srcurl sha desc
  local workdir destdir srcdir builddir
  local arch="$(_adm_arch)"

  [ -f "$metafile" ] || { adm_log_error "Metafile not found: $metafile"; return 1; }

  adm_log_info "==== ADM BUILD START ===="
  adm_log_info "Metafile: $metafile"

  # parse metadata
  name=$(grep -E '^name:' "$metafile" | awk '{print $2}' | tr -d '[:space:]')
  version=$(grep -E '^version:' "$metafile" | awk '{print $2}' | tr -d '[:space:]')
  srcurl=$(grep -E '^source:' "$metafile" | awk '{print $2}' | tr -d '[:space:]')
  sha=$(grep -E '^sha256:' "$metafile" | awk '{print $2}' | tr -d '[:space:]')
  desc=$(grep -E '^desc:' "$metafile" | cut -d':' -f2- | sed 's/^ *//')
  pkg="${name:-$(basename "$metafile")}"

  [ -z "$pkg" ] && { adm_log_error "Failed to determine package name."; return 1; }

  adm_log_info "Building package: $pkg version $version ($arch)"
  adm_log_info "Description: $desc"

  # ensure chroot
  _adm_require_chroot "$chrootname" || return $?

  # detect compilers
  _adm_detect_compilers

  # resolve dependencies
  local -a deps=()
  _adm_resolve_and_ensure_deps "$pkg" "$metafile" "$chrootname" deps || {
    adm_log_error "Dependency resolution failed for $pkg"
    return 1
  }

  # prepare dirs
  workdir="$ADM_WORKDIR/$pkg-$version"
  destdir="$workdir/destdir"
  srcdir="$workdir/source"
  mkdir -p "$destdir" "$srcdir" 2>/dev/null || true

  # download and extract source
  adm_log_info "Fetching source from $srcurl"
  local arc=""
  if [ -n "$srcurl" ] && declare -f adm_cache_download >/dev/null 2>&1; then
    arc=$(adm_cache_download "$srcurl" "$sha" 2>/dev/null || true)
  fi
  if [ -z "$arc" ]; then
    adm_log_error "Failed to obtain source for $pkg"
    return 1
  fi
  adm_log_info "Extracting source to $srcdir"
  if [ "$ADM_DRY_RUN" = "1" ]; then
    adm_log_info "[DRY-RUN] Would extract $arc to $srcdir"
  else
    tar -C "$srcdir" -xf "$arc" --strip-components=1 || true
  fi

  # apply patches if available
  if [ -x "$ADM_BIN_DIR/adm-patches" ]; then
    adm_log_info "Applying patches (if any)"
    "$ADM_BIN_DIR/adm-patches" apply "$pkg" "$srcdir" || true
  fi

  # pre-build hook
  if [ -x "$ADM_BIN_DIR/adm-hooks" ]; then
    "$ADM_BIN_DIR/adm-hooks" run prebuild "$pkg" "$srcdir" "$destdir" || true
  fi

  # build proper
  adm_log_info "Starting compilation of $pkg"
  local t0=$(date +%s)
  _adm_dispatch_build "$pkg" "$srcdir" "$workdir" "$destdir" "$chrootname" || {
    adm_log_error "Build failed for $pkg"
    return 1
  }
  local t1=$(date +%s)
  local total=$((t1 - t0))
  local total_hms
  total_hms=$(printf "%02d:%02d:%02d" $((total/3600)) $(((total%3600)/60)) $((total%60)))
  adm_log_correct "Build completed for $pkg in $total_hms"

  # post-build hook
  if [ -x "$ADM_BIN_DIR/adm-hooks" ]; then
    "$ADM_BIN_DIR/adm-hooks" run postbuild "$pkg" "$srcdir" "$destdir" || true
  fi

  # manifest and package
  _adm_write_manifest "$pkg" "$version" "$destdir"
  local packagefile=""
  packagefile=$(_adm_package_install_tree "$pkg" "$version" "$destdir")
  adm_log_correct "Binary package ready: $packagefile"

  _adm_summary_add "$pkg" "build_total" "$total_hms" "OK"

  adm_log_correct "==== ADM BUILD FINISHED: $pkg ===="
  echo "Package: $pkg"
  echo "Version: $version"
  echo "Cache: $packagefile"
  echo "Build time: $total_hms"
  echo "Arch: $arch"
  return 0
}

# -------------------------
# CLI / main entrypoint
# -------------------------
_adm_show_help() {
  cat <<EOF
Usage: adm-build <metafile> [options]

Options:
  --chroot <name>     : specify chroot environment name (required)
  --profile <name>    : use compilation profile (default: normal)
  --jobs <n>          : number of parallel jobs (default: auto)
  --dry-run           : simulate all operations without executing
  --force             : ignore certain errors
  --detailed          : show detailed time summary per step
  --allow-exec        : allow real system modification (dangerous; only in chroot)
  --help              : show this help
EOF
}

_adm_parse_args() {
  local args=()
  while [ $# -gt 0 ]; do
    case "$1" in
      --chroot) ADM_CHROOT="$2"; shift 2 ;;
      --profile) ADM_PROFILE="$2"; shift 2 ;;
      --jobs) ADM_JOBS="$2"; shift 2 ;;
      --dry-run) ADM_DRY_RUN=1; shift ;;
      --force) ADM_FORCE=1; shift ;;
      --detailed) ADM_DETAILED=1; shift ;;
      --allow-exec) ADM_ALLOW_EXECUTION=1; shift ;;
      --help) _adm_show_help; exit 0 ;;
      --*) adm_log_error "Unknown option: $1"; _adm_show_help; exit 1 ;;
      *) args+=("$1"); shift ;;
    esac
  done
  if [ "${#args[@]}" -eq 0 ]; then
    _adm_show_help; exit 1
  fi
  echo "${args[0]}"
}

# -------------------------
# Program entry
# -------------------------
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  metafile=$(_adm_parse_args "$@")
  if [ ! -f "$metafile" ]; then
    adm_log_error "Metafile not found: $metafile"
    exit 1
  fi
  adm_build_package "$metafile"
  adm_log_correct "Build process complete."
fi

# End of Part 3/3
# ==========================================================
#  adm-build (final version)
# ==========================================================
