#!/usr/bin/env bash
# ================================================================
# adm-run v1.0
# Orquestrador De Programas: instala pacotes (fetch->extract->build->install),
# suporta múltiplas sources.list, resolve dependências, TUI, search/info.
# Produzido para integração com adm-fetch/adm-extract/admbuild/adminstall
# ================================================================

set -euo pipefail
IFS=$'\n\t'

# -------------------------
# CONFIGURAÇÃO PADRÃO
# -------------------------
ADM_ROOT=${ADM_ROOT:-/usr/src/adm}
CFG_DIR="$ADM_ROOT/cfg"
SOURCES_DIR="$CFG_DIR/sources.d"
DEFAULT_SOURCES="$CFG_DIR/sources.list"
MERGE_TMP_DIR="${ADM_ROOT}/tmp"
MERGED_SOURCES_FILE="${MERGE_TMP_DIR}/merged.sources.list"
BUILD_DIR="$ADM_ROOT/build"
SRC_DIR="$ADM_ROOT/src"
LOG_DIR="$ADM_ROOT/logs"
HOOK_DIR="$ADM_ROOT/hooks"

# Called scripts (must be executable or adm-run will warn and attempt fallback)
ADM_FETCH="${ADM_FETCH:-$ADM_ROOT/scripts/adm-fetch}"
ADM_EXTRACT="${ADM_EXTRACT:-$ADM_ROOT/scripts/adm-extract}"
ADM_BUILD="${ADM_BUILD:-$ADM_ROOT/scripts/adm-build}"
ADM_INSTALL="${ADM_INSTALL:-$ADM_ROOT/scripts/adm-install}"
ADM_UNINSTALL="${ADM_UNINSTALL:-$ADM_ROOT/scripts/adm-uninstall}"

# defaults
DELIM="${DELIM:-|}"
JOBS=${JOBS:-$(nproc || echo 1)}
PROFILE=${PROFILE:-standard}

# Retry/backoff
RETRY_COUNT=2
RETRY_DELAY=3

# create dirs
mkdir -p "$MERGE_TMP_DIR" "$BUILD_DIR" "$LOG_DIR" "$SRC_DIR" "$HOOK_DIR" "$CFG_DIR"

# -------------------------
# CORES / FORMATAÇÃO
# -------------------------
CLR_RESET='\e[0m'
CLR_MAGENTA='\e[95m'
CLR_GREEN='\e[92m'
CLR_CYAN='\e[96m'
CLR_YELLOW='\e[93m'
CLR_RED='\e[91m'

timestamp(){ date '+%Y-%m-%d %H:%M:%S'; }

# short terminal lines (consistent with other scripts)
headline(){ printf "%b%s%b %b=>%b %s\n" "$CLR_CYAN" "$(timestamp)" "$CLR_RESET" "$CLR_MAGENTA" "$CLR_RESET" "$1"; }
short_ok(){ printf "%b[✔]%b %s\n" "$CLR_GREEN" "$CLR_RESET" "$1"; }
short_warn(){ printf "%b[!]%b %s\n" "$CLR_YELLOW" "$CLR_RESET" "$1"; }
short_err(){ printf "%b[✖]%b %s\n" "$CLR_RED" "$CLR_RESET" "$1"; }

# -------------------------
# LOGGING
# -------------------------
ADM_RUN_LOG="$LOG_DIR/adm-run.log"
: > "$ADM_RUN_LOG"

log() { printf "%s %s\n" "$(timestamp)" "$*" >>"$ADM_RUN_LOG"; }
log_pkg() { local pkg="$1"; shift; printf "%s %s\n" "$(timestamp)" "$*" >>"$LOG_DIR/${pkg}.run.log"; }

# -------------------------
# SANITY CHECKS
# -------------------------
require_executable_or_warn() {
    local path="$1" name="$2"
    if [[ ! -x "$path" ]]; then
        short_warn "$name not found or not executable at $path. Some operations will fail if required."
        log "WARN: $name not executable: $path"
        return 1
    fi
    return 0
}

require_executable_or_warn "$ADM_FETCH" "adm-fetch"
require_executable_or_warn "$ADM_EXTRACT" "adm-extract"
# ADM_BUILD and ADM_INSTALL may be provided later
if [[ ! -x "$ADM_BUILD" ]]; then
    short_warn "adm-build not found/executable at $ADM_BUILD (build steps may fail)."
    log "WARN: adm-build missing $ADM_BUILD"
fi
if [[ ! -x "$ADM_INSTALL" ]]; then
    short_warn "adm-install not found/executable at $ADM_INSTALL (install steps may fail)."
    log "WARN: adm-install missing $ADM_INSTALL"
fi

# -------------------------
# TRAPS and cleanup
# -------------------------
cleanup_and_exit() {
    local code=${1:-0}
    # keep merged file for debugging unless code==0? we keep it but log
    if [[ -f "$MERGED_SOURCES_FILE" ]]; then
        log "Merged sources kept at $MERGED_SOURCES_FILE"
    fi
    exit "$code"
}
trap 'cleanup_and_exit $?' EXIT INT TERM

# -------------------------
# SOURCES LISTS LOADING & MERGING
# Supports:
#  - --sources file1 file2 ...
#  - automatic reading of DEFAULT_SOURCES and all files in SOURCES_DIR/*.list
#  - when duplicate pkg ids found, last wins (order: DEFAULT_SOURCES then files in SOURCES_DIR sorted, then explicit --sources which override)
# -------------------------

# internal associative arrays for package metadata
declare -A PKG_VERSION PKG_URL PKG_SHA PKG_DEPS PKG_TYPE PKG_SOURCE_FILE

# parse a single line into associative arrays
parse_sources_line_into_maps() {
    local file="$1"
    local lineno="$2"
    local line="$3"
    # trim CR and BOM
    line="${line//$'\r'/}"
    line="${line//$'\xef\xbb\xbf'/}"
    # ignore comments and blank
    [[ -z "${line//[[:space:]]/}" ]] && return 0
    [[ "${line//[[:space:]]/}" == \#* ]] && return 0
    IFS="$DELIM" read -r pkg ver url sha deps typ <<<"$line" || return 0
    pkg=$(echo "$pkg" | xargs)
    [[ -z "$pkg" ]] && return 0
    # store; later entries override earlier ones
    PKG_VERSION["$pkg"]="${ver:-}"
    PKG_URL["$pkg"]="${url:-}"
    PKG_SHA["$pkg"]="${sha:-}"
    PKG_DEPS["$pkg"]="${deps:-}"
    PKG_TYPE["$pkg"]="${typ:-}"
    PKG_SOURCE_FILE["$pkg"]="$file:$lineno"
}

# load a list file
load_sources_file() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        log "WARN: sources file not found: $file"
        return 1
    fi
    local ln=0
    while IFS= read -r line || [[ -n "$line" ]]; do
        ln=$((ln+1))
        parse_sources_line_into_maps "$file" "$ln" "$line"
    done < "$file"
    return 0
}

# merge multiple sources in order. args are filenames in precedence order (earlier lower priority)
merge_sources_files() {
    # $@ order: system defaults (lowest) ... user-provided (highest)
    : > "$MERGED_SOURCES_FILE"
    for f in "$@"; do
        [[ -f "$f" ]] || continue
        # append to merged file but remove duplicates by pkg id? We'll append and allow override by reloading maps
        cat "$f" >> "$MERGED_SOURCES_FILE"
    done
    # clear maps and reload from merged file to ensure last wins when duplicate pkg ids are present
    PKG_VERSION=()
    PKG_URL=()
    PKG_SHA=()
    PKG_DEPS=()
    PKG_TYPE=()
    PKG_SOURCE_FILE=()
    load_sources_file "$MERGED_SOURCES_FILE"
    log "Merged ${#PKG_URL[@]} packages into $MERGED_SOURCES_FILE"
}

# build list of source files to merge (defaults + sources.d + explicit files)
build_sources_list_to_merge() {
    local explicit=("$@")
    local files=()
    # default base
    if [[ -f "$DEFAULT_SOURCES" ]]; then
        files+=("$DEFAULT_SOURCES")
    fi
    # all files in sources.d sorted
    if [[ -d "$SOURCES_DIR" ]]; then
        while IFS= read -r f; do files+=("$f"); done < <(find "$SOURCES_DIR" -maxdepth 1 -type f -name '*.list' | sort)
    fi
    # then explicit ones (highest priority)
    for ef in "${explicit[@]}"; do
        [[ -f "$ef" ]] && files+=("$ef")
    done
    # remove duplicates while preserving order (later entries override content by reload logic)
    local seen=()
    local out=()
    for p in "${files[@]}"; do
        if [[ -z "${seen[$p]:-}" ]]; then
            out+=("$p")
            seen["$p"]=1
        fi
    done
    echo "${out[@]}"
}

# helper to print packages count
print_loaded_packages_summary() {
    local count=${#PKG_URL[@]}
    headline "Loaded $count packages from merged sources"
}

# -------------------------
# USAGE parsing (partial, more in Part 2/3)
# -------------------------
# We'll parse CLI and accept: --sources file1 file2, --tui, --install pkg..., --remove, --rebuild, --deps, --dry-run, --continue
# For now set defaults and allow to fill arrays
REQUEST_INSTALL=()
REQUEST_REMOVE=()
REQUEST_REBUILD=()
REQUEST_DEPS=()
OPT_TUI=0
OPT_DRYRUN=0
OPT_CONTINUE=0
OPT_NO_FETCH=0
OPT_NO_BUILD=0
OPT_NO_INSTALL=0
OPT_SOURCES=()

# parse basic args (we'll refine in Part 2/3 for full help)
while [[ $# -gt 0 ]]; do
    case "$1" in
        --sources) shift; while [[ $# -gt 0 && "$1" != --* ]]; do OPT_SOURCES+=("$1"); shift; done ;;
        --tui) OPT_TUI=1; shift ;;
        --install) shift; while [[ $# -gt 0 && "$1" != --* ]]; do REQUEST_INSTALL+=("$1"); shift; done ;;
        --remove) shift; while [[ $# -gt 0 && "$1" != --* ]]; do REQUEST_REMOVE+=("$1"); shift; done ;;
        --rebuild) shift; while [[ $# -gt 0 && "$1" != --* ]]; do REQUEST_REBUILD+=("$1"); shift; done ;;
        --deps) shift; while [[ $# -gt 0 && "$1" != --* ]]; do REQUEST_DEPS+=("$1"); shift; done ;;
        --continue) OPT_CONTINUE=1; shift ;;
        --dry-run) OPT_DRYRUN=1; shift ;;
        --no-fetch) OPT_NO_FETCH=1; shift ;;
        --no-build) OPT_NO_BUILD=1; shift ;;
        --no-install) OPT_NO_INSTALL=1; shift ;;
        --opt-profile) PROFILE="${2:-$PROFILE}"; shift 2 ;;
        --jobs) JOBS="${2:-$JOBS}"; shift 2 ;;
        -h|--help) # we'll print help in Part 3/3
            HELP_WANTED=1; shift ;;
        *) # ambiguous: treat bare .list path as install-list or package names (collected later)
            # store into REQUEST_INSTALL for now
            REQUEST_INSTALL+=("$1"); shift ;;
    esac
done

# At this point, we will build the list of source files to merge:
SOURCES_TO_MERGE=()
# get defaults and sources.d first
mapfile -t default_merged_list < <(build_sources_list_to_merge "${OPT_SOURCES[@]}")
# build_sources_list_to_merge echoes files; capture them into array
SOURCES_TO_MERGE=("${default_merged_list[@]}")
# if explicit OPT_SOURCES provided, ensure they are appended in precedence
if ((${#OPT_SOURCES[@]})); then
    for x in "${OPT_SOURCES[@]}"; do
        if [[ -f "$x" ]]; then
            # override priority by putting at end (highest priority)
            SOURCES_TO_MERGE+=("$x")
        else
            short_warn "Explicit sources file not found: $x"
            log "WARN: explicit sources file not found: $x"
        fi
    done
fi

if ((${#SOURCES_TO_MERGE[@]} == 0)); then
    short_err "No sources files found. Create $DEFAULT_SOURCES or put files in $SOURCES_DIR or pass --sources"
    exit 1
fi

merge_sources_files "${SOURCES_TO_MERGE[@]}"
print_loaded_packages_summary()

# -------------------------
# STATE MANAGEMENT
# -------------------------
pkg_state_file() { echo "$BUILD_DIR/$1/.state"; }
pkg_set_state() {
    local pkg="$1" state="$2"
    mkdir -p "$BUILD_DIR/$pkg"
    echo "$state" > "$(pkg_state_file "$pkg")"
    log_pkg "$pkg" "STATE -> $state"
}
pkg_get_state() {
    local pkg="$1"
    local f; f="$(pkg_state_file "$pkg")"
    [[ -f "$f" ]] && cat "$f" || echo "NONE"
}
pkg_is_installed() {
    [[ "$(pkg_get_state "$1")" == "INSTALLED" ]]
}
pkg_has_failed() {
    [[ "$(pkg_get_state "$1")" == "FAILED" ]]
}

# -------------------------
# DEPENDENCY RESOLUTION
# -------------------------
resolve_dependencies_recursive() {
    local pkg="$1"
    local -n out_ref="$2"
    local -A seen
    local -A visiting

    _resolve() {
        local p="$1"
        # detect unknown package
        if [[ -z "${PKG_URL[$p]:-}" ]]; then
            short_warn "Unknown dependency: $p (skipped)"
            log "WARN: dependency $p unknown"
            return
        fi
        # detect cycle
        if [[ -n "${visiting[$p]:-}" ]]; then
            short_err "Dependency cycle detected at $p"
            log "ERROR: cycle detected at $p"
            return 1
        fi
        if [[ -n "${seen[$p]:-}" ]]; then
            return
        fi
        visiting["$p"]=1
        # split deps by comma
        local deps="${PKG_DEPS[$p]:-}"
        IFS=',' read -r -a arr <<<"${deps// /}"
        for d in "${arr[@]}"; do
            [[ -z "$d" ]] && continue
            _resolve "$d" || return 1
        done
        visiting["$p"]=""
        seen["$p"]=1
        out_ref+=("$p")
    }

    _resolve "$pkg"
}

# -------------------------
# SPINNER (lightweight)
# -------------------------
__frames=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
__sp_pid=""
start_spinner(){
    local msg="${1:-Working...}"
    printf "%b%s%b %b=>%b %s\n" "$CLR_CYAN" "$(timestamp)" "$CLR_RESET" "$CLR_MAGENTA" "$CLR_RESET" "$msg"
    (
        i=0
        while :; do
            printf "\r%b %s %b %s" "$CLR_GREEN" "${__frames[i % ${#__frames[@]}]}" "$CLR_RESET" "$msg"
            i=$((i+1))
            sleep 0.12
        done
    ) &
    __sp_pid=$!
}
stop_spinner(){
    local code=${1:-0} msg="${2:-Done}"
    if [[ -n "$__sp_pid" ]]; then
        kill "$__sp_pid" >/dev/null 2>&1 || true
        wait "$__sp_pid" 2>/dev/null || true
        __sp_pid=""
    fi
    if [[ "$code" -eq 0 ]]; then
        printf "\r%b[✔]%b %s\n" "$CLR_GREEN" "$CLR_RESET" "$msg"
    else
        printf "\r%b[✖]%b %s\n" "$CLR_RED" "$CLR_RESET" "$msg"
    fi
}

# -------------------------
# PIPELINE EXECUTION
# -------------------------
run_step() {
    local step="$1" pkg="$2"
    local tool log_out log_err
    tool=""
    case "$step" in
        fetch) tool="$ADM_FETCH" ;;
        extract) tool="$ADM_EXTRACT" ;;
        build) tool="$ADM_BUILD" ;;
        install) tool="$ADM_INSTALL" ;;
        *) short_err "Invalid step: $step"; return 1 ;;
    esac

    log_out="$LOG_DIR/${pkg}.${step}.out"
    log_err="$LOG_DIR/${pkg}.${step}.err"
    : >"$log_out"
    : >"$log_err"

    if [[ ! -x "$tool" ]]; then
        short_err "Step $step skipped, missing tool $tool"
        log_pkg "$pkg" "ERROR: missing tool $tool"
        return 1
    fi

    start_spinner "$step → $pkg"
    if "$tool" "$pkg" >>"$log_out" 2>>"$log_err"; then
        stop_spinner 0 "$step OK: $pkg"
        pkg_set_state "$pkg" "$(echo "$step" | tr '[:lower:]' '[:upper:]')ED"
        return 0
    else
        stop_spinner 1 "$step failed: $pkg"
        pkg_set_state "$pkg" "FAILED"
        log_pkg "$pkg" "FAILED at $step"
        [[ "$OPT_CONTINUE" -eq 1 ]] && return 0
        return 1
    fi
}

run_pipeline_for_package() {
    local pkg="$1"
    local state
    state=$(pkg_get_state "$pkg")
    log_pkg "$pkg" "Starting pipeline (current state: $state)"
    short_info "→ Processing $pkg ($state)"

    # fetch
    if [[ "$OPT_NO_FETCH" -eq 0 ]]; then
        if ! run_step fetch "$pkg"; then return 1; fi
    fi

    # extract
    if [[ "$OPT_NO_BUILD" -eq 0 ]]; then
        if ! run_step extract "$pkg"; then return 1; fi
    fi

    # build
    if [[ "$OPT_NO_BUILD" -eq 0 ]]; then
        if ! run_step build "$pkg"; then return 1; fi
    fi

    # install
    if [[ "$OPT_NO_INSTALL" -eq 0 ]]; then
        if ! run_step install "$pkg"; then return 1; fi
    fi

    pkg_set_state "$pkg" "INSTALLED"
    short_ok "$pkg installed successfully"
    return 0
}

# -------------------------
# SEARCH & INFO UTILITIES
# -------------------------
search_package() {
    local term="$1"
    printf "%bSearch:%b '%s'\n" "$CLR_CYAN" "$CLR_RESET" "$term"
    for pkg in "${!PKG_URL[@]}"; do
        if [[ "$pkg" =~ $term ]]; then
            printf "%b%-20s%b %s\n" "$CLR_GREEN" "$pkg" "$CLR_RESET" "${PKG_URL[$pkg]}"
        fi
    done
}

info_package() {
    local pkg="$1"
    if [[ -z "${PKG_URL[$pkg]:-}" ]]; then
        short_err "Package not found: $pkg"
        return 1
    fi
    echo -e "${CLR_MAGENTA}Package:${CLR_RESET} $pkg"
    echo -e "${CLR_MAGENTA}Version:${CLR_RESET} ${PKG_VERSION[$pkg]}"
    echo -e "${CLR_MAGENTA}URL:${CLR_RESET} ${PKG_URL[$pkg]}"
    echo -e "${CLR_MAGENTA}SHA256:${CLR_RESET} ${PKG_SHA[$pkg]}"
    echo -e "${CLR_MAGENTA}Dependencies:${CLR_RESET} ${PKG_DEPS[$pkg]}"
    echo -e "${CLR_MAGENTA}Type:${CLR_RESET} ${PKG_TYPE[$pkg]}"
    echo -e "${CLR_MAGENTA}State:${CLR_RESET} $(pkg_get_state "$pkg")"
    echo -e "${CLR_MAGENTA}Defined in:${CLR_RESET} ${PKG_SOURCE_FILE[$pkg]}"
}

# -------------------------
# BUILD PACKAGE EXECUTION ORDER
# -------------------------
build_install_order() {
    local -a pkgs=("$@")
    local -a ordered unique
    declare -A seen
    for p in "${pkgs[@]}"; do
        local deps_list=()
        resolve_dependencies_recursive "$p" deps_list || continue
        for d in "${deps_list[@]}"; do
            if [[ -z "${seen[$d]:-}" ]]; then
                ordered+=("$d")
                seen["$d"]=1
            fi
        done
    done
    echo "${ordered[@]}"
}

# -------------------------
# HELP TEXT
# -------------------------
print_help() {
cat <<EOF
adm-run - Orquestrador ADM (fetch -> extract -> build -> install)
Usage: $(basename "$0") [options]

Modes:
  --tui                  Start interactive TUI mode
  --install <pkg|file>.. Install packages by name or a .list file (accepts multiple)
  --remove  <pkg>..      Uninstall package(s)
  --rebuild <pkg>..      Force rebuild of given package(s)
  --deps <pkg>           Show dependency resolution/order for package
  --search <regex>       Search packages by name (regex)
  --info <pkg>           Show package information
  --sources <file>..     Additional sources.list files (higher priority)
  --dry-run              Don't execute external scripts; only show plan
  --continue             Continue on failures (don't abort)
  --no-fetch             Skip fetch step
  --no-build             Skip build step
  --no-install           Skip install step
  --opt-profile <name>   Use optimization profile (standard|conservative|aggressive|custom)
  --jobs <N>             Parallel jobs (passed to builds)
  -h, --help             Show this help

Examples:
  adm-run --install firefox
  adm-run --install /usr/src/adm/cfg/xorg.sources.list
  adm-run --install firefox chromium --sources /usr/src/adm/cfg/extra.list
  adm-run --tui
EOF
}

# -------------------------
# UTIL: refresh PKG maps if we want to re-merge with extra sources (file list)
# merges current merged sources with additional files (appended as highest priority)
# -------------------------
refresh_merged_with_extra() {
    # args: list of extra source files
    local extra=("$@")
    # build base list in same order used earlier: defaults + sources.d
    mapfile -t base_files < <(build_sources_list_to_merge)
    # append extras to end (higher priority)
    for f in "${extra[@]}"; do
        [[ -f "$f" ]] || { short_warn "Extra source not found: $f"; continue; }
        base_files+=("$f")
    done
    merge_sources_files "${base_files[@]}"
    print_loaded_packages_summary
}

# -------------------------
# HANDLERS: INSTALL
# -------------------------
install_from_listfile() {
    local listfile="$1"
    if [[ ! -f "$listfile" ]]; then
        short_err "List file not found: $listfile"
        return 1
    fi
    # re-merge with this listfile as highest priority
    refresh_merged_with_extra "$listfile"
    # read all pkgs from listfile (ignore comments)
    local to_install=()
    while IFS= read -r ln || [[ -n "$ln" ]]; do
        ln="${ln//$'\r'/}"; ln="${ln//$'\xef\xbb\xbf'/}"
        [[ -z "${ln//[[:space:]]/}" ]] && continue
        [[ "${ln//[[:space:]]/}" == \#* ]] && continue
        IFS="$DELIM" read -r pkg ver url sha deps typ <<<"$ln" || continue
        pkg=$(echo "$pkg" | xargs)
        [[ -z "$pkg" ]] && continue
        to_install+=("$pkg")
    done < "$listfile"

    if ((${#to_install[@]} == 0)); then
        short_warn "No packages found in $listfile"
        return 0
    fi

    # compute overall ordered list with deps
    mapfile -t ordered < <(build_install_order "${to_install[@]}")
    short_info "Install order prepared: ${#ordered[@]} packages"
    if [[ "$OPT_DRYRUN" -eq 1 ]]; then
        for p in "${ordered[@]}"; do
            echo "DRYRUN: would install $p (state: $(pkg_get_state "$p"))"
        done
        return 0
    fi

    local failed=0
    for p in "${ordered[@]}"; do
        if pkg_is_installed "$p" && [[ "$OPT_CONTINUE" -eq 0 ]]; then
            short_info "Skipping $p (already INSTALLED)"
            continue
        fi
        if ! run_pipeline_for_package "$p"; then
            short_err "Failed to install $p"
            failed=$((failed+1))
            [[ "$OPT_CONTINUE" -eq 0 ]] && break
        fi
    done

    return $(( failed > 0 ? 1 : 0 ))
}

install_packages() {
    local args=("$@")
    local explicit_sources=()
    local pkg_names=()
    # separate explicit .list files from package names
    for a in "${args[@]}"; do
        if [[ -f "$a" && "$a" == *.list ]]; then
            explicit_sources+=("$a")
        else
            pkg_names+=("$a")
        fi
    done

    # if explicit sources present, re-merge with them (higher priority)
    if ((${#explicit_sources[@]})); then
        refresh_merged_with_extra "${explicit_sources[@]}"
    fi

    # ensure requested package names exist, or treat as packages to install if present in merged maps
    local valid_pkgs=()
    for p in "${pkg_names[@]}"; do
        if [[ -n "${PKG_URL[$p]:-}" ]]; then
            valid_pkgs+=("$p")
        else
            short_warn "Package not found in merged sources: $p"
            log "WARN: requested package not found: $p"
        fi
    done

    if ((${#valid_pkgs[@]} == 0)); then
        short_warn "No valid packages to install"
        return 1
    fi

    # compute ordered list with dependencies
    mapfile -t ordered < <(build_install_order "${valid_pkgs[@]}")
    short_info "Install order prepared: ${#ordered[@]} packages"

    if [[ "$OPT_DRYRUN" -eq 1 ]]; then
        for p in "${ordered[@]}"; do
            echo "DRYRUN: would install $p (state: $(pkg_get_state "$p"))"
        done
        return 0
    fi

    local failed=0
    for p in "${ordered[@]}"; do
        if pkg_is_installed "$p" && [[ "$OPT_CONTINUE" -eq 0 ]]; then
            short_info "Skipping $p (already INSTALLED)"
            continue
        fi
        if ! run_pipeline_for_package "$p"; then
            short_err "Failed to install $p"
            failed=$((failed+1))
            [[ "$OPT_CONTINUE" -eq 0 ]] && break
        fi
    done

    return $(( failed > 0 ? 1 : 0 ))
}

# -------------------------
# HANDLERS: REMOVE
# -------------------------
remove_packages() {
    local pkgs=("$@")
    if ((${#pkgs[@]} == 0)); then
        short_warn "No packages provided to remove"
        return 1
    fi
    local failed=0
    for p in "${pkgs[@]}"; do
        if [[ -x "$ADM_UNINSTALL" ]]; then
            start_spinner "Uninstalling $p"
            if "$ADM_UNINSTALL" "$p" >>"$LOG_DIR/${p}.uninstall.out" 2>>"$LOG_DIR/${p}.uninstall.err"; then
                stop_spinner 0 "Uninstalled: $p"
                pkg_set_state "$p" "NONE"
                short_ok "Removed $p"
            else
                stop_spinner 1 "Uninstall failed: $p"
                short_err "Uninstall failed: $p (see logs)"
                log_pkg "$p" "UNINSTALL FAILED"
                failed=$((failed+1))
                [[ "$OPT_CONTINUE" -eq 0 ]] && break
            fi
        else
            short_err "adm-uninstall not available; cannot remove $p"
            log "ERROR: adm-uninstall missing; remove not performed for $p"
            failed=$((failed+1))
            [[ "$OPT_CONTINUE" -eq 0 ]] && break
        fi
    done
    return $(( failed > 0 ? 1 : 0 ))
}

# -------------------------
# HANDLERS: REBUILD
# -------------------------
rebuild_packages() {
    local pkgs=("$@")
    if ((${#pkgs[@]} == 0)); then
        short_warn "No packages provided to rebuild"
        return 1
    fi
    local failed=0
    for p in "${pkgs[@]}"; do
        # remove build dir to force rebuild
        local bdir="$BUILD_DIR/$p"
        if [[ -d "$bdir" ]]; then
            safe_rm_dir "$bdir" || { short_err "Failed removing $bdir"; failed=$((failed+1)); [[ "$OPT_CONTINUE" -eq 0 ]] && break; }
        fi
        pkg_set_state "$p" "NONE"
        if ! install_packages "$p"; then
            short_err "Rebuild failed for $p"
            failed=$((failed+1))
            [[ "$OPT_CONTINUE" -eq 0 ]] && break
        fi
    done
    return $(( failed > 0 ? 1 : 0 ))
}

# -------------------------
# HANDLERS: DEPS (show order)
# -------------------------
show_deps_for() {
    local pkg="$1"
    if [[ -z "${PKG_URL[$pkg]:-}" ]]; then
        short_err "Package not found: $pkg"
        return 1
    fi
    local -a order=()
    if ! resolve_dependencies_recursive "$pkg" order; then
        short_err "Dependency resolution failed for $pkg (cycle?)"
        return 1
    fi
    echo "Dependency order for $pkg:"
    for p in "${order[@]}"; do
        printf " - %s (state: %s)\n" "$p" "$(pkg_get_state "$p")"
    done
    return 0
}

# -------------------------
# HANDLERS: SEARCH / INFO
# -------------------------
do_search() {
    local term="$1"
    if [[ -z "$term" ]]; then
        short_warn "Empty search term"
        return 1
    fi
    search_package "$term"
}

do_info() {
    local pkg="$1"
    if [[ -z "$pkg" ]]; then
        short_warn "No package specified"
        return 1
    fi
    info_package "$pkg"
}

# -------------------------
# TUI (simple) - interactive menu
# -------------------------
tui_menu() {
    while :; do
        echo "========================================="
        echo " ADM RUN - TUI"
        echo " 1) Search package"
        echo " 2) Info package"
        echo " 3) Install package(s)"
        echo " 4) Install list file (.list)"
        echo " 5) Show dependency order for a package"
        echo " 6) Show status of packages (summary)"
        echo " 7) Remove package"
        echo " 8) Rebuild package"
        echo " 9) Help"
        echo " 0) Exit"
        echo -n "Choose an option: "
        read -r choice
        case "$choice" in
            1)
                echo -n "Enter search regex: "; read -r r; do_search "$r";;
            2)
                echo -n "Enter package name: "; read -r p; do_info "$p";;
            3)
                echo -n "Enter package names (space separated): "; read -r line
                IFS=' ' read -r -a arr <<<"$line"
                install_packages "${arr[@]}";;
            4)
                echo -n "Enter path to .list file: "; read -r lf
                install_from_listfile "$lf";;
            5)
                echo -n "Enter package name: "; read -r p; show_deps_for "$p";;
            6)
                echo "Packages summary:"
                for pkg in "${!PKG_URL[@]}"; do
                    printf "%-25s %s\n" "$pkg" "$(pkg_get_state "$pkg")"
                done;;
            7)
                echo -n "Enter package(s) to remove: "; read -r line
                IFS=' ' read -r -a arr <<<"$line"
                remove_packages "${arr[@]}";;
            8)
                echo -n "Enter package(s) to rebuild: "; read -r line
                IFS=' ' read -r -a arr <<<"$line"
                rebuild_packages "${arr[@]}";;
            9)
                print_help;;
            0) break;;
            *) echo "Invalid option";;
        esac
        echo
    done
}

# -------------------------
# MAIN - dispatch parsed args from Part1
# -------------------------
main_dispatch() {
    # if TUI requested
    if [[ "$OPT_TUI" -eq 1 ]]; then
        tui_menu
        return 0
    fi

    # handle search/info single-mode requests
    if ((${#REQUEST_DEPS[@]})); then
        for p in "${REQUEST_DEPS[@]}"; do show_deps_for "$p"; done
    fi
    if ((${#REQUEST_REBUILD[@]})); then
        rebuild_packages "${REQUEST_REBUILD[@]}"
    fi
    if ((${#REQUEST_REMOVE[@]})); then
        remove_packages "${REQUEST_REMOVE[@]}"
    fi
    if ((${#REQUEST_INSTALL[@]})); then
        # check whether any of the REQUEST_INSTALL args are .list files -> call install_from_listfile
        local lists=() pkgs=()
        for a in "${REQUEST_INSTALL[@]}"; do
            if [[ -f "$a" && "$a" == *.list ]]; then
                lists+=("$a")
            else
                pkgs+=("$a")
            fi
        done
        local ret=0

        # install lists first (they may re-merge maps and define many pkgs)
        for lf in "${lists[@]}"; do
            if ! install_from_listfile "$lf"; then
                short_err "Failed installing list $lf"
                ret=1
                [[ "$OPT_CONTINUE" -eq 0 ]] && return $ret
            fi
        done

        # then install explicit package names
        if ((${#pkgs[@]})); then
            if ! install_packages "${pkgs[@]}"; then
                short_err "Failed installing requested packages"
                ret=1
            fi
        fi

        return $ret
    fi

    # if nothing matched, print help
    print_help
}

# Run main dispatch
main_dispatch

# After main, print summary
echo
echo "================ adm-run summary ================"
# summarize states
success=0 fail=0 total=0
for pkg in "${!PKG_URL[@]}"; do
    st="$(pkg_get_state "$pkg")"
    total=$((total+1))
    case "$st" in
        INSTALLED) success=$((success+1)) ;;
        FAILED) fail=$((fail+1)) ;;
    esac
done
echo "Packages known: $total"
echo -e "${CLR_GREEN}Installed: $success${CLR_RESET}   ${CLR_RED}Failed: $fail${CLR_RESET}"
echo "Logs: $LOG_DIR"
echo "Merged sources: $MERGED_SOURCES_FILE"
echo "================================================="
if [[ $fail -gt 0 ]]; then
    exit 1
else
    exit 0
fi
