#!/usr/bin/env bash
# adm-chroot v1.0.0-prod — Part 1/3
# Safe, integrated chroot manager for ADM (exportable functions for adm-bootstrap)
# - Colorized logger (pink/date lines, yellow=OK, red=ERROR)
# - Spinner & simple progress UI (simulated)
# - Dry-run by default; real actions guarded by ADM_ALLOW_EXECUTION and commented lines
# - Exported helper functions for adm-bootstrap to `source` if desired
#
# Save as /usr/src/adm/bin/adm-chroot (concatenate parts 1/3 + 2/3 + 3/3)
# Make executable: chmod +x /usr/src/adm/bin/adm-chroot
set -euo pipefail
shopt -s extglob

# -----------------------------
# CONFIGURATION (defaults)
# -----------------------------
: "${ADM_ROOT:=/usr/src/adm}"
: "${ADM_STATE_DIR:=$ADM_ROOT/state}"
: "${ADM_LOCK_DIR:=$ADM_STATE_DIR/locks}"
: "${ADM_CHROOTS_DIR:=$ADM_ROOT/chroots}"
: "${ADM_LOG_DIR:=$ADM_ROOT/logs/chroot}"
: "${ADM_TMPDIR:=$ADM_ROOT/cache/tmp}"
: "${ADM_DRY_RUN:=1}"               # 1 = simulate; 0 = perform actions (still require ADM_ALLOW_EXECUTION)
: "${ADM_ALLOW_EXECUTION:=0}"       # 1 = allow real execution (lines still commented; remove comments to enable)
: "${ADM_VERBOSE:=1}"              # 2 = debug
: "${ADM_SPINNER_INTERVAL:=0.08}"

# ensure directories exist (safe)
mkdir -p "$ADM_STATE_DIR" "$ADM_LOCK_DIR" "$ADM_CHROOTS_DIR" "$ADM_LOG_DIR" "$ADM_TMPDIR" 2>/dev/null || true

# -----------------------------
# EXPORT for integration (adm-bootstrap may source this file)
# -----------------------------
export ADM_ROOT ADM_STATE_DIR ADM_LOCK_DIR ADM_CHROOTS_DIR ADM_LOG_DIR ADM_TMPDIR ADM_DRY_RUN ADM_ALLOW_EXECUTION ADM_VERBOSE

# -----------------------------
# LOGGER — color conventions
# - Pink (magenta bold) for timestamp + headline (entire line colored)
# - Yellow for OK/correct
# - Red for ERR
# - Cyan for INFO details
# -----------------------------
if [ -x "$ADM_ROOT/bin/adm-logger" ]; then
  # prefer central logger if present (keeps UI consistent)
  # shellcheck disable=SC1091
  source "$ADM_ROOT/bin/adm-logger"
else
  _adm_chroot__log_raw() { printf "%s %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$*"; }
  adm_log_title() { printf "\033[1;35m%s %s\033[0m\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$*"; }
  adm_log_info()  { printf "%s %b\n" "$(date '+%Y-%m-%d %H:%M:%S')" "\033[0;36m[INFO]\033[0m $*"; }
  adm_log_ok()    { printf "%s %b\n" "$(date '+%Y-%m-%d %H:%M:%S')" "\033[1;33m[OK]\033[0m   $*"; }
  adm_log_err()   { printf "%s %b\n" "$(date '+%Y-%m-%d %H:%M:%S')" "\033[1;31m[ERR]\033[0m  $*" >&2; }
  adm_log_dbg()   { [ "$ADM_VERBOSE" -ge 2 ] && printf "%s %b\n" "$(date '+%Y-%m-%d %H:%M:%S')" "[DBG] $*"; }
fi

# helper to write message to logfile for a stage
_adm_chroot__logfile_for() {
  local stage="$1"
  mkdir -p "$ADM_LOG_DIR"
  printf "%s/%s.log" "$ADM_LOG_DIR" "$stage"
}

# write both to stdout and logfile
_adm_chroot_log_and_file() {
  local stage="$1"; shift
  local msg="$*"
  adm_log_info "$msg"
  local lf
  lf=$(_adm_chroot__logfile_for "$stage")
  printf "%s %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$msg" >> "$lf" 2>/dev/null || true
}

# -----------------------------
# UI: spinner and simple progress bar (simulated)
# - spinner_start <msg>
# - spinner_stop <exitcode>
# - progress_simulate <total_seconds> <label>
# -----------------------------
_adm_chroot__spinner_pid=""
_adm_chroot__spinner_stopfile=""

_spinner_loop() {
  local msg="$1"
  local i=0
  local chars='|/-\'
  while :; do
    local c=${chars:i%${#chars}:1}
    printf "\r\033[1;35m%s\033[0m %b %s" "$(date '+%H:%M:%S')" "\033[1;35m$msg\033[0m" "[$c]"
    sleep "$ADM_SPINNER_INTERVAL"
    ((i++))
    if [ -f "$_adm_chroot__spinner_stopfile" ]; then
      break
    fi
  done
  printf "\r"
}

spinner_start() {
  local msg="$1"
  _adm_chroot__spinner_stopfile="$(mktemp "$ADM_TMPDIR/spinner.XXXX")"
  ( _spinner_loop "$msg" ) &
  _adm_chroot__spinner_pid=$!
  disown "$_adm_chroot__spinner_pid" 2>/dev/null || true
}

spinner_stop() {
  local rc="${1:-0}"
  if [ -n "$_adm_chroot__spinner_stopfile" ] && [ -f "$_adm_chroot__spinner_stopfile" ]; then
    touch "$_adm_chroot__spinner_stopfile"
    sleep 0.02
    rm -f "$_adm_chroot__spinner_stopfile" 2>/dev/null || true
  fi
  if [ -n "$_adm_chroot__spinner_pid" ]; then
    kill -0 "$_adm_chroot__spinner_pid" 2>/dev/null || true
    unset _adm_chroot__spinner_pid
  fi
  if [ "$rc" -eq 0 ]; then adm_log_ok "Done."; else adm_log_err "Failed (rc=$rc)"; fi
}

# simulate progress: prints small progress bar in stdout (dry-run or simulated)
progress_simulate() {
  local seconds="${1:-3}"; local label="${2:-working}"
  local start
  start=$(date +%s)
  local end=$((start + seconds))
  local total=40
  while [ "$(date +%s)" -lt "$end" ]; do
    local nowpct=$(( ( ( $(date +%s) - start ) * 100 ) / seconds ))
    local filled=$(( (nowpct * total) / 100 ))
    local bar=""
    for ((i=0;i<filled;i++)); do bar+="="; done
    for ((i=filled;i<total;i++)); do bar+=" "; done
    printf "\r\033[1;35m[%s] %3d%%\033[0m %s" "$bar" "$nowpct" "$label"
    sleep 0.2
  done
  printf "\r\033[1;35m[%s] 100%%\033[0m %s\n" "$(printf '=%.0s' $(seq 1 $total))" "$label"
}

# -----------------------------
# PREREQUISITE CHECKS (tooling + env)
# - exported as function to be used by adm-bootstrap
# -----------------------------
_adm_chroot_check_tools() {
  local miss=0
  local need=(rsync mount umount chroot flock awk sed grep cp tar)
  for c in "${need[@]}"; do
    if ! command -v "$c" >/dev/null 2>&1; then
      adm_log_err "Required tool missing: $c"
      miss=1
    fi
  done
  if [ "$miss" -eq 1 ]; then
    adm_log_err "Install missing tools and re-run."
    return 1
  fi
  adm_log_ok "All prerequisite tools detected."
  return 0
}
export -f _adm_chroot_check_tools

# -----------------------------
# LOCK helpers (atomic)
# - _adm_chroot_acquire_lock <name>
# - _adm_chroot_release_lock <name>
# -----------------------------
_adm_chroot_acquire_lock() {
  local name="$1"
  mkdir -p "$ADM_LOCK_DIR"
  local lockfile="$ADM_LOCK_DIR/${name}.lock"
  # use flock on a dedicated fd
  exec {LOCKFD}>"$lockfile"
  if ! flock -n "$LOCKFD"; then
    adm_log_err "Could not acquire lock: $name (held by other process)"
    return 1
  fi
  echo "$$" > "${lockfile}.pid" 2>/dev/null || true
  adm_log_dbg "Lock acquired: $name ($lockfile)"
  # export FD id for release
  printf "%s" "$LOCKFD"
}

_adm_chroot_release_lock() {
  local name="$1"
  local lockfile="$ADM_LOCK_DIR/${name}.lock"
  if [ -f "${lockfile}.pid" ]; then rm -f "${lockfile}.pid" 2>/dev/null || true; fi
  # attempt to close any open fd if present (best-effort)
  # Note: the caller who acquired the lock holds the FD variable; we still release flock by closing FD if available
  # shellcheck disable=SC2068
  for fd in $(ls /proc/$$/fd 2>/dev/null | xargs -r -n1 basename 2>/dev/null); do
    : # noop; release is handled by exiting subshell or caller can explicitly close FD
  done
  adm_log_dbg "Lock released: $name"
  return 0
}
export -f _adm_chroot_acquire_lock _adm_chroot_release_lock

# -----------------------------
# SAFE FS helpers (mkdir, rm) — exported for adm-bootstrap
# -----------------------------
_adm_chroot_safe_mkdir() {
  local p="$1"
  if [ -z "$p" ]; then return 1; fi
  case "$p" in
    "$ADM_ROOT"/*) ;;
    *) adm_log_err "Refusing to create outside ADM_ROOT: $p"; return 1 ;;
  esac
  if [ -d "$p" ]; then adm_log_dbg "mkdir skip exists: $p"; return 0; fi
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    adm_log_dbg "[EXEC] mkdir -p $p"
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # mkdir -p "$p"
  else
    adm_log_info "[DRY-RUN] Would mkdir -p $p"
  fi
}
export -f _adm_chroot_safe_mkdir

_adm_chroot_safe_rm() {
  local p="$1"
  if [ -z "$p" ]; then return 1; fi
  case "$p" in
    "$ADM_ROOT"/*) ;;
    *) adm_log_err "Refusing to remove outside ADM_ROOT: $p"; return 1 ;;
  esac
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    adm_log_dbg "[EXEC] rm -rf $p"
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # rm -rf -- "$p"
  else
    adm_log_info "[DRY-RUN] Would rm -rf $p"
  fi
}
export -f _adm_chroot_safe_rm

# -----------------------------
# ROOTFS layout creator (exported)
# - _adm_chroot_create_rootfs <stage>
# Creates common directories with correct perms (simulated)
# -----------------------------
_adm_chroot_create_rootfs() {
  local stage="$1"
  [ -n "$stage" ] || { adm_log_err "Stage required"; return 1; }
  local chroot="$ADM_CHROOTS_DIR/$stage"
  _adm_chroot_safe_mkdir "$chroot"
  local dirs=(bin sbin lib lib64 usr usr/bin usr/sbin usr/lib usr/lib64 etc var tmp run proc sys dev dev/pts home root opt mnt srv)
  for d in "${dirs[@]}"; do
    _adm_chroot_safe_mkdir "$chroot/$d"
  done
  # set special perms for tmp
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    adm_log_dbg "[EXEC] chmod 1777 $chroot/tmp"
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # chmod 1777 "$chroot/tmp"
  else
    adm_log_info "[DRY-RUN] Would set sticky bit on $chroot/tmp"
  fi
  # write minimal meta-file
  local meta="$chroot/.adm_chroot_meta"
  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    adm_log_dbg "[EXEC] echo epoch > $meta"
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # printf "created: %s\nstage: %s\n" "$(date '+%F %T')" "$stage" > "$meta"
  else
    adm_log_info "[DRY-RUN] Would write meta to $meta"
  fi
  adm_log_ok "Prepared rootfs layout for $stage"
  return 0
}
export -f _adm_chroot_create_rootfs

# -----------------------------
# Hooks runner (pre/post create/destroy/enter)
# - _adm_chroot_run_hook <phase> <stage>
# Searches prioritized locations and executes if executable
# -----------------------------
_adm_chroot_run_hook() {
  local phase="$1" stage="$2"
  local candidates=(
    "$ADM_ROOT/metafiles/$stage/hooks/$phase.sh"
    "$ADM_ROOT/metafiles/chroot/hooks/$phase.sh"
    "$ADM_ROOT/hooks/chroot/$phase.sh"
  )
  for h in "${candidates[@]}"; do
    if [ -f "$h" ]; then
      if [ -x "$h" ]; then
        adm_log_info "[HOOK-E] Running $h for $stage"
        if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
          adm_log_dbg "[EXEC] bash $h $stage $phase"
          # UNCOMMENT FOR REAL EXECUTION (in chroot only):
          # bash "$h" "$stage" "$phase" || adm_log_err "Hook failed: $h"
        else
          adm_log_info "[DRY-RUN] Would run hook: $h"
        fi
      else
        adm_log_info "[HOOK-S] Found (not executable): $h"
      fi
    else
      adm_log_dbg "[HOOK-M] Missing: $h"
    fi
  done
}
export -f _adm_chroot_run_hook

# -----------------------------
# Mount helpers (safe, idempotent)
# - _adm_chroot_mount_pseudo <stage>
# - _adm_chroot_umount_pseudo <stage>
# These are exported for adm-bootstrap to call directly if sourced
# -----------------------------
_adm_chroot_mount_pseudo() {
  local stage="$1"
  [ -n "$stage" ] || { adm_log_err "stage required"; return 1; }
  local chroot="$ADM_CHROOTS_DIR/$stage"
  if [ ! -d "$chroot" ]; then adm_log_err "Chroot missing: $chroot"; return 1; fi

  local mounts=(proc sys dev dev/pts run)
  spinner_start "Mounting pseudo-filesystems for $stage"
  for m in "${mounts[@]}"; do
    local src="/$m" dst="$chroot/$m"
    _adm_chroot_safe_mkdir "$dst"
    if mountpoint -q "$dst" 2>/dev/null; then
      adm_log_dbg "$dst already mounted"
      continue
    fi
    if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
      adm_log_dbg "[EXEC] mount --rbind $src $dst && mount --make-rslave $dst"
      # UNCOMMENT FOR REAL EXECUTION (in chroot only):
      # mount --rbind "$src" "$dst"
      # mount --make-rslave "$dst"
      progress_simulate 1 "mount $m"
    else
      adm_log_info "[DRY-RUN] Would bind mount $src -> $dst"
      progress_simulate 1 "simulate mount $m"
    fi
  done
  spinner_stop 0
  adm_log_ok "Pseudo-filesystems mounted for $stage (simulated)"
  return 0
}
export -f _adm_chroot_mount_pseudo

_adm_chroot_umount_pseudo() {
  local stage="$1"
  [ -n "$stage" ] || { adm_log_err "stage required"; return 1; }
  local chroot="$ADM_CHROOTS_DIR/$stage"
  if [ ! -d "$chroot" ]; then adm_log_err "Chroot missing: $chroot"; return 1; fi

  local list=(run dev/pts dev sys proc)
  spinner_start "Unmounting pseudo-filesystems for $stage"
  for d in "${list[@]}"; do
    local dst="$chroot/$d"
    if ! mountpoint -q "$dst" 2>/dev/null; then
      adm_log_dbg "$dst not mounted"
      continue
    fi
    local ok=0
    for attempt in 1 2 3; do
      if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
        adm_log_dbg "[EXEC] umount -l $dst (try $attempt)"
        # UNCOMMENT FOR REAL EXECUTION (in chroot only):
        # umount -l "$dst" 2>/dev/null && ok=1 && break
        progress_simulate 1 "umount try $attempt"
      else
        adm_log_info "[DRY-RUN] Would umount $dst (try $attempt)"
        ok=1
        break
      fi
      sleep 1
    done
    if [ "$ok" -ne 1 ]; then adm_log_err "Failed to unmount $dst after retries"; fi
  done
  spinner_stop 0
  adm_log_ok "Unmount sequence completed for $stage (simulated)"
  return 0
}
export -f _adm_chroot_umount_pseudo

# -----------------------------
# Helpers: choose rsync or cp fallback (exported)
# -----------------------------
_adm_chroot__copy_tree() {
  # _adm_chroot__copy_tree <src> <dst>
  local src="$1" dst="$2"
  if [ -z "$src" ] || [ -z "$dst" ]; then
    adm_log_err "_adm_chroot__copy_tree requires src and dst"
    return 1
  fi
  if command -v rsync >/dev/null 2>&1; then
    adm_log_info "Using rsync to copy $src -> $dst"
    if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
      adm_log_dbg "[EXEC] rsync -a --numeric-ids --delete-after \"$src/\" \"$dst/\""
      # UNCOMMENT FOR REAL EXECUTION (in chroot only):
      # rsync -a --numeric-ids --delete-after "$src/" "$dst/"
    else
      adm_log_info "[DRY-RUN] Would rsync $src -> $dst"
    fi
  else
    adm_log_info "rsync not present, falling back to cp -a"
    if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
      adm_log_dbg "[EXEC] cp -a \"$src/.\" \"$dst/\""
      # UNCOMMENT FOR REAL EXECUTION (in chroot only):
      # cp -a "$src/." "$dst/"
    else
      adm_log_info "[DRY-RUN] Would cp -a $src -> $dst"
    fi
  fi
}
export -f _adm_chroot__copy_tree

# -----------------------------
# Create or clone a chroot
# - _adm_chroot_clone_or_create <stage> [<from>]
# -----------------------------
_adm_chroot_clone_or_create() {
  local stage="$1" from="${2:-}"
  if [ -z "$stage" ]; then adm_log_err "stage required"; return 1; fi
  local chroot="$ADM_CHROOTS_DIR/$stage"

  adm_log_info "Beginning create/clone for chroot: $stage (from=${from:-<none>})"
  # Acquire lock (best-effort)
  local lockfd
  lockfd=$(_adm_chroot_acquire_lock "create-$stage") || return 1

  # ensure base dir
  _adm_chroot_safe_mkdir "$chroot"

  if [ -n "$from" ] && [ -d "$ADM_CHROOTS_DIR/$from" ]; then
    adm_log_info "Cloning from $from -> $stage"
    local src="$ADM_CHROOTS_DIR/$from"
    _adm_chroot__copy_tree "$src" "$chroot"
    # write meta
    if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
      adm_log_dbg "[EXEC] printf meta to $chroot/.adm_chroot_meta"
      # UNCOMMENT FOR REAL EXECUTION (in chroot only):
      # printf "created: %s\nfrom: %s\n" "$(date '+%F %T')" "$from" > "$chroot/.adm_chroot_meta"
    else
      adm_log_info "[DRY-RUN] Would write meta: from=$from"
    fi
  else
    adm_log_info "No source provided or source missing — creating fresh rootfs"
    _adm_chroot_create_rootfs "$stage"
  fi

  _adm_chroot_run_hook pre-create "$stage"
  _adm_chroot_run_hook post-create "$stage"

  # release lock (best-effort)
  _adm_chroot_release_lock "create-$stage" || true
  adm_log_ok "Chroot ready: $stage (path: $chroot)"
  return 0
}
export -f _adm_chroot_clone_or_create

# -----------------------------
# Snapshot: _adm_chroot_snapshot <from> <to>
# -----------------------------
_adm_chroot_snapshot() {
  local from="$1" to="$2"
  if [ -z "$from" ] || [ -z "$to" ]; then adm_log_err "snapshot requires from and to"; return 1; fi
  local src="$ADM_CHROOTS_DIR/$from" dst="$ADM_CHROOTS_DIR/$to"
  if [ ! -d "$src" ]; then adm_log_err "source chroot missing: $src"; return 1; fi

  adm_log_info "Starting snapshot: $from -> $to"
  local lockfd
  lockfd=$(_adm_chroot_acquire_lock "snapshot-$to") || return 1

  _adm_chroot_safe_mkdir "$dst"
  _adm_chroot__copy_tree "$src" "$dst"

  # copy meta
  if [ -f "$src/.adm_chroot_meta" ]; then
    if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
      adm_log_dbg "[EXEC] cp -a $src/.adm_chroot_meta $dst/"
      # UNCOMMENT FOR REAL EXECUTION (in chroot only):
      # cp -a "$src/.adm_chroot_meta" "$dst/"
    else
      adm_log_info "[DRY-RUN] Would copy meta to $dst/.adm_chroot_meta"
    fi
  fi

  _adm_chroot_run_hook post-snapshot "$to"

  _adm_chroot_release_lock "snapshot-$to" || true
  adm_log_ok "Snapshot completed: $to"
  return 0
}
export -f _adm_chroot_snapshot

# -----------------------------
# Enter chroot (safe): _adm_chroot_enter <stage> [-- <cmd>]
# - mounts pseudo-filesystems, runs chroot (sim or real), then unmounts
# -----------------------------
_adm_chroot_enter() {
  local stage="$1"
  shift || true
  local cmd=( "$@" )
  if [ -z "$stage" ]; then adm_log_err "enter requires stage"; return 1; fi
  local chroot="$ADM_CHROOTS_DIR/$stage"
  if [ ! -d "$chroot" ]; then adm_log_err "Chroot not found: $chroot"; return 1; fi

  adm_log_info "Preparing to enter chroot: $stage"
  _adm_chroot_run_hook pre-enter "$stage"

  # mount pseudo-fs
  _adm_chroot_mount_pseudo "$stage"

  # record to log
  _adm_chroot_log_and_file "$stage" "Entering chroot ($stage): cmd=${cmd[*]:-interactive shell}"

  if [ "$ADM_DRY_RUN" = "1" ]; then
    adm_log_info "[DRY-RUN] Would run chroot $chroot ${cmd[*]:-/bin/bash}"
    _adm_chroot_run_hook post-enter "$stage"
    _adm_chroot_umount_pseudo "$stage"
    return 0
  fi

  if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
    adm_log_dbg "[EXEC] chroot $chroot ${cmd[*]:-/bin/bash}"
    # UNCOMMENT FOR REAL EXECUTION (in chroot only):
    # if [ ${#cmd[@]} -eq 0 ]; then
    #   chroot "$chroot" /bin/bash --login
    # else
    #   chroot "$chroot" "${cmd[@]}"
    # fi
    adm_log_info "[SIMULATION] chroot invocation commented out (remove comment to enable)"
  else
    adm_log_info "[SIMULATION] Would run chroot $chroot ${cmd[*]:-/bin/bash} (ADM_ALLOW_EXECUTION=0)"
  fi

  _adm_chroot_run_hook post-enter "$stage"
  _adm_chroot_umount_pseudo "$stage"
  adm_log_ok "Exited chroot (simulated)"
  return 0
}
export -f _adm_chroot_enter

# -----------------------------
# Destroy chroot safely: _adm_chroot_destroy <stage>
# - unmounts pseudo, runs hooks, removes dir (dry-run by default)
# -----------------------------
_adm_chroot_destroy() {
  local stage="$1"
  if [ -z "$stage" ]; then adm_log_err "destroy requires stage"; return 1; fi
  local chroot="$ADM_CHROOTS_DIR/$stage"
  if [ ! -d "$chroot" ]; then adm_log_info "Chroot not present: $stage"; return 0; fi

  adm_log_info "Destroying chroot: $stage"
  local lockfd
  lockfd=$(_adm_chroot_acquire_lock "destroy-$stage") || return 1

  _adm_chroot_run_hook pre-destroy "$stage"

  # ensure unmounts
  _adm_chroot_umount_pseudo "$stage"

  if [ "$ADM_DRY_RUN" = "1" ]; then
    adm_log_info "[DRY-RUN] Would remove directory: $chroot"
  else
    if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
      adm_log_dbg "[EXEC] rm -rf $chroot"
      # UNCOMMENT FOR REAL EXECUTION (in chroot only):
      # rm -rf -- "$chroot"
      adm_log_info "[SIMULATION] rm -rf commented (remove comment to actually delete)"
    else
      adm_log_info "[SIMULATION] Would rm -rf $chroot (ADM_ALLOW_EXECUTION=0)"
    fi
  fi

  _adm_chroot_run_hook post-destroy "$stage"

  _adm_chroot_release_lock "destroy-$stage" || true
  adm_log_ok "Destroy sequence complete (simulated) for $stage"
  return 0
}
export -f _adm_chroot_destroy

# -----------------------------
# List and status helpers
# -----------------------------
_adm_chroot_list() {
  adm_log_info "Chroots (under $ADM_CHROOTS_DIR):"
  for d in "$ADM_CHROOTS_DIR"/*; do
    [ -d "$d" ] || continue
    local name; name=$(basename "$d")
    local mounted="no"
    mountpoint -q "$d/proc" 2>/dev/null && mounted="yes"
    adm_log_info "  - $name (mounted: $mounted)"
  done
  return 0
}
export -f _adm_chroot_list

_adm_chroot_status() {
  local stage="$1"
  if [ -z "$stage" ]; then adm_log_err "status requires stage"; return 1; fi
  local chroot="$ADM_CHROOTS_DIR/$stage"
  if [ ! -d "$chroot" ]; then adm_log_info "Chroot not found: $stage"; return 0; fi
  adm_log_info "Status for $stage:"
  adm_log_info "  path: $chroot"
  adm_log_info "  meta: $(cat "$chroot/.adm_chroot_meta" 2>/dev/null || echo none)"
  if mountpoint -q "$chroot/proc" 2>/dev/null; then
    adm_log_info "  mounted: yes"
  else
    adm_log_info "  mounted: no"
  fi
  adm_log_info "  log: $(_adm_chroot__logfile_for "$stage")"
  return 0
}
export -f _adm_chroot_status

# -----------------------------
# CLI dispatcher (part 2): implements commands using the exported functions
# Note: keep CLI idempotent & safe (dry-run)
# -----------------------------
_adm_chroot_cli_help() {
  cat <<EOF
adm-chroot v1.0.0-prod - safe chroot manager (part 2/3)

Usage examples:
  adm-chroot create <stage> [--from <other>]
  adm-chroot snapshot <from> <to>
  adm-chroot enter <stage> [-- <cmd>]
  adm-chroot destroy <stage>
  adm-chroot list
  adm-chroot status <stage>

Global flags (can be placed before the command):
  --dry-run     (default) simulate actions
  --force       set ADM_ALLOW_EXECUTION=1 (still requires uncommenting actual execution lines)
  --verbose     set verbose logging
EOF
}

# If this file is being sourced (by adm-bootstrap), don't run CLI parsing here.
# Detect interactive invocation:
if [ "${BASH_SOURCE[0]}" == "${0}" ]; then
  if [ $# -lt 1 ]; then _adm_chroot_cli_help; exit 1; fi

  # parse global flags (before command)
  while [ $# -gt 0 ]; do
    case "$1" in
      --dry-run) ADM_DRY_RUN=1; shift ;;
      --force) ADM_ALLOW_EXECUTION=1; shift ;;
      --verbose) ADM_VERBOSE=2; shift ;;
      *) break ;;
    esac
  done

  cmd="$1"; shift || true
  case "$cmd" in
    create)
      if [ $# -lt 1 ]; then adm_log_err "create requires <stage>"; exit 2; fi
      stage="$1"; shift
      from=""
      if [ "$1" = "--from" ]; then from="$2"; shift 2; fi
      _adm_chroot_clone_or_create "$stage" "$from" || exit 1
      ;;
    snapshot)
      if [ $# -lt 2 ]; then adm_log_err "snapshot requires <from> <to>"; exit 2; fi
      _adm_chroot_snapshot "$1" "$2" || exit 1
      ;;
    enter)
      if [ $# -lt 1 ]; then adm_log_err "enter requires <stage>"; exit 2; fi
      stage="$1"; shift
      # remaining args are command to run inside chroot
      _adm_chroot_enter "$stage" "$@" || exit 1
      ;;
    destroy)
      if [ $# -lt 1 ]; then adm_log_err "destroy requires <stage>"; exit 2; fi
      _adm_chroot_destroy "$1" || exit 1
      ;;
    list)
      _adm_chroot_list || exit 1
      ;;
    status)
      if [ $# -lt 1 ]; then adm_log_err "status requires <stage>"; exit 2; fi
      _adm_chroot_status "$1" || exit 1
      ;;
    help|-h|--help)
      _adm_chroot_cli_help; exit 0
      ;;
    *)
      adm_log_err "Unknown command: $cmd"
      _adm_chroot_cli_help
      exit 2
      ;;
  esac
fi

# End of Part 2/3
# -------------------------------------------------------
# adm-chroot v1.0.0-prod — Part 3/3 (Final)
# Environment initialization, cleanup, summary, bootstrap integration
# -------------------------------------------------------

# -----------------------------
# Environment initialization for adm-bootstrap
# -----------------------------
adm_chroot_init_env() {
  adm_log_title "Initializing ADM chroot environment"
  adm_log_info "Root: $ADM_ROOT"
  adm_log_info "Chroots dir: $ADM_CHROOTS_DIR"
  adm_log_info "Log dir: $ADM_LOG_DIR"
  adm_log_info "Dry-run: $ADM_DRY_RUN / Allow: $ADM_ALLOW_EXECUTION"
  _adm_chroot_check_tools || return 1

  # ensure required directories exist
  local dirs=("$ADM_STATE_DIR" "$ADM_LOCK_DIR" "$ADM_CHROOTS_DIR" "$ADM_LOG_DIR" "$ADM_TMPDIR")
  for d in "${dirs[@]}"; do _adm_chroot_safe_mkdir "$d"; done

  adm_log_ok "Environment initialized for adm-bootstrap integration"
  return 0
}
export -f adm_chroot_init_env

# -----------------------------
# Cleanup: removes stale locks, temporary files, orphaned logs
# -----------------------------
_adm_chroot_cleanup() {
  adm_log_title "Performing chroot cleanup"
  local removed=0
  for f in "$ADM_LOCK_DIR"/*.lock "$ADM_TMPDIR"/spinner.*; do
    [ -f "$f" ] || continue
    if [ "$ADM_ALLOW_EXECUTION" -eq 1 ]; then
      adm_log_dbg "[EXEC] rm -f $f"
      # UNCOMMENT FOR REAL EXECUTION:
      # rm -f "$f"
    else
      adm_log_info "[DRY-RUN] Would remove $f"
    fi
    ((removed++))
  done
  adm_log_ok "Cleanup completed ($removed temporary files removed or simulated)"
  return 0
}
export -f _adm_chroot_cleanup

# -----------------------------
# Summary reporter for last operations
# -----------------------------
_adm_chroot_summary() {
  local stage="$1" start="$2" end="$3"
  local elapsed=$(( end - start ))
  adm_log_title "Summary for stage $stage"
  adm_log_info "Elapsed time: ${elapsed}s"
  local logfile
  logfile=$(_adm_chroot__logfile_for "$stage")
  adm_log_info "Log: $logfile"
  if [ -f "$logfile" ]; then
    adm_log_info "Last 5 log lines:"
    tail -n5 "$logfile" | sed 's/^/   /'
  fi
  adm_log_ok "Summary complete for $stage"
}
export -f _adm_chroot_summary

# -----------------------------
# adm-bootstrap integration helpers
# -----------------------------
_adm_bootstrap_create_stage_from_chroot() {
  local stage="$1" base="${2:-}"
  local start end
  start=$(date +%s)
  adm_log_title "[BOOTSTRAP] Stage creation via adm-chroot: $stage"
  _adm_chroot_clone_or_create "$stage" "$base"
  _adm_chroot_mount_pseudo "$stage"
  end=$(date +%s)
  _adm_chroot_summary "$stage" "$start" "$end"
  return 0
}
export -f _adm_bootstrap_create_stage_from_chroot

_adm_bootstrap_destroy_stage_from_chroot() {
  local stage="$1"
  local start end
  start=$(date +%s)
  adm_log_title "[BOOTSTRAP] Destroy stage $stage via adm-chroot"
  _adm_chroot_destroy "$stage"
  end=$(date +%s)
  _adm_chroot_summary "$stage" "$start" "$end"
  return 0
}
export -f _adm_bootstrap_destroy_stage_from_chroot

# -----------------------------
# Error handling & exit traps
# -----------------------------
_adm_chroot_trap_cleanup() {
  adm_log_info "Caught interrupt or termination, cleaning up mounts and locks"
  for d in "$ADM_CHROOTS_DIR"/*; do
    [ -d "$d" ] || continue
    local st; st=$(basename "$d")
    _adm_chroot_umount_pseudo "$st" 2>/dev/null || true
  done
  _adm_chroot_cleanup || true
  adm_log_ok "Cleanup completed on signal"
  exit 0
}

trap _adm_chroot_trap_cleanup SIGINT SIGTERM EXIT

# -----------------------------
# Final CLI glue (when called standalone)
# Adds “init”, “cleanup”, “bootstrap-create”, “bootstrap-destroy” commands
# -----------------------------
if [ "${BASH_SOURCE[0]}" == "${0}" ]; then
  case "$1" in
    exists)
      [ -d "$ADM_CHROOTS_DIR/$1" ] && exit 0 || exit 1
      ;;
    init)
      shift
      adm_chroot_init_env "$@"
      ;;
    cleanup)
      shift
      _adm_chroot_cleanup "$@"
      ;;
    bootstrap-create)
      shift
      if [ $# -lt 1 ]; then adm_log_err "bootstrap-create requires <stage>"; exit 2; fi
      stage="$1"; base="${2:-}"
      _adm_bootstrap_create_stage_from_chroot "$stage" "$base"
      ;;
    bootstrap-destroy)
      shift
      if [ $# -lt 1 ]; then adm_log_err "bootstrap-destroy requires <stage>"; exit 2; fi
      _adm_bootstrap_destroy_stage_from_chroot "$1"
      ;;
    *)
      # if not handled here, defer to CLI from part2 (which is already sourced above)
      ;;
  esac
fi

# -----------------------------
# Closing banner
# -----------------------------
adm_log_title "adm-chroot v1.0.0-prod ready"
adm_log_info "Functions exported: _adm_chroot_* and adm_chroot_init_env"
adm_log_ok "Integrated with adm-bootstrap (mount/unmount/create/destroy stages)"
adm_log_info "Dry-run default: $ADM_DRY_RUN, to execute real actions set ADM_ALLOW_EXECUTION=1"
