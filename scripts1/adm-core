#!/usr/bin/env bash
# ================================================================
# adm-core.sh
# Núcleo compartilhado do ADM - logging centralizado, UI, spinner,
# variáveis globais, hooks, helpers seguros, download fallback,
# verificação de checksums, gerenciamento de estado de pacotes.
# Inclua: source /usr/src/adm/core/adm-core.sh
# ================================================================

set -euo pipefail
IFS=$'\n\t'

# ---------------------------
# CONFIG / PATHS (exportadas)
# ---------------------------
ADM_ROOT="${ADM_ROOT:-/usr/src/adm}"
CORE_DIR="${CORE_DIR:-$ADM_ROOT/core}"
LOG_DIR="${LOG_DIR:-$ADM_ROOT/logs}"
SRC_DIR="${SRC_DIR:-$ADM_ROOT/sources}"
BUILD_DIR="${BUILD_DIR:-$ADM_ROOT/build}"
PKG_DIR="${PKG_DIR:-$ADM_ROOT/packages}"
INSTALLED_DIR="${INSTALLED_DIR:-$ADM_ROOT/installed}"
BACKUP_DIR="${BACKUP_DIR:-$ADM_ROOT/inst-backups}"
CFG_DIR="${CFG_DIR:-$ADM_ROOT/cfg}"
HOOK_DIR="${HOOK_DIR:-$ADM_ROOT/hooks}"
CACHE_DIR="${CACHE_DIR:-$ADM_ROOT/cache}"
TMP_DIR="${TMP_DIR:-${TMPDIR:-/tmp}/admcore.$$}"

LOG_FILE="${LOG_FILE:-$LOG_DIR/adm.log}"
DEFAULT_RETRY_COUNT="${DEFAULT_RETRY_COUNT:-2}"
DEFAULT_RETRY_DELAY="${DEFAULT_RETRY_DELAY:-3}"

# Ensure directories exist
mkdir -p "$CORE_DIR" "$LOG_DIR" "$SRC_DIR" "$BUILD_DIR" "$PKG_DIR" \
         "$INSTALLED_DIR" "$BACKUP_DIR" "$CFG_DIR" "$HOOK_DIR" "$CACHE_DIR" "$TMP_DIR"

export ADM_ROOT CORE_DIR LOG_DIR SRC_DIR BUILD_DIR PKG_DIR INSTALLED_DIR BACKUP_DIR CFG_DIR HOOK_DIR CACHE_DIR TMP_DIR LOG_FILE

# ---------------------------
# UI / COLORS
# ---------------------------
CLR_RESET='\e[0m'
CLR_MAGENTA='\e[95m'
CLR_GREEN='\e[92m'
CLR_CYAN='\e[96m'
CLR_YELLOW='\e[93m'
CLR_RED='\e[91m'
CLR_GRAY='\e[90m'

timestamp(){ date '+%Y-%m-%d %H:%M:%S'; }

# Centralized logging: all messages go to LOG_FILE and optionally to per-operation logs
_log_write() {
    local level="$1"; shift
    local msg="$*"
    printf '%s [%s] %s\n' "$(timestamp)" "$level" "$msg" >>"$LOG_FILE"
}

# ---------------------------
# USER-FACING SHORT OUTPUT (uniform)
# ---------------------------
adm_headline(){ printf "%b%s%b %b=>%b %s\n" "$CLR_CYAN" "$(timestamp)" "$CLR_RESET" "$CLR_MAGENTA" "$CLR_RESET" "$*"; }
adm_ok(){ printf "%b[✔]%b %s\n" "$CLR_GREEN" "$CLR_RESET" "$*"; _log_write "OK" "$*"; }
adm_fail(){ printf "%b[✖]%b %s\n" "$CLR_RED" "$CLR_RESET" "$*"; _log_write "ERR" "$*"; }
adm_info(){ printf "%b[%s]%b %s\n" "$CLR_GREEN" "$(timestamp)" "$CLR_RESET" "$*"; _log_write "INFO" "$*"; }
adm_warn(){ printf "%b[!]%b %s\n" "$CLR_YELLOW" "$CLR_RESET" "$*"; _log_write "WARN" "$*"; }

# ---------------------------
# SPINNER (reusable)
# ---------------------------
__adm_frames=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
__adm_sp_pid=""
adm_start_spinner(){
    local msg="${1:-Working...}"
    adm_info "$msg"
    (
        local i=0
        while :; do
            printf "\r%b %s %b %s" "$CLR_GREEN" "${__adm_frames[i % ${#__adm_frames[@]}]}" "$CLR_RESET" "$msg"
            i=$((i+1))
            sleep 0.12
        done
    ) &
    __adm_sp_pid=$!
}
adm_stop_spinner(){
    local code="${1:-0}"
    local msg="${2:-Done}"
    if [[ -n "$__adm_sp_pid" ]]; then
        kill "$__adm_sp_pid" >/dev/null 2>&1 || true
        wait "$__adm_sp_pid" 2>/dev/null || true
        __adm_sp_pid=""
    fi
    if [[ "$code" -eq 0 ]]; then
        printf "\r%b[✔]%b %s\n" "$CLR_GREEN" "$CLR_RESET" "$msg"
        _log_write "SPINNER" "OK: $msg"
    else
        printf "\r%b[✖]%b %s\n" "$CLR_RED" "$CLR_RESET" "$msg"
        _log_write "SPINNER" "FAIL: $msg"
    fi
}

# ---------------------------
# CENTRALIZED RUN CMD (captures stdout/stderr to central and per-op logs)
# Usage: adm_run_cmd "short-desc" logfile -- command args...
# ---------------------------
adm_run_cmd(){
    local desc="$1"; shift
    local logpath="$1"; shift
    if [[ -z "$logpath" ]]; then
        logpath="$LOG_DIR/adm.cmd.$(date +%s).log"
    fi
    _log_write "CMD" "$desc -> logfile=$logpath"
    # remaining args are command
    if "$@" >>"$logpath" 2>&1; then
        _log_write "CMDOK" "$desc"
        return 0
    else
        _log_write "CMDFAIL" "$desc (see $logpath)"
        return 1
    fi
}

# ---------------------------
# SAFE HELPERS
# ---------------------------
safe_mkdir(){ mkdir -p "$1" || true; }
safe_rm_dir(){
    local p="$1"
    if [[ -z "$p" ]]; then return 0; fi
    # prevent accidental deletion outside ADM_ROOT
    case "$p" in
        "$ADM_ROOT"/*) rm -rf "$p" || true ;;
        *) adm_warn "Refusing to remove path outside ADM_ROOT: $p"; return 1 ;;
    esac
}
safe_copy(){ cp -a "$1" "$2" >>"$LOG_FILE" 2>&1 || return 1; }

# ---------------------------
# SIMPLE ERROR HANDLER & TRAP (logs last command + exit)
# ---------------------------
_adm_last_cmd=""
_adm_err_trap(){
    local rc=$?
    if [[ $rc -ne 0 ]]; then
        adm_fail "adm-core: command failed (exit $rc). Last command: $_adm_last_cmd"
        _log_write "STACK" "Last command: $_adm_last_cmd"
        # print tail of log for quick diagnosis
        tail -n 40 "$LOG_FILE" 2>/dev/null | sed 's/^/  /'
    fi
    # cleanup tmp if exists
    if [[ -d "$TMP_DIR" ]]; then rm -rf "$TMP_DIR" || true; fi
    exit "$rc"
}
trap '_adm_last_cmd="$BASH_COMMAND"' DEBUG
trap '_adm_err_trap' EXIT INT TERM

# ---------------------------
# DOWNLOAD HELPERS (fallbacks, retries)
# ---------------------------
adm_detect_downloader(){
    if command -v wget >/dev/null 2>&1; then echo "wget"
    elif command -v curl >/dev/null 2>&1; then echo "curl"
    elif command -v rsync >/dev/null 2>&1; then echo "rsync"
    else echo "none"; fi
}

adm_git_clone(){
    local url="$1" dest="$2" depth="${3:-1}"
    safe_mkdir "$(dirname "$dest")"
    if [[ -d "$dest/.git" && -n "$(git -C "$dest" status --porcelain 2>/dev/null)" ]]; then
        _log_write "GIT" "Repo exists and dirty: $dest"
        return 1
    fi
    adm_run_cmd "git clone $url" "$LOG_DIR/git.clone.log" git clone --depth="$depth" "$url" "$dest"
}

adm_download_http(){
    local url="$1" out="$2" retries="${3:-$DEFAULT_RETRY_COUNT}"
    local tool
    tool="$(adm_detect_downloader)"
    local attempt=0
    while :; do
        attempt=$((attempt+1))
        case "$tool" in
            wget)
                if adm_run_cmd "wget $url" "$LOG_DIR/wget.$(date +%s).log" wget -c --no-verbose --retry-connrefused --tries=3 -O "$out" "$url"; then return 0; fi
                ;;
            curl)
                if adm_run_cmd "curl $url" "$LOG_DIR/curl.$(date +%s).log" curl -L --retry 3 --silent --show-error -o "$out" "$url"; then return 0; fi
                ;;
            rsync)
                if adm_run_cmd "rsync $url" "$LOG_DIR/rsync.$(date +%s).log" rsync -avz "$url" "$(dirname "$out")/"; then return 0; fi
                ;;
            *)
                adm_fail "No downloader available (install wget or curl or rsync)"
                return 1
                ;;
        esac
        if (( attempt > retries )); then
            adm_fail "Download failed after $attempt attempts: $url"
            return 1
        fi
        sleep "$DEFAULT_RETRY_DELAY"
    done
}

adm_download_with_fallback(){
    local type="$1" url="$2" destdir="$3"
    safe_mkdir "$destdir"
    case "$type" in
        git|github|gitlab)
            # allow github shorthand: user/repo
            if [[ "$url" =~ ^[^/:]+/[^/:]+$ && "$url" != http* ]]; then
                url="https://github.com/$url.git"
            fi
            adm_git_clone "$url" "$destdir" || return 1
            ;;
        ftp|https|http)
            local file
            file="$(basename "$url")"
            local out="$destdir/$file"
            adm_download_http "$url" "$out" || return 1
            ;;
        rsync)
            adm_run_cmd "rsync $url" "$LOG_DIR/rsync.$(date +%s).log" rsync -avz "$url" "$destdir/" || return 1
            ;;
        *)
            adm_fail "Unknown source type: $type"
            return 1
            ;;
    esac
    return 0
}

# ---------------------------
# CHECKSUM & INTEGRITY
# ---------------------------
adm_checksum_verify(){
    local file="$1" expected="$2"
    if [[ -z "$expected" ]]; then
        _log_write "CHECK" "No checksum provided for $file"
        return 0
    fi
    if ! command -v sha256sum >/dev/null 2>&1; then
        adm_warn "sha256sum not available; skipping checksum for $file"
        return 0
    fi
    if [[ ! -f "$file" ]]; then
        adm_fail "Checksum verify failed: file not found $file"
        return 1
    fi
    local got
    got="$(sha256sum "$file" | awk '{print $1}')"
    if [[ "$got" != "$expected" ]]; then
        adm_fail "Checksum mismatch for $file (expected $expected got $got)"
        return 1
    fi
    adm_ok "Checksum OK for $(basename "$file")"
    return 0
}

# ---------------------------
# HOOKS (global and per-package)
# Hooks structure:
#  $HOOK_DIR/pre/<phase>/*.sh
#  $HOOK_DIR/post/<phase>/*.sh
#  $HOOK_DIR/pre/<pkg>/*.sh
#  $HOOK_DIR/post/<pkg>/*.sh
# Usage: adm_run_hooks pre|post <phase> [pkg]
# ---------------------------
adm_run_hooks(){
    local when="$1"; shift
    local phase="$1"; shift
    local pkg="${1:-}"
    local base
    base="$HOOK_DIR/$when/$phase"
    if [[ -d "$base" ]]; then
        for h in "$base"/*.sh; do
            [[ -x "$h" ]] || continue
            adm_info "hook: $when/$phase -> $(basename "$h")"
            if ! "$h" "$pkg" >>"$LOG_FILE" 2>&1; then
                adm_warn "Hook failed: $h"
                return 1
            fi
        done
    fi
    if [[ -n "$pkg" ]]; then
        local pbase="$HOOK_DIR/$when/$pkg"
        if [[ -d "$pbase" ]]; then
            for h in "$pbase"/*.sh; do
                [[ -x "$h" ]] || continue
                adm_info "hook: $when/$pkg -> $(basename "$h")"
                if ! "$h" "$pkg" >>"$LOG_FILE" 2>&1; then
                    adm_warn "Hook failed: $h"
                    return 1
                fi
            done
        fi
    fi
    return 0
}

# ---------------------------
# PACKAGE STATE MANAGEMENT (BUILD / FETCH / EXTRACT / INSTALLED / FAILED)
# state file: $BUILD_DIR/<pkg>/.state
# ---------------------------
adm_pkg_state_file(){ printf "%s/%s/.state" "$BUILD_DIR" "$1"; }
adm_pkg_set_state(){
    local pkg="$1" state="$2"
    local sf
    sf="$(adm_pkg_state_file "$pkg")"
    mkdir -p "$(dirname "$sf")"
    printf "%s\n" "$state" >"$sf"
    _log_write "PKGSTATE" "$pkg -> $state"
}
adm_pkg_get_state(){
    local pkg="$1"
    local sf
    sf="$(adm_pkg_state_file "$pkg")"
    if [[ -f "$sf" ]]; then cat "$sf"; else echo "NONE"; fi
}

# ---------------------------
# SOURCES.LIST PARSER & MERGER
# Expect lines like:
# name type url version [sha256]
# Merge multiple lists preserving order and allowing overrides.
# ---------------------------
adm_parse_sources_file(){
    local file="$1"
    awk '$1!~ /^#/ && NF>=3 {name=$1; type=$2; url=$3; ver=(NF>=4?$4:""); sha=(NF>=5?$5:""); printf("%s\t%s\t%s\t%s\t%s\n",name,type,url,ver,sha)}' "$file" || true
}

adm_merge_sources_files(){
    # args: list of files (priority order)
    local out="$ADM_ROOT/cfg/merged.sources.list"
    : >"$out"
    local f
    for f in "$@"; do
        [[ -f "$f" ]] || continue
        adm_parse_sources_file "$f" >>"$out"
    done
    _log_write "SOURCES" "Merged sources into $out"
    echo "$out"
}

# ---------------------------
# UTIL: find latest package by name in PKG_DIR
# ---------------------------
adm_find_latest_pkgfile(){
    local name="$1"
    shopt -s nullglob
    local arr=( "$PKG_DIR"/"$name"-*.pkg.tar.* )
    shopt -u nullglob
    if ((${#arr[@]}==0)); then return 1; fi
    printf "%s\n" "${arr[@]}" | sort -V | tail -n1
}

# ---------------------------
# TOOLCHECKS & ENV VERIFY
# ---------------------------
adm_check_tool(){
    local cmd="$1"
    if ! command -v "$cmd" >/dev/null 2>&1; then
        adm_warn "Tool not found: $cmd"
        return 1
    fi
    return 0
}
adm_require_tools(){
    local missing=0
    for t in "$@"; do adm_check_tool "$t" || missing=1; done
    if [[ $missing -ne 0 ]]; then
        adm_warn "One or more required tools missing"
    fi
    return $missing
}

# ---------------------------
# SIMPLE DEBUB / DUMP STATE (for admin)
# ---------------------------
adm_core_dump(){
    cat <<EOF
ADM_ROOT=$ADM_ROOT
CORE_DIR=$CORE_DIR
LOG_DIR=$LOG_DIR
SRC_DIR=$SRC_DIR
BUILD_DIR=$BUILD_DIR
PKG_DIR=$PKG_DIR
INSTALLED_DIR=$INSTALLED_DIR
BACKUP_DIR=$BACKUP_DIR
CFG_DIR=$CFG_DIR
HOOK_DIR=$HOOK_DIR
CACHE_DIR=$CACHE_DIR
TMP_DIR=$TMP_DIR
LOG_FILE=$LOG_FILE
EOF
}

# ---------------------------
# FINISH: Export commonly used functions for scripts that source this file
# ---------------------------
export -f timestamp adm_headline adm_ok adm_fail adm_info adm_warn
export -f adm_start_spinner adm_stop_spinner adm_run_cmd adm_run_hooks
export -f adm_download_with_fallback adm_checksum_verify adm_pkg_set_state adm_pkg_get_state
export -f adm_merge_sources_files adm_find_latest_pkgfile adm_require_tools adm_core_dump
export -f safe_mkdir safe_rm_dir safe_copy adm_detect_downloader
