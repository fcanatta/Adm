#!/usr/bin/env bash
# ================================================================
# adm-clean v1.0
# Limpeza e manutenção completa do ambiente ADM.
# Remove resíduos, builds incompletos, pacotes órfãos, logs antigos e caches.
# ================================================================

set -euo pipefail
IFS=$'\n\t'

ADM_ROOT=${ADM_ROOT:-/usr/src/adm}
BUILD_DIR="$ADM_ROOT/build"
PKG_DIR="$ADM_ROOT/packages"
LOG_DIR="$ADM_ROOT/logs"
INSTALLED_DIR="$ADM_ROOT/installed"
BACKUP_DIR="$ADM_ROOT/inst-backups"
TMP_DIR="$ADM_ROOT/tmp"
CFG_DIR="$ADM_ROOT/cfg"

mkdir -p "$BUILD_DIR" "$PKG_DIR" "$LOG_DIR" "$INSTALLED_DIR" "$BACKUP_DIR" "$TMP_DIR"

# ---------------------------
# UI / Colors
# ---------------------------
CLR_RESET='\e[0m'
CLR_MAGENTA='\e[95m'
CLR_GREEN='\e[92m'
CLR_CYAN='\e[96m'
CLR_YELLOW='\e[93m'
CLR_RED='\e[91m'

timestamp(){ date '+%Y-%m-%d %H:%M:%S'; }
headline(){ printf "%b%s%b %b=>%b %s\n" "$CLR_CYAN" "$(timestamp)" "$CLR_RESET" "$CLR_MAGENTA" "$CLR_RESET" "$1"; }
short_ok(){ printf "%b[✔]%b %s\n" "$CLR_GREEN" "$CLR_RESET" "$1"; }
short_fail(){ printf "%b[✖]%b %s\n" "$CLR_RED" "$CLR_RESET" "$1"; }
short_info(){ printf "%b[%s]%b %s\n" "$CLR_GREEN" "$(timestamp)" "$CLR_RESET" "$1"; }
short_warn(){ printf "%b[!]%b %s\n" "$CLR_YELLOW" "$CLR_RESET" "$1"; }

# spinner
__frames=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
__sp_pid=""
start_spinner(){
    local msg="${1:-Working...}"
    printf "%b%s%b %b=>%b %s\n" "$CLR_CYAN" "$(timestamp)" "$CLR_RESET" "$CLR_MAGENTA" "$CLR_RESET" "$msg"
    (
        local i=0
        while :; do
            printf "\r%b %s %b %s" "$CLR_GREEN" "${__frames[i % ${#__frames[@]}]}" "$CLR_RESET" "$msg"
            i=$((i+1))
            sleep 0.12
        done
    ) &
    __sp_pid=$!
}
stop_spinner(){
    local code=${1:-0} msg="${2:-Done}"
    if [[ -n "$__sp_pid" ]]; then
        kill "$__sp_pid" >/dev/null 2>&1 || true
        wait "$__sp_pid" 2>/dev/null || true
        __sp_pid=""
    fi
    if [[ "$code" -eq 0 ]]; then
        printf "\r%b[✔]%b %s\n" "$CLR_GREEN" "$CLR_RESET" "$msg"
    else
        printf "\r%b[✖]%b %s\n" "$CLR_RED" "$CLR_RESET" "$msg"
    fi
}

# ---------------------------
# ARGS
# ---------------------------
MODE="safe"
DRY_RUN=0
FORCE=0

USAGE="Usage: $(basename "$0") [--safe|--full|--logs-only|--orphans-only] [--dry-run] [--force]"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --safe) MODE="safe"; shift ;;
        --full) MODE="full"; shift ;;
        --logs-only) MODE="logs-only"; shift ;;
        --orphans-only) MODE="orphans-only"; shift ;;
        --dry-run) DRY_RUN=1; shift ;;
        --force) FORCE=1; shift ;;
        -h|--help) echo "$USAGE"; exit 0 ;;
        *) echo "Unknown arg: $1"; echo "$USAGE"; exit 1 ;;
    esac
done

# ---------------------------
# LOGGING
# ---------------------------
RUN_LOG="$LOG_DIR/adm-clean.$(date +%Y%m%d-%H%M%S).log"
: >"$RUN_LOG"
log(){ printf "%s %s\n" "$(timestamp)" "$*" >>"$RUN_LOG"; }

headline "ADM Cleaner - mode=$MODE dry-run=$DRY_RUN"

# ---------------------------
# SAFETY CHECKS
# ---------------------------
if [[ "$ADM_ROOT" != "/usr/src/adm" && "$FORCE" -eq 0 ]]; then
    short_warn "ADM_ROOT não é padrão ($ADM_ROOT). Adicione --force para confirmar limpeza fora de /usr/src/adm."
    exit 1
fi

if [[ "$DRY_RUN" -eq 1 ]]; then
    short_info "Modo DRY-RUN: nenhuma exclusão será feita, apenas exibida."
fi

# ---------------------------
# FUNCTION: Safe delete
# ---------------------------
safe_delete() {
    local path="$1"
    [[ -z "$path" ]] && return 0
    [[ "$path" != "$ADM_ROOT"* ]] && { short_warn "Ignorando caminho fora do ADM_ROOT: $path"; return 0; }
    if [[ "$DRY_RUN" -eq 1 ]]; then
        short_info "DRY-RUN: removeria $path"
        return 0
    fi
    if [[ -e "$path" ]]; then
        rm -rf "$path" >>"$RUN_LOG" 2>&1 || { short_warn "Falha ao remover $path"; log "DELETE_FAIL $path"; }
        log "DELETED $path"
    fi
}

# ---------------------------
# CLEAN LOGS
# ---------------------------
clean_logs() {
    headline "Limpando logs antigos e compactando grandes..."
    find "$LOG_DIR" -type f -size +5M -name "*.out" | while read -r f; do
        short_info "Compactando log grande: $f"
        gzip -f "$f" || true
    done
    find "$LOG_DIR" -type f -mtime +15 -name "*.log" -delete -print | while read -r f; do
        log "OLD_LOG_REMOVED $f"
    done
    short_ok "Logs limpos e otimizados"
}

# ---------------------------
# CLEAN ORPHANS
# ---------------------------
clean_orphans() {
    headline "Procurando resíduos órfãos..."
    local orphans_found=0
    # Pacotes sem manifest
    find "$PKG_DIR" -type f -name "*.pkg.tar.*" | while read -r pkg; do
        local name base
        base=$(basename "$pkg")
        name="${base%%-*}"
        if [[ ! -f "$INSTALLED_DIR"/"$name"-*.manifest ]]; then
            orphans_found=1
            short_info "Pacote órfão: $pkg"
            safe_delete "$pkg"
        fi
    done
    # Builds sem status
    find "$BUILD_DIR" -mindepth 1 -maxdepth 1 -type d | while read -r b; do
        if [[ ! -f "$b/.state" ]]; then
            short_info "Build sem estado: $b"
            safe_delete "$b"
        fi
    done
    short_ok "Órfãos limpos (se existiam)"
}

# ---------------------------
# CLEAN TMP / CACHES
# ---------------------------
clean_tmp() {
    headline "Limpando diretórios temporários..."
    find "$TMP_DIR" -type f -mtime +2 -delete
    find "$TMP_DIR" -type d -empty -delete
    short_ok "TMP limpo"
}

# ---------------------------
# CLEAN BACKUPS
# ---------------------------
clean_backups() {
    headline "Removendo backups antigos..."
    find "$BACKUP_DIR" -maxdepth 1 -type d -mtime +30 | while read -r b; do
        short_info "Backup expirado: $b"
        safe_delete "$b"
    done
    short_ok "Backups antigos removidos"
}

# ---------------------------
# CLEAN BUILD DIRS
# ---------------------------
clean_build_dirs() {
    headline "Removendo diretórios de build falhados..."
    find "$BUILD_DIR" -type f -name ".state" | while read -r st; do
        if grep -q "FAILED" "$st"; then
            local dir
            dir=$(dirname "$st")
            short_info "Build falhado: $dir"
            safe_delete "$dir"
        fi
    done
    short_ok "Builds falhados limpos"
}

# ---------------------------
# FULL CLEAN
# ---------------------------
full_clean() {
    headline "Executando limpeza completa..."
    for d in "$BUILD_DIR" "$TMP_DIR"; do
        short_info "Resetando $d"
        safe_delete "$d"
        mkdir -p "$d"
    done
    clean_logs
    clean_backups
    clean_orphans
    short_ok "Limpeza completa concluída"
}

# ---------------------------
# MAIN EXECUTION
# ---------------------------
case "$MODE" in
    logs-only)
        clean_logs
        ;;
    orphans-only)
        clean_orphans
        ;;
    full)
        clean_logs
        clean_tmp
        clean_backups
        clean_build_dirs
        clean_orphans
        full_clean
        ;;
    safe|*)
        clean_logs
        clean_tmp
        clean_build_dirs
        clean_orphans
        clean_backups
        ;;
esac

headline "Resumo: limpeza concluída (log em $RUN_LOG)"
short_ok "adm-clean finalizado com sucesso"
exit 0
