#!/usr/bin/env bash
# ui.sh - Interactive CLI / Dashboard for ADM Build System
# Location: /usr/src/adm/scripts/ui.sh
# Purpose: provide UI helpers, progress bars, and a dashboard (multi-job) with spinners.
# Author: Generated by ChatGPT
# SPDX-License-Identifier: MIT

# Safe to source multiple times
: "${ADM_UI_SH_LOADED:-}" || ADM_UI_SH_LOADED=0
if [ "$ADM_UI_SH_LOADED" -eq 1 ]; then
    return 0
fi
ADM_UI_SH_LOADED=1

# Require bash
if [ -z "$BASH_VERSION" ]; then
    echo "ui.sh: WARNING: bash not detected; script assumes bash features." >&2
fi

set -u

# Load environment (if available)
ADM_SCRIPTS_DEFAULT="/usr/src/adm/scripts"
: "${ADM_SCRIPTS:=${ADM_SCRIPTS_DEFAULT}}"
if [ -f "${ADM_SCRIPTS}/env.sh" ]; then
    # shellcheck disable=SC1090
    source "${ADM_SCRIPTS}/env.sh" || true
fi

# Prefer log.sh if present
if [ -f "${ADM_SCRIPTS}/log.sh" ]; then
    # shellcheck disable=SC1090
    source "${ADM_SCRIPTS}/log.sh" || true
else
    _adm_log_fallback() {
        local lvl="$1"; shift
        printf '%s [%s] %s\n' "$(date -u +'%Y-%m-%dT%H:%M:%SZ')" "$lvl" "$*" >&2
    }
    log_info() { _adm_log_fallback INFO "$*"; }
    log_warn() { _adm_log_fallback WARN "$*"; }
    log_error() { _adm_log_fallback ERROR "$*"; }
fi

# Defaults (can be overridden by env.sh or ADM_UI_MODE)
: "${ADM_UI_MODE:=auto}"      # auto, SIMPLE, DASHBOARD, COMPACT, SILENT
: "${ADM_COLOR:=true}"
: "${ADM_REFRESH:=0.18}"      # seconds between dashboard ticks
: "${ADM_TMP:=/usr/src/adm/tmp/ui}"
: "${ADM_JOBS:=1}"
: "${ADM_LOGS:=/usr/src/adm/logs}"
: "${ADM_UI_MIN_TTY_COLS:=60}"

# ensure dirs
mkdir -p "$ADM_TMP/jobs" "$ADM_TMP" "$ADM_LOGS" 2>/dev/null || true

# Terminal capabilities
IS_TTY=false
if [ -t 1 ]; then IS_TTY=true; fi
if [ "$ADM_UI_MODE" = "SILENT" ] || [ "${ADM_LOGLEVEL:-}" = "QUIET" ]; then
    IS_TTY=false
fi

# Color helpers
_ui_color_reset() { printf '\e[0m'; }
_ui_color() { [ "$ADM_COLOR" = "true" ] && printf '%b' "$1" || true; }
_ui_ok_color='\e[1;32m'
_ui_err_color='\e[1;31m'
_ui_warn_color='\e[1;33m'
_ui_info_color='\e[1;34m'
_ui_run_color='\e[1;36m'

# Detect terminal width
_ui_term_cols() {
    local cols=80
    if $IS_TTY; then
        cols=$(tput cols 2>/dev/null || echo 80)
    fi
    echo "$cols"
}

# Time formatting
_ui_format_time() {
    local s=$1
    local h=$((s/3600))
    local m=$(( (s%3600)/60 ))
    local sec=$((s%60))
    if [ "$h" -gt 0 ]; then
        printf '%dh%02dm%02ds' "$h" "$m" "$sec"
    elif [ "$m" -gt 0 ]; then
        printf '%dm%02ds' "$m" "$sec"
    else
        printf '%ds' "$sec"
    fi
}

# Spinner themes
declare -A SPINNER_THEMES
SPINNER_THEMES[dots]='⠋ ⠙ ⠹ ⠸ ⠼ ⠴ ⠦ ⠧ ⠇ ⠏'
SPINNER_THEMES[line]='- \| /'
SPINNER_THEMES[arrow]='↻ ↺ ↻ ↺'
SPINNER_THEMES[pulse]='• ● • ○'
SPINNER_THEMES[bounce]='⠁ ⠂ ⠄ ⠂'

# Convert theme string to array of frames
_ui_spinner_frames() {
    local theme="$1"
    local frames_str
    frames_str="${SPINNER_THEMES[$theme]:-${SPINNER_THEMES[dots]}}"
    # split on space
    read -r -a frames <<<"$frames_str"
    echo "${frames[@]}"
}

# Manage spinner state for jobs
# job status files: $ADM_TMP/jobs/<jobid>.status
# Format (kv lines or json-like): pkg=...\nstage=...\npercent=..\nstatus=RUNNING|DONE|FAILED\nstart=epoch

# Write helper for job status (can be used by build scripts)
ui_job_status_write() {
    local jobfile="$1"; shift
    local tmp jobdir
    jobdir=$(dirname "$jobfile")
    mkdir -p "$jobdir" 2>/dev/null || true
    tmp="${jobfile}.$(date +%s%N).tmp"
    : > "$tmp"
    while [ "$#" -gt 0 ]; do
        echo "$1" >> "$tmp"
        shift
    done
    mv -f "$tmp" "$jobfile" || true
}

# Read job status into associative array
ui_job_status_read() {
    local jobfile="$1"
    declare -A st
    if [ ! -f "$jobfile" ]; then
        echo ""
        return 0
    fi
    while IFS= read -r line || [ -n "$line" ]; do
        case "$line" in
            *=*) key=${line%%=*}; val=${line#*=}; st[$key]="$val" ;;
            *) : ;;
        esac
    done < "$jobfile"
    # print as key=value pairs to stdout for caller to eval
    for k in "${!st[@]}"; do
        printf '%s=%s\n' "$k" "${st[$k]}"
    done
}

# Utility: safe echo with truncation
_ui_trunc() {
    local text="$1" max=$2
    if [ ${#text} -le $max ]; then printf '%s' "$text"; else printf '%s' "${text:0:$((max-3))}..."; fi
}

# Draw a single dashboard line for a job
_ui_draw_job_line() {
    local idx="$1" jobfile="$2" cols="$3" spinner_frame="$4"
    # read status kvs
    declare -A S
    while IFS= read -r kv || [ -n "$kv" ]; do
        case "$kv" in
            *=*) k=${kv%%=*}; v=${kv#*=}; S[$k]="$v" ;;
        esac
    done < <(ui_job_status_read "$jobfile")

    local pkg="${S[pkg]:-unknown}"
    local stage="${S[stage]:-idle}"
    local percent="${S[percent]:-0}"
    local status="${S[status]:-RUNNING}"
    local elapsed="${S[elapsed]:-0}"

    local left="[${idx}]"
    local pctstr="${percent}%"
    local elapsed_str="$(_ui_format_time "$elapsed")"
    local eta=""
    if [[ "$percent" =~ ^[0-9]+$ ]] && [ "$percent" -gt 0 ] && [ "$percent" -lt 100 ]; then
        eta="ETA: --"
    fi

    # Build content
    local maxpkg=$((cols-40))
    [ $maxpkg -lt 10 ] && maxpkg=10
    local pkg_disp
    pkg_disp=$(_ui_trunc "$pkg" $maxpkg)

    local status_icon
    case "$status" in
        RUNNING) status_icon="$spinner_frame" ;;
        DONE) status_icon="✔" ;;
        FAILED) status_icon="✖" ;;
        *) status_icon="·" ;;
    esac

    printf ' %s %-*s  %5s  %6s  %s\n' "$left" $maxpkg "$pkg_disp" "$pctstr" "$status_icon" "$elapsed_str"
}

# Draw header and footer
_ui_draw_header() {
    local total_jobs running completed failed start_ts
    total_jobs=$(ls "$ADM_TMP/jobs" 2>/dev/null | wc -l || echo 0)
    running=0; completed=0; failed=0
    for jf in "$ADM_TMP"/jobs/*; do
        [ -f "$jf" ] || continue
        # read status
        local st
        st=$(ui_job_status_read "$jf" | awk -F= '/^status=/{print $2; exit}') || true
        case "$st" in
            RUNNING) running=$((running+1)) ;;
            DONE) completed=$((completed+1)) ;;
            FAILED) failed=$((failed+1)) ;;
            *) : ;;
        esac
    done
    start_ts=${ADM_UI_START_TS:-$(date +%s)}
    local uptime=$(( $(date +%s) - start_ts ))
    local profile_display="${ADM_PROFILE:-default}"
    local header_line
    header_line="Jobs: ${total_jobs} | Running: ${running} | Completed: ${completed} | Failures: ${failed} | Profile: ${profile_display} | Uptime: $(_ui_format_time $uptime)"

    local cols
    cols=$(_ui_term_cols)
    printf '%s\n' "${header_line:0:$cols}"
    # separator
    printf '%*s\n' "$cols" '' | tr ' ' '─'
}

_ui_draw_footer() {
    local cols=$1
    printf '%*s\n' "$cols" '' | tr ' ' '─'
}

# Dashboard loop
_ui_dashboard_loop_running=false
_ui_dashboard_loop() {
    ADM_UI_START_TS=$(date +%s)
    _ui_dashboard_loop_running=true
    trap '_ui_dashboard_cleanup_and_exit' EXIT INT TERM
    trap '_ui_dashboard_handle_sigwinch' WINCH

    local cols
    local spinner_tick=0
    while _ui_dashboard_loop_running; do
        cols=$(_ui_term_cols)
        # clear screen and move to top
        if $IS_TTY; then
            tput civis 2>/dev/null || true
            tput sc 2>/dev/null || true
            tput cup 0 0 2>/dev/null || printf '\033[H'
        fi

        _ui_draw_header

        # list job files sorted by name
        local i=0
        for jf in "$ADM_TMP"/jobs/*; do
            [ -f "$jf" ] || continue
            i=$((i+1))
            # pick spinner frame for this job
            local theme
            theme=$(ui_job_status_read "$jf" | awk -F= '/^spinner=/{print $2; exit}') || true
            [ -z "$theme" ] && theme=dots
            read -r -a frames <<<"$(_ui_spinner_frames "$theme")"
            local fcount=${#frames[@]}
            local frame_index=$(( spinner_tick % fcount ))
            local frame_char="${frames[$frame_index]}"
            _ui_draw_job_line "$i" "$jf" "$cols" "$frame_char"
        done

        _ui_draw_footer "$cols"
        # flush output
        if $IS_TTY; then
            tput rc 2>/dev/null || true
        fi

        spinner_tick=$((spinner_tick+1))
        sleep "$ADM_REFRESH"

        # Stop condition: no job files or all done
        local any_running=0
        for jf in "$ADM_TMP"/jobs/*; do
            [ -f "$jf" ] || continue
            local st
            st=$(ui_job_status_read "$jf" | awk -F= '/^status=/{print $2; exit}') || true
            if [ "$st" = "RUNNING" ] || [ -z "$st" ]; then any_running=1; break; fi
        done
        if [ $any_running -eq 0 ]; then
            _ui_dashboard_loop_running=false
        fi
    done

    # restore cursor
    if $IS_TTY; then
        tput cnorm 2>/dev/null || true
    fi

    # final summary
    _ui_dashboard_exit
}

_ui_dashboard_handle_sigwinch() { :; }

_ui_dashboard_cleanup_and_exit() {
    _ui_dashboard_loop_running=false
}

# Exit and summary
_ui_dashboard_exit() {
    # compute summary
    local total=0 success=0 fail=0
    for jf in "$ADM_TMP"/jobs/*; do
        [ -f "$jf" ] || continue
        total=$((total+1))
        local st
        st=$(ui_job_status_read "$jf" | awk -F= '/^status=/{print $2; exit}') || true
        if [ "$st" = "DONE" ]; then success=$((success+1)); fi
        if [ "$st" = "FAILED" ]; then fail=$((fail+1)); fi
    done
    local elapsed=$(( $(date +%s) - ADM_UI_START_TS ))
    printf '\n'
    printf 'Build Summary\n'
    printf 'Total: %d | Success: %d | Failures: %d | Time: %s\n' "$total" "$success" "$fail" "$(_ui_format_time $elapsed)"
    log_info "UI: Build summary total=$total success=$success fail=$fail time=$elapsed"
}

# SIMPLE mode spinner helpers for single-job interactive output
_ui_simple_spinner() {
    local theme=${1:-dots}
    local -a frames
    read -r -a frames <<<"$(_ui_spinner_frames "$theme")"
    local idx=0
    while :; do
        printf '%s' "${frames[$idx]}"
        sleep "$ADM_REFRESH"
        idx=$(( (idx+1) % ${#frames[@]} ))
    done
}

# Public API: init and start
ui_init() {
    # decide mode
    if [ "$ADM_UI_MODE" = "auto" ]; then
        if [ "$ADM_JOBS" -gt 1 ] && $IS_TTY; then
            ADM_UI_MODE=DASHBOARD
        else
            ADM_UI_MODE=SIMPLE
        fi
    fi

    log_info "UI: init mode=$ADM_UI_MODE jobs=$ADM_JOBS"
    if [ "$ADM_UI_MODE" = "DASHBOARD" ]; then
        # start the dashboard loop in background
        _ui_dashboard_loop
    fi
}

# Start dashboard (blocking until jobs finish)
ui_start_dashboard() {
    if [ "$ADM_UI_MODE" != "DASHBOARD" ]; then return 0; fi
    _ui_dashboard_loop
}

# Helper for build scripts to register themselves (creates job file)
# Usage: ui_register_job <jobid> <pkg> <spinner_theme>
ui_register_job() {
    local jid="$1" pkg="$2" spinner_theme="${3:-dots}"
    local jf="$ADM_TMP/jobs/$jid.status"
    ui_job_status_write "$jf" "pkg=$pkg" "stage=queued" "percent=0" "status=RUNNING" "spinner=$spinner_theme" "start=$(date +%s)" "elapsed=0"
}

# Helper for build scripts to update percent/elapsed
# Usage: ui_update_job <jobid> percent=<n> stage=<stage> status=RUNNING
ui_update_job() {
    local jid="$1" shiftargs
    shift
    local jf="$ADM_TMP/jobs/$jid.status"
    # read existing to preserve values
    declare -A old
    if [ -f "$jf" ]; then
        while IFS= read -r l || [ -n "$l" ]; do
            case "$l" in
                *=*) k=${l%%=*}; v=${l#*=}; old[$k]="$v" ;;
            esac
        done < "$jf"
    fi
    local tmp="${jf}.$(date +%s%N).tmp"
    :> "$tmp"
    # write preserved fields
    for k in pkg stage percent status spinner start elapsed; do
        if [ -n "${old[$k]:-}" ]; then
            echo "$k=${old[$k]}" >> "$tmp"
        fi
    done
    # apply updates
    while [ "$#" -gt 0 ]; do
        echo "$1" >> "$tmp"
        shift
    done
    # recalc elapsed
    if [ -f "$jf" ]; then
        local s=$(awk -F= '/^start=/{print $2; exit}' "$jf" 2>/dev/null || echo 0)
        if [ "$s" -gt 0 ]; then
            local elapsed=$(( $(date +%s) - s ))
            echo "elapsed=$elapsed" >> "$tmp"
        fi
    fi
    mv -f "$tmp" "$jf" || true
}

# Mark job done
ui_mark_done() {
    local jid="$1" jf="$ADM_TMP/jobs/$jid.status"
    if [ -f "$jf" ]; then
        ui_update_job "$jid" "percent=100" "status=DONE"
    fi
}

# Mark job failed
ui_mark_failed() {
    local jid="$1" jf="$ADM_TMP/jobs/$jid.status"
    if [ -f "$jf" ]; then
        ui_update_job "$jid" "status=FAILED"
    fi
}

# show last few lines of job log
ui_show_job_log() {
    local jid="$1" logf="$ADM_LOGS/$jid.log"
    if [ -f "$logf" ]; then
        tail -n 200 "$logf"
    else
        echo "No log for $jid"
    fi
}

# expose some functions
export -f ui_init ui_start_dashboard ui_register_job ui_update_job ui_mark_done ui_mark_failed ui_show_job_log ui_job_status_write

log_info "ui.sh loaded: mode=${ADM_UI_MODE} jobs=${ADM_JOBS} tmp=${ADM_TMP}"
