#!/usr/bin/env bash
# env.sh - Environment bootstrap for ADM Build System
# Location: /usr/src/adm/scripts/env.sh
# Purpose: define/export global variables, detect environment, provide persistent cache,
#          robust error handling, and support --set overrides passed as arguments.
# Author: Generated by ChatGPT
# SPDX-License-Identifier: MIT

# Guard: allow this file to be sourced multiple times safely
: "${ADM_ENV_SH_LOADED:-}" || ADM_ENV_SH_LOADED=0
if [ "$ADM_ENV_SH_LOADED" -eq 1 ]; then
    return 0
fi
ADM_ENV_SH_LOADED=1

# Ensure we're running under bash
if [ -z "$BASH_VERSION" ]; then
    echo "env.sh: warning: bash not detected; script assumes bash features."
fi

set -u

# --------------------- Basic utilities ---------------------
# prefer log.sh if available
ADM_SCRIPTS_DEFAULT="/usr/src/adm/scripts"
ADM_ROOT_DEFAULT="/usr/src/adm"

# allow wrapper to set ADM_ROOT before sourcing
: "${ADM_ROOT:=$ADM_ROOT_DEFAULT}"
: "${ADM_SCRIPTS:=${ADM_ROOT}/scripts}"

if [ -f "${ADM_SCRIPTS}/log.sh" ]; then
    # shellcheck disable=SC1090
    source "${ADM_SCRIPTS}/log.sh"
else
    # Provide minimal logging fallbacks
    _adm_log() {
        local level="$1"; shift
        local msg="$*"
        printf '%s [%s] %s\n' "$(date -u +'%Y-%m-%dT%H:%M:%SZ')" "$level" "$msg" >&2
    }
    die() { _adm_log "FATAL" "$*"; return 1; }
    info() { _adm_log "INFO" "$*"; }
    warn() { _adm_log "WARN" "$*"; }
    debug() { if [ "${ADM_DEBUG:-false}" = "true" ]; then _adm_log "DEBUG" "$*"; fi }
fi

# safe die wrapper for sourced context
_die() {
    if (return 0 2>/dev/null); then
        # we're sourced â€” return non-zero so caller can decide
        _adm_log "FATAL" "$*"
        return 1
    else
        _adm_log "FATAL" "$*"
        exit 1
    fi
}

# safe_run: run a command, capture output, return status
safe_run() {
    local -r cmd=("$@")
    local out
    out="$("${cmd[@]}" 2>&1)" || {
        local rc=$?
        debug "safe_run failed: ${cmd[*]} rc=${rc} out=${out}"
        return $rc
    }
    if [ -n "$out" ]; then debug "safe_run out: ${cmd[*]} -> ${out}"; fi
    return 0
}

retry() {
    local -r tries=${1:-3}; shift
    local -r backoff=${1:-1}; shift || true
    local n=0
    local rc
    until [ $n -ge "$tries" ]; do
        "$@" && return 0
        rc=$?
        n=$((n+1))
        sleep $((backoff * n))
    done
    return $rc
}

# validate key name for --set
validate_key() {
    case "$1" in
        [A-Z0-9_]* ) return 0 ;;
        * ) return 1 ;;
    esac
}

# atomic write
safe_atomic_write() {
    local file="$1"; shift
    local tmp
    tmp="${file}.$(date +%s).tmp"
    umask 077
    : > "$tmp" || return 1
    cat > "$tmp" || return 1
    mv -f "$tmp" "$file" || return 1
}

# acquire lock using flock if available
acquire_lock() {
    local lockfile="$1"; shift
    exec 9>"$lockfile" || return 1
    if command -v flock >/dev/null 2>&1; then
        flock -x 9 || return 1
    fi
    return 0
}
release_lock() {
    # close fd 9
    exec 9>&-
}

# --------------------- Defaults and paths ---------------------
: "${ADM_REPO:=${ADM_ROOT}/repo}"
: "${ADM_BUILD:=${ADM_ROOT}/build}"
: "${ADM_LOGS:=${ADM_ROOT}/logs}"
: "${ADM_CACHE:=${ADM_ROOT}/cache}"
: "${ADM_CONFIG:=${ADM_ROOT}/config}"
: "${ADM_BOOTSTRAP:=${ADM_ROOT}/bootstrap}"
: "${ADM_OUTPUT:=${ADM_BOOTSTRAP}/output}"

: "${ADM_PROFILE:=default}"
: "${ADM_DEBUG:=false}"
: "${ADM_COLOR:=true}"
: "${ADM_STRIP:=true}"
: "${ADM_LOGLEVEL:=INFO}"
: "${ADM_TMP:=/tmp/adm}"
: "${ADM_MIN_FREE_MB:=50}"
: "${ADM_RETRY:=3}"
: "${ADM_CACHE_TTL:=86400}" # 24h in seconds
: "${ADM_LOCK_TIMEOUT:=30}"
: "${ADM_FORCE_NONFATAL:=false}"

# sensible default for ADM_JOBS: detect cores
_detect_nproc() {
    if command -v nproc >/dev/null 2>&1; then
        nproc
    elif [ -r /proc/cpuinfo ]; then
        grep -c '^processor' /proc/cpuinfo
    else
        echo 1
    fi
}
: "${ADM_NPROC:=$(_detect_nproc)}"
: "${ADM_JOBS:=$((ADM_NPROC+0))}"

# limit jobs to a safe maximum
ADM_JOBS_LIMIT=512
if ! [[ "$ADM_JOBS" =~ ^[0-9]+$ ]]; then
    warn "ADM_JOBS invalid ('$ADM_JOBS'), resetting to 1"
    ADM_JOBS=1
fi
if [ "$ADM_JOBS" -lt 1 ]; then ADM_JOBS=1; fi
if [ "$ADM_JOBS" -gt "$ADM_JOBS_LIMIT" ]; then
    warn "ADM_JOBS too large ($ADM_JOBS), limiting to $ADM_JOBS_LIMIT"
    ADM_JOBS=$ADM_JOBS_LIMIT
fi

# --------------------- Cache mechanics ---------------------
: "${ADM_CACHE_FILE:=${ADM_CACHE}/env-detect.cache}"
: "${ADM_CACHE_LOCK:=${ADM_CACHE_FILE}.lock}"

mkdir -p "$ADM_CACHE" "$ADM_LOGS" "$ADM_BUILD" "$ADM_TMP" 2>/dev/null || true

# load cache if valid
_cache_is_valid() {
    local file="$1"
    if [ ! -f "$file" ]; then return 1; fi
    # read timestamp
    local ts
    ts=$(awk -F'=' '/^CACHE_TS=/{print $2; exit}' "$file" 2>/dev/null || true)
    if [ -z "$ts" ]; then return 1; fi
    if ! [[ "$ts" =~ ^[0-9]+$ ]]; then return 1; fi
    local now
    now=$(date +%s)
    if [ $((now - ts)) -gt "$ADM_CACHE_TTL" ]; then
        debug "cache expired by TTL"
        return 1
    fi
    # ensure profile matches
    local profile_in_cache
    profile_in_cache=$(awk -F'=' '/^CACHE_PROFILE=/{print $2; exit}' "$file" 2>/dev/null || true)
    if [ -n "$profile_in_cache" ] && [ "$profile_in_cache" != "$ADM_PROFILE" ]; then
        debug "cache profile mismatch: $profile_in_cache != $ADM_PROFILE"
        return 1
    fi
    return 0
}

_load_cache() {
    local file="$1"
    # shellcheck disable=SC1090
    source "$file" 2>/dev/null || return 1
    return 0
}

_write_cache() {
    local file="$1"
    local tmp
    tmp="${file}.$(date +%s).tmp"
    umask 077
    {
        echo "CACHE_TS=$(date +%s)"
        echo "CACHE_PROFILE=${ADM_PROFILE}"
        echo "ADM_ARCH=${ADM_ARCH:-unknown}"
        echo "ADM_OS=${ADM_OS:-unknown}"
        echo "ADM_DISTRO=${ADM_DISTRO:-unknown}"
        echo "ADM_NPROC=${ADM_NPROC:-$ADM_NPROC}"
        echo "GCC_VERSION=${GCC_VERSION:-unknown}"
        echo "TOOL_CHECKS=${TOOL_CHECKS:-}"
    } > "$tmp" || return 1
    mv -f "$tmp" "$file" || return 1
    chmod 600 "$file" || true
    return 0
}

# --------------------- Detection routines ---------------------
_detect_basic() {
    ADM_ARCH="$(uname -m 2>/dev/null || echo unknown)"
    ADM_OS="$(uname -s 2>/dev/null || echo unknown)"
    # distro detection
    if [ -r /etc/os-release ]; then
        # shellcheck disable=SC1091
        . /etc/os-release
        ADM_DISTRO="${NAME:-${ID:-unknown}}"
    else
        if command -v lsb_release >/dev/null 2>&1; then
            ADM_DISTRO="$(lsb_release -ds 2>/dev/null || echo unknown)"
        else
            ADM_DISTRO="unknown"
        fi
    fi
    ADM_NPROC="$(_detect_nproc)"
}

_detect_tools() {
    TOOL_CHECKS=""
    _check_tool() {
        local t="$1"
        if command -v "$t" >/dev/null 2>&1; then
            local v
            case "$t" in
                gcc) v=$(gcc --version 2>/dev/null | head -n1 | awk '{print $3}' ) || v=unknown ;;
                make) v=$(make --version 2>/dev/null | head -n1 | awk '{print $3}') || v=unknown ;;
                *) v=$("$t" --version 2>/dev/null | head -n1) || v=present ;;
            esac
            TOOL_CHECKS+="${t}:present:${v};"
        else
            TOOL_CHECKS+="${t}:missing:;"
        fi
    }

    for t in bash tar wget curl git make gcc ld strip sha256sum; do
        _check_tool "$t"
    done
    GCC_VERSION=$(awk -F: 'match($0,/gcc[^0-9]*([0-9\.]+)/,a){print a[1]; exit}' <<<"$TOOL_CHECKS" 2>/dev/null || true)
}

# --------------------- Argument parsing for --set ---------------------
# Accepts both: source env.sh --set KEY=VAL ... and passing string via ADM_SET_ARGS
parse_set_args() {
    local args=()
    # if ADM_SET_ARGS provided (wrapper), split it
    if [ -n "${ADM_SET_ARGS-}" ]; then
        # shellcheck disable=SC2086
        args+=( $ADM_SET_ARGS )
    fi
    # include $@ if provided
    if [ "$#" -gt 0 ]; then
        args+=("$@")
    fi

    local i=0
    while [ $i -lt ${#args[@]} ]; do
        local token="${args[$i]}"
        case "$token" in
            --set)
                i=$((i+1))
                token="${args[$i]-}"
                ;;
            --set=*)
                token="${token#--set=}"
                ;;
            --*)
                # ignore other flags
                i=$((i+1))
                continue
                ;;
        esac
        if [ -n "$token" ]; then
            # token expected as KEY=VAL
            if [[ "$token" =~ ^([A-Z0-9_]+)=(.*)$ ]]; then
                local key=${BASH_REMATCH[1]}
                local val=${BASH_REMATCH[2]}
                if validate_key "$key"; then
                    # special handling for numeric keys
                    if [[ "$key" =~ ^ADM_[0-9A-Z_]*JOBS$ ]] || [ "$key" = "ADM_JOBS" ]; then
                        if ! [[ "$val" =~ ^[0-9]+$ ]]; then
                            warn "Ignored --set $key=$val (not a positive integer)"
                        else
                            export "$key"="$val"
                            info "Override: $key=$val"
                        fi
                    else
                        export "$key"="$val"
                        info "Override: $key=$val"
                    fi
                else
                    warn "Ignored invalid key in --set: $key"
                fi
            else
                warn "Ignored malformed --set argument: $token (expected KEY=VAL)"
            fi
        fi
        i=$((i+1))
    done
}

# --------------------- Cache load/invalidate logic ---------------------
use_cache="false"
if _cache_is_valid "$ADM_CACHE_FILE"; then
    if acquire_lock "$ADM_CACHE_LOCK"; then
        if _load_cache "$ADM_CACHE_FILE"; then
            use_cache="true"
            debug "Loaded env from cache"
        else
            debug "Cache load failed, will regenerate"
        fi
        release_lock
    else
        warn "Could not acquire cache lock, proceeding without cache"
    fi
fi

if [ "$use_cache" != "true" ]; then
    # perform live detection
    _detect_basic || warn "Basic detection failed"
    _detect_tools || warn "Tool detection failed"
    # write cache under lock
    if acquire_lock "$ADM_CACHE_LOCK"; then
        if ! _write_cache "$ADM_CACHE_FILE"; then
            warn "Failed to write cache to $ADM_CACHE_FILE"
        else
            debug "Cache written to $ADM_CACHE_FILE"
        fi
        release_lock
    else
        warn "Could not acquire cache lock to write cache"
    fi
fi

# --------------------- Apply overrides from args/environment ---------------------
# parse any --set args passed to this sourced invocation
# Note: when sourced, arguments are in $@, so we call parse_set_args with $@
parse_set_args "$@"

# Also accept ADM_... environment variable overrides (already applied by export)

# Re-validate ADM_JOBS in case override changed it
if ! [[ "$ADM_JOBS" =~ ^[0-9]+$ ]]; then
    warn "ADM_JOBS invalid after overrides ('$ADM_JOBS'), resetting to 1"
    ADM_JOBS=1
fi
if [ "$ADM_JOBS" -lt 1 ]; then ADM_JOBS=1; fi
if [ "$ADM_JOBS" -gt "$ADM_JOBS_LIMIT" ]; then
    warn "ADM_JOBS too large ($ADM_JOBS), limiting to $ADM_JOBS_LIMIT"
    ADM_JOBS=$ADM_JOBS_LIMIT
fi

# --------------------- Environment sanity checks ---------------------
# Check minimal free space
_available_mb() {
    df --output=avail -m "$ADM_ROOT" 2>/dev/null | tail -n1 || echo 0
}
if [ -d "$ADM_ROOT" ]; then
    free_mb=$(_available_mb)
    if [ "$free_mb" -lt "$ADM_MIN_FREE_MB" ]; then
        _adm_log "WARN" "Low disk space on ${ADM_ROOT}: ${free_mb}MB (< ${ADM_MIN_FREE_MB}MB)"
        if [ "$ADM_FORCE_NONFATAL" != "true" ]; then
            _die "Insufficient disk space in ${ADM_ROOT} (requires ${ADM_MIN_FREE_MB}MB)."
        fi
    fi
else
    if ! mkdir -p "$ADM_ROOT" 2>/dev/null; then
        _die "Cannot create ADM_ROOT ${ADM_ROOT}, check permissions or run as root."
    fi
fi

# Permissions check for cache/logs
if [ ! -w "$ADM_CACHE" ]; then
    warn "Cache directory $ADM_CACHE not writable; falling back to in-memory cache for this run"
fi

# Check for fatal tools (example: gcc, make)
fatal_missing_tools=()
for t in gcc make; do
    if ! command -v "$t" >/dev/null 2>&1; then
        fatal_missing_tools+=("$t")
    fi
done
if [ ${#fatal_missing_tools[@]} -gt 0 ]; then
    _adm_log "ERROR" "Missing required tools: ${fatal_missing_tools[*]}"
    if [ "$ADM_FORCE_NONFATAL" != "true" ]; then
        _die "Please install: ${fatal_missing_tools[*]}"
    else
        warn "Continuing despite missing: ${fatal_missing_tools[*]} (ADM_FORCE_NONFATAL=true)"
    fi
fi

# --------------------- Export all relevant variables ---------------------
export ADM_ROOT ADM_SCRIPTS ADM_REPO ADM_BUILD ADM_LOGS ADM_CACHE ADM_CONFIG ADM_BOOTSTRAP ADM_OUTPUT
export ADM_PROFILE ADM_DEBUG ADM_COLOR ADM_STRIP ADM_LOGLEVEL ADM_TMP ADM_MIN_FREE_MB ADM_RETRY ADM_CACHE_TTL
export ADM_NPROC ADM_JOBS
export ADM_ARCH ADM_OS ADM_DISTRO GCC_VERSION TOOL_CHECKS

# --------------------- Utility functions exposed ---------------------
print_env() {
    cat <<EOF
ADM_ROOT=${ADM_ROOT} (source)
ADM_PROFILE=${ADM_PROFILE}
ADM_JOBS=${ADM_JOBS}
ADM_NPROC=${ADM_NPROC}
ADM_ARCH=${ADM_ARCH}
ADM_OS=${ADM_OS}
ADM_DISTRO=${ADM_DISTRO}
GCC_VERSION=${GCC_VERSION}
TOOL_CHECKS=${TOOL_CHECKS}
Cache-file=${ADM_CACHE_FILE}
EOF
}

env_status() {
    echo "env: profile=${ADM_PROFILE} cache_file=${ADM_CACHE_FILE}"
    if _cache_is_valid "$ADM_CACHE_FILE"; then
        echo "env: cache=valid"
    else
        echo "env: cache=missing/expired"
    fi
}

# final debug/info
info "env.sh loaded: profile=${ADM_PROFILE} jobs=${ADM_JOBS} arch=${ADM_ARCH} distro=${ADM_DISTRO}"
