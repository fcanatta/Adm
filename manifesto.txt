MANIFESTO DO SISTEMA DE BUILD INTELIGENTE adm
======================================================


Versão: 1.0
Autor: Fernando (conceito) + assistente (organização)
Formato: texto simples
Arquivo sugerido: /usr/src/adm/MANIFESTO.txt

Este manifesto descreve:

- Objetivo do sistema
- Estrutura de diretórios 
- Formato de metadados
- Hooks e patches
- Sistema de logs
- Detecção de compiladores, linkers, linguagens e ferramentas de documentação 
- Todos os 25 scripts principais, com Função de cada um
- Fluxo geral de construção de um sistema usando esses scripts

====================================================================
1. OBJETIVO GERAL DO PROGRAMA
====================================================================

O sistema em /usr/src/adm  um ambiente de construção automatizado e inteligente
para criar, do zero, um sistema Linux tipo "Linux From Scratch" ampliado.

Objetivos:

- Construir um sistema Linux modular, híbrido e otimizado.
- Suportar múltiplas combinações:
- glibc e musl
- systemd e sysvinit e runit
- toolchains diversos (gcc/clang/llvm/etc.)
- multiplas arquiteturas (x86_64, i686, ARM, AArch64, RISC-V, etc.)
- Criar perfis de build (minimal, desktop, server, extreme(tudo no máximo para performance lto,pgo,O3,tudo), ).
- Reaproveitar builds via cache e rebuild inteligente.
- Ter logs claros, coloridos,saída personalizada na tela, com spinner e marca de conclusão (✔️ ).
- Nunca ter erros silenciosos: qualquer problema deve aparecer nos logs e no código de saída.
- Evoluir ao extremo com inteligência com um núcleo de inteligência (learning-engine + intelligence.db).

====================================================================
2. ESTRUTURA PRINCIPAL DE DIRETÓRIOS 
====================================================================

Raiz do sistema de build:

    /usr/src/adm/

Subdiretorios principais:

    /usr/src/adm/repo/
        <categoria>/<programa>/
            metadados
            patch/
                *.patch
            hook/
                pre-fetch
                post-fetch
                pre-extract
                post-extract
                pre-build
                post-build
                pre-install
                post-install
                pre-package
                post-package
                pre-uninstall 
                post-uninstall

    /usr/src/adm/scripts/
        (os 25 scripts principais e auxiliares)

    /usr/src/adm/sources/
        (fontes baixadas)

       /usr/src/adm/build/
        (?rvore de compilação, chroot, etc.)

    /usr/src/adm/cache/
        (cache binários e de fontes)

    /usr/src/adm/logs/
        (logs globais e por pacote)

    /usr/src/adm/meta/
        hardware.info
        global-env.sh
        detected-tools.info
        optimization.profile
        outros arquivos de metadados globais

    /usr/src/adm/intelligence/
        intelligence.db / knowledge.db
        README.intelligence (descrição do propósito)

    /usr/src/adm/profiles/
        (opcional) arquivos simples com listas de pacotes por perfil

====================================================================
3. METADADOS DE CADA PROGRAMA
====================================================================

Cada programa/pacote controlado pelo sistema possui um diretório:

    /usr/src/adm/repo/<categoria>/<programa>/

Dentro dele, existe um arquivo de texto simples chamado:

    metadados

Formato EXATO do arquivo metadados (uma chave por linha):

    name: <nome-do-programa>
    version: <versao>
    categoria: <categoria>
    run_deps: lista de dependencias de execução separadas por espaço ou none
    build_deps: lista de dependências de compilação separadas por espaço ou none
    opt_deps: lista de dependencias opcionais separadas por espaço ou none
    url: url-do-source url-do-source
    checksum: sha256:VALOR sha256:VALOR ou md5:VALOR md5:VALOR

Regras:

- Sem vírgulas, sem aspas, sem JSON, YAML, TOML, nada disso.
- Listas os valores separados por espaço.
- Se não houver dependências, usar "none".
- O resto (build system, flags, otimizações) detectado automaticamente pelos scripts.

Exemplo:

    name: kmod
    version: 33
    categoria: base
    url: https://www.kernel.org/pub/linux/utils/kernel/kmod/kmod-33.tar.xz
    checksum: sha256:4a8291e3ab9845d62c9d...
    run_deps: zlib xz openssl
    build_deps: autoconf automake libtool pkgconf
    opt_deps: none

====================================================================
4. PATCHES E HOOKS
====================================================================

Para cada programa:

    /usr/src/adm/repo/<categoria>/<programa>/patch/
        *.patch  são aplicados automaticamente.

    /usr/src/adm/repo/<categoria>/<programa>/hook/
        (todos opcionais, se existirem e forem executáveis, rodam)
        pre_fetch
        post_fetch 
        pre_extract
        post_extract
        pre_build
        post_build
        pre_install
        post_install
        pre_package
        post_package
        pre_uninstall
        post_uninstall

Comportamento:

- Falha ao aplicar patch Nao é silenciosa:
  - o build do programa é abortado
  - o patch que falhou é registrado no log
- Falha em hook tambem aborta o build, com log claro.

====================================================================
5. LOGS, CORES, SPINNER E STATUS
====================================================================

Todo o sistema usa um nucleo de log comum (funções compartilhadas), com:

Funções típicas:

    log_info  (mensagens informativas)
    log_warn  (avisos)
    log_error (erros)
    task_start "Mensagem..."  (inicia uma tarefa com spinner)
    task_ok                   (encerra spinner e mostra sinal de ??)
    task_fail                 (encerra spinner e mostra sinal de erro)

Formato padrão no terminal:

    HH:MM:SS  [TAG] Mensagem ... (com cores ANSI)

Saída esperado na tela em toda operação do programa: 

16:24:42 [0] Building apps/cpio [ 2.13 21.12] (cor parágrafo inteiro rosa bold)
spinner Parallel build using 32 jobs (cor cinza)
spinner Preparing build in src.cpio.x86.202111221.162442.7972.ryzen (cinza)
sppiner Building. Writing output to /usr/src/adm/logs/0-cpio.out (cinza)
spinner Install. In directory (caminho do diretório destdir) (em amarelo bold)
spinner Packaging. cpio v1.4 in (caminho/cpio-1.4-x86_64-1-musl-(profile).tar.zst)
(Em verde)✔️ Correct package construction e verificated cpio v1.4(Em amarelo bold)
(Verde) ✔️ 00:00:20 [0] Finished building package cpio v1.4 (rosa bold)

16:25:02 [0] Building dev/flex v2.4 [2.6.4 21.12] (rosa bold)
spinner Parallel build using 32 jobs (cinza)
spinner Reading package profile: (caminho do profile e nome)
spinner Preparing build in (caminho do diretório de trabalho)
spinner Building. Writing output to (caminho do log)
spinner Install. In directory (caminho do diretório destdir)
spinner Packaging. flex v2.4 in (caminho/flex-2.4-x86_64-1-musl-(profile).tar.zst)
(Em verde)✔️ Correct package construction e verificated flex v2.4(amarelo bold)
✔️ 00:00:06 [0] Finish building package flex v2.4 (rosa bold)


- Cores:
  - INFO: branco/cinza
  - WARN: amarelo
  - ERROR: vermelho
  - BUILD/TASK: amarelo ou ciano
  - SUCESSO: verde (✔️)
  - FALHA: vermelho (x)

Logs em arquivo:

- logs/setup-<id>.log
- logs/build-<data>-<id>.log
- logs/<categoria>-<programa>.log

Os arquivos não precisam de cor; códigos ANSI são removidos ao gravar.

Nenhum erro crítico é ignorado:
- Se um comando essencial falha, o script registra log_error e sai com código != 0.

====================================================================
6. DETECÇÃO DE COMPILADORES, LINKERS, LINGUAGENS E DOCS
====================================================================

O sistema detecta e registra, em meta/detected-tools.info, todos os tipos de:

Compiladores C/C++:

    gcc, g++
    clang, clang++
    tcc
    icc / icx (se existir)
    zig cc / zig c++

Linkers:

    ld.bfd
    ld.gold
    lld
    mold

Outras linguagens:

    rustc, cargo
    go
    zig
    javac, jar
    mcs / csc / dotnet
    python3, pip
    perl
    node, npm, pnpm, yarn
    lua
    gfortran, flang
    ghc, cabal, stack

Ferramentas de build:

    make, gmake
    ninja
    meson
    cmake
    scons
    waf

Ferramentas de documentação:

    man, info, texinfo
    doxygen
    sphinx-build
    mkdocs
    asciidoc / asciidoctor
    pandoc

Todas as detecções são gravadas em:

    /usr/src/adm/meta/detected-tools.info

E as flags de otimização recomendadas são gravadas em:

    /usr/src/adm/meta/optimization.profile

====================================================================
7. VISÃO GERAL DO FLUXO DE CONSTRUÇÃO 
====================================================================

Fluxo macro tipico para construir um sistema (resumido):

1) setup-environment.sh  
   - cria estrutura /usr/src/adm
   - gera hardware.info, global-env.sh
   - cria toda a estrutura apropriada para construir o cross-toolchain
   - faz toda a configuração para a preparação do cross-toolchain

2) log-manager.sh + learning-engine.sh  (extremamente inteligente e evoluído)
    - processam logs, aprendem. registram heurísticas e melhoram builds futuros

3) verify-dependencies.sh  
   - garante que o host possui ferramentas mínimas 
   - garante que nada serão passado do host para o sistema e nada do sistema passara para o host

4) detect-optimizations.sh  
   - detecta CPU, toolchains, linkers, linguagens, docs, tipos de constru??es 
   - gera optimization.profile + detected-tools.info

5) environment-wrapper.sh  
   - configura PATH, CFLAGS, LDFLAGS, MAKEFLAGS, etc. para os builds
   - 

6) profile-manager.sh + template-builder.sh  
   - define o perfil (desktop/server/minimal/etc.)
   - monta lista de pacotes e combina??es de libc/init/otimiza??es 

7) fetch-sources.sh + patch-engine + hooks  
   - l? metadados, baixa m?ltiplas fontes em todos os formatos git,github,gitlab,https,rsync,sourceforge,diret?rio, aplica patches, hooks de pre/post em todos os est?gios 

8) build-toolchain.sh  
   - construir binutils, gcc, libc (musl/glibc) isolado do host
   - com as flags, profiles, par?metros, seguros para n?o quebrar
   - com intelig?ncia para criar cross-toolchain e toolchain final

9) build-core-system.sh  
   - compila base do sistema (LFS estendido)
   - constr?i a base do sistema

10) build-init-systems.sh + unify-libs.sh + unify-inits.sh  
   - constroem e integram systemd/sysvinit e diferentes libcs

11) cache-manager.sh + build-intelligence.sh + rebuild-intelligent.sh  
    - cache bin?rio, heur?sticas, rebuild seletivo

12) package-manager.sh + update-system.sh  
    - gerenciam pacotes, atualizam componentes
    - em update olha o cache de source se tiver vers?o maior constr?i 
    - detectar toolchain e usar o script de toolchain para construir(atualizar)

13) system-health.sh + test-suite.sh  
    - checam integridade, rodam testes, QEMU/chroot

14) snapshot-system.sh  
    - gera ISO/IMG/TAR.XZ reprodut?veis 
    - dos stages, ou sistema inteiro

15) cli-interface.sh + finalize-system.sh  
    - fun??es de interface com o usuário e finalização do build
    - comandos de informações sobre programa, procura por programa
    - todos os comandos e parâmetros de todos os scripts
    - help com todos os comandos e parâmetros 
    - menu tui bonito com a logo do adm com cores 
    - adm quando chamado sem parâmetros exibe logo adm colorida

====================================================================
8. LISTA COMPLETA DOS 25 SCRIPTS E SUAS FUNÇÕES 
====================================================================

A seguir, cada script principal do sistema e seus papéis.

------------------------------------------------------------
1) setup-environment.sh (evoluído e inteligente)
------------------------------------------------------------
Função:
- Inicializar toda a estrutura /usr/src/adm.
- Criar diretórios: repo, scripts, sources, build, cache, logs, meta, intelligence, profiles.
- Validar permissões de escrita.
- Verificar ferramentas mínimas do host.
- Gerar meta/hardware.info (CPU, memória, arquitetura, kernel).
- Gerar meta/global-env.sh com vari?veis globais.
- Gera todos os perfis

Erros:
- Falta de permiss?o.
- Falta de ferramentas essenciais.
- Problemas ao criar diret?rios ou arquivos.
- Nenhum erro é silencioso.

------------------------------------------------------------
2) log-manager.sh (inteligente)
------------------------------------------------------------
Fun??o:
- Centralizar e organizar logs do sistema:
  - logs globais
  - logs por pacote
  - resumos por dia ou por build
  - gerar sumários de erros, tempos de build, etc.

Erros:
- Problemas de escrita em disco ou acesso a logs s?o reportados, nunca ignorados.

------------------------------------------------------------
3) verify-dependencies.sh (evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Confirmar que o sistema host possui todas as depend?ncias m?nimas para o build:
  compiladores, ferramentas b?sicas, utilit?rios fundamentais.
- Criar relat?rio em logs/deps-report.txt.
- Avisar claramente o que est? faltando.

Erros:
- Qualquer depend?ncia essencial faltando gera erro expl?cito.

------------------------------------------------------------
4) fetch-sources.sh (evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Ler metadados de cada programa (name, version, url, checksum, deps).
- M?ltiplos downloads e em paralelo git,gitlab,github,rsync,ftp,https,sourceforge,diret?rio 
- Baixar tarballs/arquivos de fonte para sources/.
- Validar checksum (sha256 ou md5).
- extrair em todos os formatos com otimiza??es 
- Extrair conte?do para build/<categoria>/<programa>.
- Chamar hooks: pre-fetch, post-fetch, pre-extract, post-extract.
- Integrar-se com patch-engine.sh para aplicar patches.

Erros:
- Falha de download, checksum inv?lido, falha na extra??o, patch ou hook:
  sempre com erro claro e build interrompido.

------------------------------------------------------------
5) detect-optimizations.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Detectar hardware:
  - CPU, instru??es suportadas, n?mero de cores.
- Detectar todos os tipos compiladores, linkers, linguagens, ferramentas de docs.
- Definir flags de otimiza??o (CFLAGS, CXXFLAGS etc.) baseadas em hardware.
- Gerar meta/detected-tools.info.
- Gerar meta/optimization.profile.

Erros:
- Aus?ncia total de compilador C ou linker gera falha imediata, sem continuar.

------------------------------------------------------------
6) build-intelligence.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- C?rebro da constru??o:
  - coordenar ordem de build de pacotes.
  - analisar falhas e ajustar flags (ex.: reduzir de -O3 para -O2, desativar LTO).
  - decidir reconstru??es necess?rias.
- Alimentar intelligence.db com:
  - tempos de compila??o,
  - flags usadas,
  - falhas e solu??es,
  - depend?ncias reais detectadas.

Erros:
- Detec??o de ciclos de depend?ncias.
- Falhas ao ler/gravar intelig?ncia.
- Nunca ignorar problemas.

------------------------------------------------------------
7) build-toolchain.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Construir toolchain isolado:
  - binutils,
  - gcc,
  - libc (glibc/musl conforme perfil).
- Suportar multilib/cross-compiling se desejado.
- Integrar com environment-wrapper para exportar PATH correto para o toolchain.

Erros:
- Falha em qualquer etapa do toolchain interrompe o processo, com logs detalhados.

------------------------------------------------------------
8) build-core-system.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Construir o conjunto de pacotes base do sistema (similar ao LFS base):
  bash, coreutils, sed, grep, gawk, util-linux, zlib, xz etc.
- Aplicar flags de otimiza??o do optimization.profile.
- Integrar com cache-manager e intelig?ncia.
- continuar do ?ltimo programa constru?do com sucesso

Erros:
- Falha em qualquer pacote base registrada claramente com nome do pacote e logs.

------------------------------------------------------------
9) build-init-systems.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Construir e configurar:
  - systemd
  - sysvinit
  - runit
  - ou ambos, conforme perfil.
- Configurar servi?os b?sicos (logging, networking m?nimo, etc.).

Erros:
- Falhas espec?ficas em init geram logs dedicados.
- Se ambos forem constru?dos, garantir de forma inteligente que n?o entrem em conflito.
- e se quiser trocar de init depois garantir que n?o precise reconstruir todo o sistema s? o necess?rio de forma inteligente 

------------------------------------------------------------
10) profile-manager.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Gerenciar perfis de build:
  - minimal
  - desktop
  - server
  - embedded
  - extreme (tudo no m?ximo para performance lto,pgo,03....)
- Traduzir o perfil em:
  - tipo de libc,
  - tipo de init,
  - n?vel padr?o de otimiza??o,
  - conjunto de pacotes recomendados.
  - conjunto de pacotes recomendado para o perfil extreme

Erros:
- Perfil inexistente ou inv?lido gera erro claro.

------------------------------------------------------------
11) template-builder.sh (evolu?do ao extremo e inteligente)
------------------------------------------------------------
Fun??o:
- Permitir cria??o de perfis din?micos a partir de templates.
- Exemplo: template que gera perfis como:
  - glibc+systemd
  - musl+sysvinit
  - desktop-leve, etc.
  - glibc+sysvinit+extreme

Erros:
- Templates mal formados ou incompat?veis geram log com detalhes.

------------------------------------------------------------
12) unify-libs.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Ajudar a coexist?ncia de m?ltiplas libcs (glibc/musl) e m?ltiplas arquiteturas.
- Organizar diret?rios de bibliotecas.
- Criar symlinks, wrappers e ajustar vari?veis de ambiente relacionadas a libs.

Erros:
- Qualquer incoer?ncia na unifica??o (libs sobrepostas, conflitos) gera erro
  e impede follow-up sem corre??o.

------------------------------------------------------------
13) unify-inits.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Harmonizar differences entre systemd e sysvinit e runit.
- Criar camada de compatibilidade para servi?os comuns (rede, log, etc.).
- Permitir altern?ncia de init sem recompilar o sistema inteiro, se poss?vel.

Erros:
- Conflitos entre scripts de servi?o s?o logados e bloqueiam conclus?o da unifica??o.

------------------------------------------------------------
14) environment-wrapper.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Centralizar configura??o de vari?veis de ambiente globais:
  PATH, CFLAGS, CXXFLAGS, LDFLAGS, MAKEFLAGS, etc.
- Usar info de:
  - detected-tools.info
  - optimization.profile
  - toolchain instalado

Erros:
- Toolchain inexistente ou inv?lido gera erro claro.

------------------------------------------------------------
15) cache-manager.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Gerenciar cache de pacotes:
  - bin?rios compilados
  - fontes baixadas
  - detectar novas fontes com vers?es novas para atualizar
- Decidir se um pacote pode ser reutilizado ,atualizado ou precisa ser rebuildado.

Erros:
- Cache corrompido ou incoerente deve ser invalidado, com aviso.

------------------------------------------------------------
16) rebuild-intelligent.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Recompilar somente o necess?rio depois de mudan?as:
  - altera??es de flags
  - altera??es de um pacote base
- Usar o grafo de depend?ncias real (coletado por intelig?ncia) para saber
  quais pacotes dependem de qual.

Erros:
- Problemas de consist?ncia no grafo ou rebuild parcial s?o logados sem sil?ncio.

------------------------------------------------------------
17) patch-engine.sh (evolu?do ? inteligente)
------------------------------------------------------------
Função:
- N?cleo que aplica patches de:
  /repo/<categoria>/<programa>/patch/*.patch
- Ordena patches por nome.
- e tenta p0,p1,p2
- Aplica antes da compila??o.

Erros:
- Falha em patch = build abortado com log.

------------------------------------------------------------
18) package-manager.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Função:
- Gerenciar pacotes internamente:
  - instalar
  - uninstall
  - listar
  - verificar
  - exportar em tarball reprodut?vel 
- Registrar quais arquivos pertencem a qual pacote.

Erros:
- Conflitos de arquivo, estado quebrado ou pacotes incompletos aparecem em log.

------------------------------------------------------------
19) update-system.sh (extremamente evolu?do e inteligente 
------------------------------------------------------------
Função:
- Atualizar pacotes com novas vers?es.
- buscar no upstream do programa por vers?o maior
- Verificar fontes (metadados atualizados e cache de sources por vers?o maior).
- Integrar com rebuild-intelligent para reconstruir apenas o necess?rio.

Erros:
- Atualiza??o falhas podem gerar rollback e s?o logadas.

------------------------------------------------------------
20) system-health.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Função:
- Checar integridade do sistema:
  - bibliotecas ausentes
  - falta de links
  - analizar programa por vulnerabilidades 
  - testar programa pra conferir se est? funcional, se tem bug
  - depend?ncias quebradas
  - servi?os importantes
- Emitir relat?rio de sa?de.

Erros:
- Qualquer problema detectado aparece no relat?rio e nos logs.

------------------------------------------------------------
21) learning-engine.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Analisar hist?ricos de builds, falhas, tempo e flags.
- Ajustar heur?sticas e par?metros de compila??o futuros.
- Alimentar intelligence.db com dados precisos.

Erros:
- Corrup??o de dados de intelig?ncia gera aviso; o sistema recome?a 
  a aprender do zero, mas sempre avisando.

------------------------------------------------------------
22) test-suite.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Rodar baterias de testes:
  - testes unit?rios 
  - testes de integra??o 
  - testes de boot via QEMU
  - testes via chroot

Erros:
- Falha em teste ? registrada detalhadamente, com indica??o do componente afetado.

------------------------------------------------------------
23) snapshot-system.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Criar snapshots reprodut?veis do sistema e stages 1,2,3
  - ISO
  - IMG
  - TAR.XZ
  
- Atribuir um hash global ?nico.

Erros:
- Falhas na cria??o de imagem ou compress?o s?o logadas e o snapshot n?o ? marcado como v?lido.

------------------------------------------------------------
24) cli-interface.sh
------------------------------------------------------------
Fun??o:
- Fornecer interface de linha de comando para o usu?rio:

Exemplos:

    build --profile desktop --libc musl --init sysvinit firefox
    build --profile server nginx
    status
    list-packages
    list-profiles
    rebuild --changed
    snapshot --format iso
    health-check
    adm --install firefox (ele faz todo o processo e me entrega o programa funcionando)
    adm --search programa ( mostra o programa se tiver no cache,reposit?rio,metadados e se tiver instalado sinal de ?? 
    adm --info programa (mostra informa??es detalhadas do programa e se tiver instalado sinal de ?? 
    adm --uninstall programa 
    adm --fetch link (ele usa o fetch-sources.sh baixa o programa para o cache e confere o sha256 ou md5

Erros:
- Comandos inv?lidos, argumentos incorretos, perfis inexistentes:
  tudo ? informado de forma clara na sa?da.

------------------------------------------------------------
25) finalize-system.sh (extremamente evolu?do e inteligente)
------------------------------------------------------------
Fun??o:
- Fazer a limpeza final do ambiente de build.
- Gerar relat?rio completo do sistema constru?do.
- Instalar bootloader (se aplic?vel).
- Marcar o build como conclu?do e validado.
- Integrar com snapshot-system.sh para garantir que snapshot final ? consistente.

Erros:
- Qualquer falha final (bootloader, permiss?es, passos incompletos)
  ? registrada claramente e impede o sistema de ser marcado como "conclu?do".

====================================================================
9. NOTA FINAL
====================================================================

Este MANIFESTO ? a refer?ncia de alto n?vel do sistema:

- Define a responsabilidade de cada script.
- Define o formato m?nimo de metadados.
- Define a estrutura de diret?rios.
- Define o comportamento de logs e detec??o.
- Define que ERROS NUNCA podem ser silenciosos.

Qualquer evolu??o futura deve manter:

- Simplicidade no metadado.
- Organiza??o em /usr/src/adm.
- Coer?ncia com este documento.
- Organizar todos os scripts por ordem logica de cria??o dos scripts para n?o ter que refazer depois por conta de compatibilidadee fun??es.


Modelo de metadados 

name: <nome-do-programa>
version: <versao>
categoria: <categoria>
run_deps: lista de deps de execu??o separadas por espa?o ou none
build_deps: lista de deps de compila??o separadas por espa?o ou none
opt_deps: lista de deps opcionais separadas por espa?o ou none
url: url-do-source url-do-source url-do-source
checksum: sha256:VALOR sha256:VALOR ou md5:VALOR md5:VALOR

Observação metadados somente isso e nada mais.