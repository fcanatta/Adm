#!/usr/bin/env bash
# adm - Simple package manager for Linux From Scratch style systems
# Features:
#  - Build/install/remove packages defined as shell recipes
#  - Binary cache (.tar.zst and .tar.xz)
#  - Source cache and parallel downloads
#  - Dependency resolution with Kahn-style topological sort and cycle detection
#  - DESTDIR support and manifest-based uninstall
#  - Simple upgrade mechanism based on recipe-provided upstream version
#  - Optional chroot build helper
#
# NOTE:
#  Este script é um framework genérico. Cada pacote precisa de um "recipe"
#  em shell que define como baixar, compilar e instalar o programa.
#  Ver comentários em ADM_RECIPES_DIR mais abaixo.

set -euo pipefail

ADM_VERSION="0.1.0"

# -------------------------------------------------------------
# Configuração básica (pode ser sobrescrita por variáveis de ambiente)
# -------------------------------------------------------------
ADM_PREFIX="${ADM_PREFIX:-/usr}"
ADM_STATE_DIR="${ADM_STATE_DIR:-/var/lib/adm}"
ADM_CACHE_DIR="${ADM_CACHE_DIR:-$ADM_STATE_DIR/cache}"
ADM_SRC_CACHE="${ADM_SRC_CACHE:-$ADM_CACHE_DIR/src}"
ADM_BIN_CACHE="${ADM_BIN_CACHE:-$ADM_CACHE_DIR/bin}"
ADM_BUILD_ROOT="${ADM_BUILD_ROOT:-/var/tmp/adm/build}"
ADM_LOG_DIR="${ADM_LOG_DIR:-/var/log/adm}"
ADM_DB_DIR="${ADM_DB_DIR:-$ADM_STATE_DIR/db}"
ADM_MANIFEST_DIR="${ADM_MANIFEST_DIR:-$ADM_DB_DIR/manifests}"
ADM_META_DIR="${ADM_META_DIR:-$ADM_DB_DIR/meta}"
ADM_RECIPES_DIR="${ADM_RECIPES_DIR:-$ADM_STATE_DIR/recipes}"
ADM_DL_JOBS="${ADM_DL_JOBS:-4}"
ADM_CHROOT_DIR="${ADM_CHROOT_DIR:-}"   # opcional, para builds em chroot
ADM_DEFAULT_COMPRESS="${ADM_DEFAULT_COMPRESS:-zst}" # zst ou xz

umask 022

# -------------------------------------------------------------
# Cores
# -------------------------------------------------------------
if [[ -t 1 && -z "${NO_COLOR:-}" ]]; then
  C_RESET=$'\033[0m'
  C_RED=$'\033[31m'
  C_GREEN=$'\033[32m'
  C_YELLOW=$'\033[33m'
  C_BLUE=$'\033[34m'
  C_MAGENTA=$'\033[35m'
  C_CYAN=$'\033[36m'
else
  C_RESET=""; C_RED=""; C_GREEN=""; C_YELLOW=""; C_BLUE=""; C_MAGENTA=""; C_CYAN=""
fi

log_info()  { printf '%s[INFO]%s %s\n'  "$C_GREEN" "$C_RESET" "$*" >&2; }
log_warn()  { printf '%s[WARN]%s %s\n'  "$C_YELLOW" "$C_RESET" "$*" >&2; }
log_error() { printf '%s[ERRO]%s %s\n'  "$C_RED" "$C_RESET" "$*" >&2; }
log_debug() { [[ -n "${ADM_DEBUG:-}" ]] && printf '%s[DBG ]%s %s\n' "$C_CYAN" "$C_RESET" "$*" >&2 || true; }

die() {
  log_error "$*"
  exit 1
}

dry_run_enabled() {
  case "${ADM_DRY_RUN:-0}" in
    1|true|yes|on|ON|TRUE)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

# -------------------------------------------------------------
# Inicialização de diretórios
# -------------------------------------------------------------
init_dirs() {
  for d in \
    "$ADM_STATE_DIR" "$ADM_CACHE_DIR" "$ADM_SRC_CACHE" "$ADM_BIN_CACHE" \
    "$ADM_BUILD_ROOT" "$ADM_LOG_DIR" "$ADM_DB_DIR" \
    "$ADM_MANIFEST_DIR" "$ADM_META_DIR" "$ADM_RECIPES_DIR"; do
    if [[ ! -d "$d" ]]; then
      mkdir -p "$d" || die "Não foi possível criar diretório: $d"
    fi
  done
}

# -------------------------------------------------------------
# Tratamento de erros
# -------------------------------------------------------------
cleanup_build() {
  local builddir="${ADM_CURRENT_BUILD_DIR:-}"
  if [[ -n "$builddir" && -d "$builddir" ]]; then
    log_debug "Limpando diretório de build temporário: $builddir"
    rm -rf "$builddir" || log_warn "Falha ao remover $builddir"
  fi
}

on_err() {
  local exit_code=$?
  log_error "Erro inesperado (code=$exit_code). Veja logs em $ADM_LOG_DIR."
  cleanup_build
  exit "$exit_code"
}

trap on_err ERR
trap cleanup_build EXIT

# -------------------------------------------------------------
# Utilidades gerais
# -------------------------------------------------------------
ensure_cmd() {
  local cmd="$1"
  command -v "$cmd" >/dev/null 2>&1 || die "Comando obrigatório não encontrado: $cmd"
}

# Comparação de versões usando sort -V
ver_gt() {
  local a="$1"; local b="$2"
  [[ "$(printf '%s\n%s\n' "$a" "$b" | sort -V | tail -n1)" == "$a" && "$a" != "$b" ]]
}

ver_ge() {
  local a="$1"; local b="$2"
  [[ "$(printf '%s\n%s\n' "$a" "$b" | sort -V | tail -n1)" == "$a" ]]
}

timestamp() {
  date '+%Y-%m-%d %H:%M:%S'
}

# -------------------------------------------------------------
# Localizar arquivo de recipe de um pacote em qualquer subdiretório
# Nome do pacote == nome do arquivo .sh (ex: man-pages -> man-pages.sh)
# -------------------------------------------------------------
find_recipe_file() {
  local pkg="$1"
  local recipe

  # Procura a primeira ocorrência de <pkg>.sh em qualquer subdiretório
  recipe="$(find "$ADM_RECIPES_DIR" -type f -name "$pkg.sh" -print | head -n1)"

  if [[ -z "$recipe" ]]; then
    return 1
  fi

  printf '%s\n' "$recipe"
}

# -------------------------------------------------------------
# Carregar recipe de pacote
# -------------------------------------------------------------
load_recipe() {
  local pkg="$1"
  local recipe

  # Usa find_recipe_file para suportar subdiretórios
  recipe="$(find_recipe_file "$pkg")" || die "Recipe não encontrado para pacote '$pkg' em $ADM_RECIPES_DIR"

  # Limpar variáveis antigas relacionadas a recipe
  unset PKG_NAME PKG_VERSION PKG_RELEASE PKG_DESC PKG_DEPENDS PKG_SOURCES \
        PKG_BUILD_DIR PKG_LICENSE PKG_URL PKG_SHA256S PKG_MD5S PKG_GROUPS
  unset pkg_prepare pkg_build pkg_check pkg_install pkg_upstream_version

  # shellcheck source=/dev/null
  . "$recipe"

  [[ -n "${PKG_NAME:-}" ]] || die "Recipe $recipe não define PKG_NAME"
  [[ -n "${PKG_VERSION:-}" ]] || die "Recipe $recipe não define PKG_VERSION"
  [[ "$(basename "$PKG_NAME")" == "$pkg" ]] || :
}

# -------------------------------------------------------------
# Banco de dados / metadados
# -------------------------------------------------------------
meta_file_for() {
  local pkg="$1"
  printf '%s/%s.meta' "$ADM_META_DIR" "$pkg"
}

is_installed() {
  local pkg="$1"
  [[ -f "$(meta_file_for "$pkg")" ]]
}

get_installed_version() {
  local pkg="$1"
  local meta
  meta="$(meta_file_for "$pkg")"
  [[ -f "$meta" ]] || return 1
  awk -F= '$1=="version"{print $2}' "$meta"
}

write_meta() {
  local pkg="$1" version="$2" release="$3" deps="$4"
  local meta
  meta="$(meta_file_for "$pkg")"
  {
    printf 'name=%s\n' "$pkg"
    printf 'version=%s\n' "$version"
    printf 'release=%s\n' "$release"
    printf 'depends=%s\n' "$deps"
    printf 'installed_at=%s\n' "$(timestamp)"
  } >"$meta.tmp"
  mv "$meta.tmp" "$meta"
}

manifest_file_for() {
  local pkg="$1"
  printf '%s/%s.manifest' "$ADM_MANIFEST_DIR" "$pkg"
}

list_installed() {
  if [[ ! -d "$ADM_META_DIR" ]]; then
    return 0
  fi
  for f in "$ADM_META_DIR"/*.meta; do
    [[ -e "$f" ]] || continue
    basename "${f%.meta}"
  done | sort
}

# -------------------------------------------------------------
# Download de fontes (com cache e paralelismo)
# -------------------------------------------------------------
download_one() {
  local url="$1"
  local dest="$2"
  local sha256="$3"
  local md5="$4"

  # Tenta no máximo duas vezes: download + (se necessário) redownload
  local attempt
  for attempt in 1 2; do
    if (( attempt == 2 )); then
      log_warn "Nova tentativa de download para $(basename "$dest")..."
    fi

    if [[ -f "$dest" ]]; then
      log_debug "Fonte já em cache: $dest"
    else
      log_info "Baixando fonte: $url -> $dest"

      case "$url" in
        git+*|git://*|*.git)
          ensure_cmd git
          local tmp_dir="${dest}.git-tmp"
          rm -rf "$tmp_dir"
          git clone --depth 1 "${url#git+}" "$tmp_dir"
          ( cd "$tmp_dir" && git archive --format=tar --output="$dest" HEAD )
          rm -rf "$tmp_dir"
          ;;
        http://*|https://*|ftp://*)
          if command -v curl >/dev/null 2>&1; then
            curl -L --fail --retry 3 -o "$dest" "$url"
          elif command -v wget >/dev/null 2>&1; then
            wget -O "$dest" "$url"
          else
            die "Nem curl nem wget encontrados para baixar: $url"
          fi
          ;;
        rsync://*)
          ensure_cmd rsync
          rsync -av "$url" "$dest"
          ;;
        *)
          die "Esquema de URL não suportado: $url"
          ;;
      esac
    fi

    # -----------------------------------------
    # Verificação de SHA256, se fornecido
    # -----------------------------------------
    if [[ -n "$sha256" ]]; then
      log_info "Verificando SHA256 de $(basename "$dest")"
      local calc_sha
      calc_sha="$(sha256sum "$dest" | awk '{print $1}')"

      if [[ "$calc_sha" != "$sha256" ]]; then
        log_warn "SHA256 incorreto para $(basename "$dest"). Esperado: $sha256 Obtido: $calc_sha"
        log_warn "Removendo para tentar baixar novamente..."
        rm -f "$dest"
        continue
      fi
    fi

    # -----------------------------------------
    # Verificação de MD5, se fornecido
    # -----------------------------------------
    if [[ -n "$md5" ]]; then
      log_info "Verificando MD5 de $(basename "$dest")"
      local calc_md5
      calc_md5="$(md5sum "$dest" | awk '{print $1}')"

      if [[ "$calc_md5" != "$md5" ]]; then
        log_warn "MD5 incorreto para $(basename "$dest"). Esperado: $md5 Obtido: $calc_md5"
        log_warn "Removendo para tentar baixar novamente..."
        rm -f "$dest"
        continue
      fi
    fi

    # Se chegou aqui, passou em todas as checagens
    return 0
  done

  die "Falha ao baixar/verificar $(basename "$dest") após duas tentativas."
}

download_sources_parallel() {
  local -a urls=("$@")
  local -a sha256s md5s
  local -a pids=()
  local -i running=0
  local -i idx=0

  mkdir -p "$ADM_SRC_CACHE"

  # Transforma PKG_SHA256S / PKG_MD5S (string) em arrays alinhados
  IFS=' ' read -r -a sha256s <<< "${PKG_SHA256S:-}"
  IFS=' ' read -r -a md5s    <<< "${PKG_MD5S:-}"

  for url in "${urls[@]}"; do
    [[ -n "$url" ]] || { ((idx++)); continue; }

    local filename dest sha md5
    filename="$(basename "${url%%\?*}")"
    dest="$ADM_SRC_CACHE/$filename"
    sha="${sha256s[$idx]:-}"
    md5="${md5s[$idx]:-}"

    (
      set -e
      download_one "$url" "$dest" "$sha" "$md5"
    ) &
    pids+=("$!")
    ((running++))

    if (( running >= ADM_DL_JOBS )); then
      # Espera todos terminarem antes de continuar
      local pid failed=0
      for pid in "${pids[@]}"; do
        if ! wait "$pid"; then
          failed=1
        fi
      done
      pids=()
      running=0
      (( failed == 0 )) || die "Falha em pelo menos um download de fonte."
    fi

    ((idx++))
  done

  # Espera os últimos downloads, se sobrou algo rodando
  if (( running > 0 )); then
    local pid failed=0
    for pid in "${pids[@]}"; do
      if ! wait "$pid"; then
        failed=1
      fi
    done
    (( failed == 0 )) || die "Falha em pelo menos um download de fonte."
  fi
}

# -------------------------------------------------------------
# Extração de fontes
# -------------------------------------------------------------
extract_src() {
  local archive="$1"
  local dest_dir="$2"

  [[ -f "$archive" ]] || die "Arquivo de fonte não encontrado: $archive"

  mkdir -p "$dest_dir"

  log_info "Extraindo $archive em $dest_dir"

  case "$archive" in
    *.tar.gz|*.tgz)    tar -xzf "$archive" -C "$dest_dir" ;;
    *.tar.bz2|*.tbz2)  tar -xjf "$archive" -C "$dest_dir" ;;
    *.tar.xz)          tar -xJf "$archive" -C "$dest_dir" ;;
    *.tar.zst|*.tzst)  ensure_cmd zstd; tar --zstd -xf "$archive" -C "$dest_dir" ;;
    *.tar.lz)          ensure_cmd lzip; tar --lzip -xf "$archive" -C "$dest_dir" ;;
    *.zip)             ensure_cmd unzip; unzip -q "$archive" -d "$dest_dir" ;;
    *.gz)              gunzip -c "$archive" | tar -xf - -C "$dest_dir" ;;
    *.bz2)             bunzip2 -c "$archive" | tar -xf - -C "$dest_dir" ;;
    *.xz)              xz -dc "$archive" | tar -xf - -C "$dest_dir" ;;
    *.7z)              ensure_cmd 7z; 7z x "$archive" -o"$dest_dir" ;;
    *)
      die "Formato de arquivo não suportado: $archive"
      ;;
  esac
}

# -------------------------------------------------------------
# Construção do pacote
# -------------------------------------------------------------
build_pkg() {
  local pkg="$1"
  load_recipe "$pkg"

  local builddir destdir
  builddir="$ADM_BUILD_ROOT/$pkg-$$"
  destdir="$builddir/dest"
  ADM_CURRENT_BUILD_DIR="$builddir"

  mkdir -p "$builddir" "$destdir"

  log_info "Construindo pacote $pkg (versão $PKG_VERSION)"

  # 1) Baixar fontes
  IFS=' ' read -r -a srcs <<< "${PKG_SOURCES:-}"
  if (( ${#srcs[@]} > 0 )); then
    download_sources_parallel "${srcs[@]}"
  else
    log_warn "Recipe $pkg não define PKG_SOURCES; assumindo fonte já disponível."
  fi

  # 2) Extração (assume primeiro arquivo como principal)
  local src_main src_archive
  if (( ${#srcs[@]} > 0 )); then
    src_main="${srcs[0]}"
    src_archive="$ADM_SRC_CACHE/$(basename "${src_main%%\?*}")"
    extract_src "$src_archive" "$builddir"
  fi

  # 3) Encontrar diretório de build (primeiro subdir criado)
  local srcdir
  srcdir="$(find "$builddir" -mindepth 1 -maxdepth 1 -type d ! -name dest | head -n1 || true)"
  [[ -n "$srcdir" ]] || srcdir="$builddir"

  # 4) Executar etapas de build definidas pela recipe
  (
    cd "$srcdir"

    if declare -f pkg_prepare >/dev/null 2>&1; then
      log_info "Etapa: prepare()"
      pkg_prepare
    fi

    if declare -f pkg_build >/dev/null 2>&1; then
      log_info "Etapa: build()"

      # Se ADM_JOBS estiver definido (ex: 8), usa make -j8 via MAKEFLAGS
      if [[ -n "${ADM_JOBS:-}" ]]; then
        export MAKEFLAGS="-j${ADM_JOBS}"
        log_info "Usando MAKEFLAGS=$MAKEFLAGS"
      fi

      PKG_DESTDIR="$destdir" PKG_PREFIX="$ADM_PREFIX" pkg_build
    else
      die "Recipe $pkg não define função pkg_build()"
    fi

    if declare -f pkg_check >/dev/null 2>&1; then
      log_info "Etapa: check()"
      pkg_check
    fi

    if declare -f pkg_install >/dev/null 2>&1; then
      log_info "Etapa: install() para DESTDIR=$destdir"
      PKG_DESTDIR="$destdir" PKG_PREFIX="$ADM_PREFIX" pkg_install
    else
      # fallback genérico: tentar "make install"
      if [[ -f Makefile || -f makefile ]]; then
        log_warn "pkg_install() não definido; tentando 'make DESTDIR=$destdir install'"
        make DESTDIR="$destdir" install
      else
        die "Sem pkg_install() e sem Makefile para instalar $pkg"
      fi
    fi
  )

  # 5) Criar pacote binário e manifest
  package_from_destdir "$pkg" "$PKG_VERSION" "${PKG_RELEASE:-1}" "$destdir"

  # 6) Instalar imediatamente
  install_from_cache "$pkg" "$PKG_VERSION" "${PKG_RELEASE:-1}"

  cleanup_build
  ADM_CURRENT_BUILD_DIR=""
}

# -------------------------------------------------------------
# Empacotamento e cache binário
# -------------------------------------------------------------
bin_pkg_filename() {
  local pkg="$1" version="$2" release="$3" ext="$4"
  local arch
  arch="$(uname -m)"
  printf '%s-%s-%s-%s.tar.%s' "$pkg" "$version" "$release" "$arch" "$ext"
}

package_from_destdir() {
  local pkg="$1" version="$2" release="$3" destdir="$4"
  [[ -d "$destdir" ]] || die "DESTDIR não existe: $destdir"

  mkdir -p "$ADM_BIN_CACHE"

  ensure_cmd zstd
  ensure_cmd xz

  local fname_zst fname_xz
  fname_zst="$(bin_pkg_filename "$pkg" "$version" "$release" "zst")"
  fname_xz="$(bin_pkg_filename "$pkg" "$version" "$release" "xz")"

  ( cd "$destdir" && tar -cf - . ) | zstd -19 -T0 -o "$ADM_BIN_CACHE/$fname_zst"
  ( cd "$destdir" && tar -cf - . ) | xz -T0 -9 -c > "$ADM_BIN_CACHE/$fname_xz"

  log_info "Pacotes criados:"
  log_info "  $ADM_BIN_CACHE/$fname_zst"
  log_info "  $ADM_BIN_CACHE/$fname_xz"

  # Gera manifesto com SHA256 (se sha256sum estiver disponível)
  local manifest
  manifest="$(manifest_file_for "$pkg")"

  if command -v sha256sum >/dev/null 2>&1; then
    log_info "Gerando manifesto com SHA256 em $manifest"
    (
      cd "$destdir" || exit 1
      # Apenas arquivos regulares e links simbólicos; diretórios serão tratados via dirname
      find . -mindepth 1 \( -type f -o -type l \) -print0 \
        | sort -z \
        | xargs -0 -r sha256sum \
        | sed 's#  \./#  /#' >"$manifest"
    )
  else
    log_warn "sha256sum não encontrado; gerando manifesto sem hashes."
    ( cd "$destdir" && find . -mindepth 1 -printf '/%P\n' | sort ) >"$manifest"
  fi
}

# -------------------------------------------------------------
# Instalação a partir do cache binário
# -------------------------------------------------------------
install_from_cache() {
  local pkg="$1" version="$2" release="$3"
  local arch
  arch="$(uname -m)"

  local fname_zst fname_xz
  fname_zst="$ADM_BIN_CACHE/$(bin_pkg_filename "$pkg" "$version" "$release" "zst")"
  fname_xz="$ADM_BIN_CACHE/$(bin_pkg_filename "$pkg" "$version" "$release" "xz")"

  local chosen=""
  case "$ADM_DEFAULT_COMPRESS" in
    zst) [[ -f "$fname_zst" ]] && chosen="$fname_zst" || chosen="$fname_xz" ;;
    xz)  [[ -f "$fname_xz" ]] && chosen="$fname_xz" || chosen="$fname_zst" ;;
    *)   chosen="$fname_zst" ;;
  esac

  [[ -f "$chosen" ]] || die "Pacote binário não encontrado para $pkg versão $version-$release"

  log_info "Instalando $pkg-$version-$release a partir de $chosen"

  case "$chosen" in
    *.tar.zst|*.tzst) tar --zstd -xf "$chosen" -C / ;;
    *.tar.xz)         tar -xJf "$chosen" -C / ;;
    *)                die "Formato de pacote binário desconhecido: $chosen" ;;
  esac

  write_meta "$pkg" "$version" "$release" "${PKG_DEPENDS:-}"
}

reverse_deps() {
  local target="$1"
  local meta name depends dep

  # Lista pacotes que dependem de $target, lendo todos os .meta
  for meta in "$ADM_META_DIR"/*.meta; do
    [[ -e "$meta" ]] || continue

    name=""
    depends=""

    while IFS='=' read -r key value; do
      case "$key" in
        name)    name="$value" ;;
        depends) depends="$value" ;;
      esac
    done < "$meta"

    # pula o próprio pacote
    [[ "$name" == "$target" ]] && continue

    # vê se $target está na lista de depends
    for dep in $depends; do
      if [[ "$dep" == "$target" ]]; then
        echo "$name"
        break
      fi
    done
  done
}

# -------------------------------------------------------------
# Remoção via manifesto
# -------------------------------------------------------------
remove_pkg() {
  local pkg="$1"
  local manifest
  manifest="$(manifest_file_for "$pkg")"

  [[ -f "$manifest" ]] || die "Manifesto não encontrado para $pkg"

  log_info "Removendo arquivos de $pkg usando manifesto $manifest"

  # Remove arquivos
  local line path
  while IFS= read -r line; do
    [[ -n "$line" ]] || continue

    # Manifesto pode ter formato:
    #   /caminho
    # ou
    #   SHA256  /caminho
    set -- $line
    if [[ "$1" == /* ]]; then
      path="$1"
    else
      path="$2"
    fi

    if [[ -e "$path" || -L "$path" ]]; then
      rm -f "$path" || log_warn "Falha ao remover $path"
    else
      log_debug "Arquivo já ausente: $path"
    fi
  done <"$manifest"

  # Tenta remover diretórios vazios
  log_info "Removendo diretórios vazios residuais"
  tac "$manifest" | while IFS= read -r line; do
    [[ -n "$line" ]] || continue

    set -- $line
    if [[ "$1" == /* ]]; then
      path="$1"
    else
      path="$2"
    fi

    local dir
    dir="$(dirname "$path")"
    [[ "$dir" == "/" || "$dir" == "." ]] && continue
    if [[ -d "$dir" ]]; then
      rmdir "$dir" 2>/dev/null || true
    fi
  done

  rm -f "$manifest"
  rm -f "$(meta_file_for "$pkg")"

  log_info "Pacote $pkg removido."
}

cmd_verify() {
  local pkg="$1"
  local manifest
  manifest="$(manifest_file_for "$pkg")"
  local meta
  meta="$(meta_file_for "$pkg")"

  if [[ ! -f "$manifest" ]]; then
    die "Manifesto não encontrado para $pkg em $manifest"
  fi

  if [[ ! -f "$meta" ]]; then
    log_warn "Meta de instalação não encontrada para $pkg em $meta"
  fi

  log_info "Verificando arquivos do pacote $pkg (manifesto: $manifest)"

  local missing=0 mismatched=0
  local line path hash

  while IFS= read -r line; do
    [[ -n "$line" ]] || continue

    # Linha pode ser:
    #   /caminho
    #   SHA256  /caminho
    set -- $line
    hash=""
    if [[ "$1" == /* ]]; then
      path="$1"
    elif [[ "$1" =~ ^[0-9a-fA-F]{64}$ && "$2" == /* ]]; then
      hash="$1"
      path="$2"
    else
      # formato inesperado; assume linha inteira como caminho
      path="$line"
    fi

    if [[ ! -e "$path" && ! -L "$path" ]]; then
      log_warn "Arquivo ausente: $path"
      missing=1
      continue
    fi

    if [[ -n "$hash" ]] && command -v sha256sum >/dev/null 2>&1; then
      local calc
      calc="$(sha256sum "$path" | awk '{print $1}')"
      if [[ "$calc" != "$hash" ]]; then
        log_warn "SHA256 divergente para $path (esperado=$hash, calculado=$calc)"
        mismatched=1
      else
        log_debug "OK (hash): $path"
      fi
    else
      log_debug "OK (existência): $path"
    fi
  done <"$manifest"

  if (( missing == 0 && mismatched == 0 )); then
    log_info "Verificação concluída: todos os arquivos de $pkg existem e (quando disponível) SHA256 confere."
    return 0
  else
    log_warn "Verificação concluída: problemas detectados em $pkg (missing=$missing, mismatched=$mismatched)"
    return 1
  fi
}

cmd_verify_all() {
  log_info "Verificando todos os pacotes instalados..."

  local -a pkgs=()
  mapfile -t pkgs < <(list_installed)

  if (( ${#pkgs[@]} == 0 )); then
    log_info "Nenhum pacote instalado para verificar."
    return 0
  fi

  local pkg failed=0
  for pkg in "${pkgs[@]}"; do
    [[ -n "$pkg" ]] || continue
    log_info "=== $pkg ==="
    if ! cmd_verify "$pkg"; then
      failed=1
    fi
  done

  if (( failed == 0 )); then
    log_info "Verificação geral concluída: todos os pacotes passaram."
  else
    log_warn "Verificação geral concluída: existem pacotes com problemas."
  fi

  return $failed
}

# -------------------------------------------------------------
# Resolução de dependências e ordenação (Kahn-like)
# -------------------------------------------------------------
pkg_deps() {
  local pkg="$1"
  load_recipe "$pkg"
  printf '%s\n' "${PKG_DEPENDS:-}" | tr ' ' '\n' | sed '/^$/d' | sort -u
}

# -------------------------------------------------------------
# Listar pacotes que pertencem a um grupo/categoria
# (usa PKG_GROUPS definido em cada recipe)
# -------------------------------------------------------------
pkgs_in_group() {
  local group="$1"
  local f

  local needle=" $group "

  # Procura todas as recipes .sh em qualquer subdiretório
  while IFS= read -r f; do
    [[ -f "$f" ]] || continue

    (
      unset PKG_NAME PKG_GROUPS
      # shellcheck source=/dev/null
      . "$f"
      local name="${PKG_NAME:-}"
      local groups=" ${PKG_GROUPS:-} "
      if [[ -n "$name" && "$groups" == *"$needle"* ]]; then
        printf '%s\n' "$name"
      fi
    )
  done < <(find "$ADM_RECIPES_DIR" -type f -name '*.sh' | sort) | sort -u
}

# Gera ordem topológica de uma lista de pacotes
topo_sort_pkgs() {
  local -a input_pkgs=("$@")
  local -a all_pkgs=()
  local -A want
  local p

  # normalizar e único
  for p in "${input_pkgs[@]}"; do
    want["$p"]=1
  done

  # inclui dependências recursivamente
  local changed=1
  while (( changed )); do
    changed=0
    for p in "${!want[@]}"; do
      local d
      while IFS= read -r d; do
        [[ -n "$d" ]] || continue
        if [[ -z "${want[$d]:-}" ]]; then
          want["$d"]=1
          changed=1
        fi
      done < <(pkg_deps "$p")
    done
  done

  # converte para lista
  for p in "${!want[@]}"; do
    all_pkgs+=("$p")
  done

  # Ordenação aproximada por dependência (Kahn-like simplificado)
  local -a sorted=()
  local -A done
  local progress

  while (( ${#sorted[@]} < ${#all_pkgs[@]} )); do
    progress=0
    for p in "${all_pkgs[@]}"; do
      [[ -n "$p" ]] || continue
      if [[ -n "${done[$p]:-}" ]]; then
        continue
      fi
      local ok=1
      local d
      while IFS= read -r d; do
        [[ -n "$d" ]] || continue
        # se dependência faz parte do conjunto e ainda não foi feita, não pode ainda
        if [[ -n "${want[$d]:-}" && -z "${done[$d]:-}" ]]; then
          ok=0
          break
        fi
      done < <(pkg_deps "$p")
      if (( ok )); then
        sorted+=("$p")
        done["$p"]=1
        progress=1
      fi
    done

    if (( ! progress )); then
      log_error "Detecção de ciclo de dependências entre pacotes:"
      log_error "Conjunto envolvido:"
      for p in "${all_pkgs[@]}"; do
        [[ -z "${done[$p]:-}" ]] && printf '  %s\n' "$p" >&2
      done
      die "Não foi possível resolver dependências (ciclo detectado)."
    fi
  done

  printf '%s\n' "${sorted[@]}"
}

# -------------------------------------------------------------
# Atualização / upgrade
# -------------------------------------------------------------
upstream_version_for() {
  local pkg="$1"
  load_recipe "$pkg"
  if declare -f pkg_upstream_version >/dev/null 2>&1; then
    pkg_upstream_version
  else
    # Se não houver função de upstream, retorna a própria versão do recipe
    printf '%s\n' "$PKG_VERSION"
  fi
}

list_upgrades() {
  local pkg
  list_installed | while IFS= read -r pkg; do
    [[ -n "$pkg" ]] || continue
    load_recipe "$pkg" || { log_warn "Sem recipe para pacote instalado $pkg"; continue; }
    local current latest
    current="$(get_installed_version "$pkg" || echo "")"
    latest="$(upstream_version_for "$pkg")"
    if [[ -z "$current" ]]; then
      continue
    fi
    if ver_gt "$latest" "$current"; then
      printf '%s %s -> %s\n' "$pkg" "$current" "$latest"
    fi
  done
}

upgrade_list() {
  # retorna apenas nomes de pacotes com upgrade disponível
  list_upgrades | awk '{print $1}'
}

upgrade_pkgs() {
  local -a pkgs=("$@")
  if (( ${#pkgs[@]} == 0 )); then
    mapfile -t pkgs < <(upgrade_list)
  fi

  if (( ${#pkgs[@]} == 0 )); then
    log_info "Nenhum pacote para atualizar."
    return 0
  fi

  log_info "Pacotes a atualizar: ${pkgs[*]}"

  # ordena por dependências
  local -a order=()
  mapfile -t order < <(topo_sort_pkgs "${pkgs[@]}")

  if dry_run_enabled; then
    log_info "DRY-RUN: atualizaria (na ordem): ${order[*]}"
    return 0
  fi

  local p
  for p in "${order[@]}"; do
    log_info "Atualizando pacote: $p"
    build_pkg "$p"
  done
}

# -------------------------------------------------------------
# Verificar se um pacote está na versão mais recente conhecida
# (usa upstream_version_for + versão instalada)
# -------------------------------------------------------------
is_pkg_up_to_date() {
  local pkg="$1"

  # Se não está instalado, obviamente não está em dia
  if ! is_installed "$pkg"; then
    return 1
  fi

  local current latest
  current="$(get_installed_version "$pkg" || echo "")"
  latest="$(upstream_version_for "$pkg")"

  # Se algo der errado, preferimos reconstruir
  if [[ -z "$current" || -z "$latest" ]]; then
    return 1
  fi

  if ver_ge "$current" "$latest"; then
    # current >= latest
    return 0
  else
    return 1
  fi
}

build_pkg_if_needed() {
  local pkg="$1"

  if is_pkg_up_to_date "$pkg"; then
    log_info "[$pkg] já está na versão mais recente, pulando build."
  else
    log_info "[$pkg] desatualizado ou ausente, construindo..."
    build_pkg "$pkg"
  fi
}

# -------------------------------------------------------------
# Instalar pacote "do jeito certo":
# - se já instalado e atualizado -> pula
# - se instalado mas desatualizado -> rebuild
# - se não instalado:
#     - se tiver binário no cache -> instala do cache
#     - senão -> constrói (build_pkg)
# -------------------------------------------------------------
install_pkg_if_needed() {
  local pkg="$1"

  # Garante que recipe foi carregada (para PKG_VERSION/PKG_RELEASE)
  load_recipe "$pkg"
  local version="$PKG_VERSION"
  local release="${PKG_RELEASE:-1}"

  if is_installed "$pkg"; then
    if is_pkg_up_to_date "$pkg"; then
      log_info "[$pkg] já está instalado e na versão mais recente, pulando."
      return 0
    else
      local current latest
      current="$(get_installed_version "$pkg" || echo "?")"
      latest="$(upstream_version_for "$pkg" || echo "$version")"
      log_info "[$pkg] instalado, mas desatualizado (atual=$current, upstream=$latest). Rebuild..."
      build_pkg "$pkg"
      return 0
    fi
  fi

  # Não instalado ainda
  local fname_zst fname_xz arch
  arch="$(uname -m)"
  fname_zst="$ADM_BIN_CACHE/$(bin_pkg_filename "$pkg" "$version" "$release" "zst")"
  fname_xz="$ADM_BIN_CACHE/$(bin_pkg_filename "$pkg" "$version" "$release" "xz")"

  if [[ -f "$fname_zst" || -f "$fname_xz" ]]; then
    log_info "[$pkg] não instalado, mas binário encontrado no cache. Instalando do cache..."
    install_from_cache "$pkg" "$version" "$release"
  else
    log_info "[$pkg] não instalado e sem binário no cache. Construindo (build_pkg)..."
    build_pkg "$pkg"
  fi
}

# -------------------------------------------------------------
# Suporte a chroot
# -------------------------------------------------------------
chroot_build_pkg() {
  local chroot_dir="$1"; shift
  local pkg="$1"

  [[ -d "$chroot_dir" ]] || die "Diretório de chroot não existe: $chroot_dir"

  ensure_cmd chroot

  # Assumimos que o script 'adm' está disponível dentro do chroot em /usr/bin/adm
  log_info "Executando build de $pkg em chroot $chroot_dir"
  chroot "$chroot_dir" /usr/bin/env \
    ADM_PREFIX="$ADM_PREFIX" \
    ADM_STATE_DIR="$ADM_STATE_DIR" \
    ADM_CACHE_DIR="$ADM_CACHE_DIR" \
    ADM_SRC_CACHE="$ADM_SRC_CACHE" \
    ADM_BIN_CACHE="$ADM_BIN_CACHE" \
    ADM_BUILD_ROOT="$ADM_BUILD_ROOT" \
    ADM_LOG_DIR="$ADM_LOG_DIR" \
    ADM_DEFAULT_COMPRESS="$ADM_DEFAULT_COMPRESS" \
    /usr/bin/adm build "$pkg"
}

# -------------------------------------------------------------
# Ajuda
# -------------------------------------------------------------
usage() {
  cat <<EOF
${C_CYAN}adm${C_RESET} - Gerenciador simples de programas para Linux From Scratch

Uso:
  adm build <pacote|grupo>     - Construir pacote OU categoria (core, base, etc)
  adm install <p1> [p2 ...]    - Instalar pacote(s) + dependências (do cache ou construindo)
  adm remove <pacote>          - Remover pacote usando manifesto
  adm deps <pacote>            - Mostrar dependências (receta)
  adm resolve <p1> [p2 ...]    - Resolver dependências e listar em ordem (Kahn-like)
  adm list                     - Listar pacotes instalados
  adm info <pacote>            - Mostra meta + recipe do pacote
  adm verify <pacote>          - Verifica se todos os arquivos do pacote ainda existem
  adm list-upgrades            - Listar pacotes com upgrades disponíveis
  adm upgrade [p1 ...]         - Atualizar todos ou lista de pacotes
  adm chroot-build <dir> <pkg> - Fazer build dentro de um chroot existente  
  adm chroot-prepare [dir]     - Prepara o chroot (monta /dev,/proc,/sys,/run, etc.)
  adm chroot-teardown [dir]    - Desmonta os mounts do chroot
  adm chroot-shell [dir]       - Entra em um shell dentro do chroot (usa adm-chroot.sh enter)
  adm chroot-build-group <dir> <grupo>   - Constrói um grupo inteiro *dentro* do chroot
  adm version                  - Mostrar versão do adm
  adm help                     - Esta ajuda

Diretórios padrão:
  Recipes:   $ADM_RECIPES_DIR (um arquivo <nome>.sh por pacote)
  Estado:    $ADM_STATE_DIR
  Cache src: $ADM_SRC_CACHE
  Cache bin: $ADM_BIN_CACHE

Cada recipe de pacote é um script shell que deve definir, no mínimo:

  PKG_NAME="foo"
  PKG_VERSION="1.0.0"
  PKG_GROUPS="core"
  PKG_RELEASE="1"
  PKG_DEPENDS="dep1 dep2"
  PKG_SOURCES="https://exemplo.org/foo-1.0.0.tar.xz"

  pkg_build() {
    ./configure --prefix="/usr"
    make -j\$(nproc)
  }

  pkg_install() {
    make DESTDIR="\$PKG_DESTDIR" install
  }

Opcional:
  pkg_prepare()        # pré-build (patches, etc)
  pkg_check()          # testes
  pkg_upstream_version() { ... }  # ecoar versão mais nova disponível no upstream

EOF
}

# -------------------------------------------------------------
# Comandos
# -------------------------------------------------------------
cmd_build() {
  local target="$1"

  # Modo DRY-RUN: só mostra o plano de build
  if dry_run_enabled; then
    if find_recipe_file "$target" >/dev/null 2>&1; then
      # Trata como pacote único, mas expande deps com topo_sort_pkgs
      local -a order=()
      mapfile -t order < <(topo_sort_pkgs "$target")
      log_info "DRY-RUN: construiria (na ordem): ${order[*]}"
      return 0
    fi

    # Não é recipe direta: trata como grupo/categoria
    log_info "DRY-RUN: construindo categoria/grupo '$target'"
    cmd_build_group "$target"
    return 0
  fi

  # Execução normal
  # Se acharmos uma recipe com esse nome em qualquer subdiretório, tratamos como pacote
  if find_recipe_file "$target" >/dev/null 2>&1; then
    build_pkg "$target"
    return 0
  fi

  # Caso contrário, tentamos tratar como grupo/categoria
  log_info "'$target' não é uma recipe direta; tentando como categoria/grupo..."
  cmd_build_group "$target"
}

cmd_install() {
  if (( $# < 1 )); then
    die "Uso: adm install <pacote> [outro_pacote ...]"
  fi

  local -a req_pkgs=("$@")
  local -a order=()

  # Resolve dependências de todos os pacotes pedidos
  # topo_sort_pkgs já inclui deps recursivamente
  mapfile -t order < <(topo_sort_pkgs "${req_pkgs[@]}")

  log_info "Ordem de instalação (com dependências): ${order[*]}"

  if dry_run_enabled; then
    local p current latest
    for p in "${order[@]}"; do
      if is_installed "$p"; then
        current="$(get_installed_version "$p" || echo '?')"
        latest="$(upstream_version_for "$p" || echo "$current")"
        if ver_gt "$latest" "$current"; then
          log_info "DRY-RUN: reconstruiria $p (instalado: $current, upstream: $latest)"
        else
          log_info "DRY-RUN: já instalado e atualizado: $p ($current)"
        fi
      else
        latest="$(upstream_version_for "$p" || echo '?')"
        log_info "DRY-RUN: instalaria $p (upstream: $latest)"
      fi
    done
    return 0
  fi

  local p
  for p in "${order[@]}"; do
    install_pkg_if_needed "$p"
  done
}

cmd_remove() {
  local pkg="$1"
  if ! is_installed "$pkg"; then
    log_warn "Pacote $pkg não está marcado como instalado."
  fi
  remove_pkg "$pkg"
}

cmd_deps() {
  local pkg="$1"
  pkg_deps "$pkg"
}

cmd_resolve() {
  local -a pkgs=("$@")
  if (( ${#pkgs[@]} == 0 )); then
    die "Informe pelo menos um pacote para resolver dependências."
  fi
  topo_sort_pkgs "${pkgs[@]}"
}

cmd_list() {
  list_installed
}

cmd_info() {
  local pkg="$1"

  log_info "Mostrando informações sobre o pacote '$pkg'"

  local meta="$ADM_META_DIR/$pkg.meta"

  if [[ -f "$meta" ]]; then
    echo "=== Instalação atual ==="
    while IFS='=' read -r key value; do
      case "$key" in
        name)        echo "Nome instalado:    $value" ;;
        version)     echo "Versão instalada:  $value" ;;
        release)     echo "Release instalada: $value" ;;
        depends)     echo "Depende de:        $value" ;;
        installed_at)echo "Instalado em:      $value" ;;
      esac
    done < "$meta"
  else
    echo "Pacote '$pkg' não está registrado como instalado."
  fi

  echo
  echo "=== Recipe ==="
  if load_recipe "$pkg"; then
    echo "PKG_NAME:        ${PKG_NAME:-}"
    echo "PKG_VERSION:     ${PKG_VERSION:-}"
    echo "PKG_RELEASE:     ${PKG_RELEASE:-}"
    echo "PKG_DESC:        ${PKG_DESC:-}"
    echo "PKG_URL:         ${PKG_URL:-}"
    echo "PKG_LICENSE:     ${PKG_LICENSE:-}"
    echo "PKG_GROUPS:      ${PKG_GROUPS:-}"
    echo "PKG_DEPENDS:     ${PKG_DEPENDS:-}"
    echo "PKG_SOURCES:     ${PKG_SOURCES:-}"
  else
    echo "Recipe para '$pkg' não encontrada em $ADM_RECIPES_DIR."
  fi
}

cmd_verify() {
  local pkg="$1"
  local manifest
  manifest="$(manifest_file_for "$pkg")"
  local meta
  meta="$(meta_file_for "$pkg")"

  if [[ ! -f "$manifest" ]]; then
    die "Manifesto não encontrado para $pkg em $manifest"
  fi

  if [[ ! -f "$meta" ]]; then
    log_warn "Meta de instalação não encontrada para $pkg em $meta"
  fi

  log_info "Verificando arquivos do pacote $pkg (manifesto: $manifest)"

  local missing=0 line
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    if [[ -e "$line" || -L "$line" ]]; then
      log_debug "OK: $line"
    else
      log_warn "Arquivo ausente: $line"
      missing=1
    fi
  done < "$manifest"

  if (( missing )); then
    log_warn "Verificação concluída: há arquivos ausentes para $pkg"
    return 1
  else
    log_info "Verificação concluída: todos os arquivos do manifesto existem para $pkg"
  fi
}

cmd_list_upgrades() {
  list_upgrades
}

cmd_upgrade() {
  if (( $# == 0 )); then
    upgrade_pkgs
  else
    upgrade_pkgs "$@"
  fi
}

cmd_build_group() {
  local group="$1"

  log_info "Resolvendo categoria/grupo '$group'..."

  local -a pkgs
  mapfile -t pkgs < <(pkgs_in_group "$group")

  if (( ${#pkgs[@]} == 0 )); then
    die "Nenhum pacote encontrado na categoria '$group'."
  fi

  log_info "Pacotes do grupo '$group': ${pkgs[*]}"

  # Ordena com dependências (inclui deps que não estão explicitamente no grupo)
  local -a order
  mapfile -t order < <(topo_sort_pkgs "${pkgs[@]}")

  log_info "Ordem de build para grupo '$group': ${order[*]}"

  if dry_run_enabled; then
    log_info "DRY-RUN: construiria grupo '$group' na ordem acima."
    return 0
  fi

  local p
  for p in "${order[@]}"; do
    build_pkg_if_needed "$p"
  done
}

cmd_chroot_build() {
  local dir="$1" pkg="$2"
  chroot_build_pkg "$dir" "$pkg"
}

cmd_chroot_shell() {
    # Argumento opcional: se vazio, helper decide via ADM_CHROOT/LFS ou /mnt/lfs
    local chroot_dir="${1:-}"

    # Caminho do helper (ajuste se você instalou em outro lugar)
    local helper="/usr/local/sbin/adm-chroot.sh"

    if [[ ! -x "$helper" ]]; then
        die "Helper $helper não encontrado ou não executável. Instale-o antes."
    fi

    if [[ -n "$chroot_dir" ]]; then
        log_info "Entrando no chroot-shell usando $helper para $chroot_dir"
        "$helper" enter "$chroot_dir"
    else
        log_info "Entrando no chroot-shell usando $helper (DIR via ADM_CHROOT/LFS ou /mnt/lfs)"
        "$helper" enter
    fi
}

cmd_chroot_prepare() {
    # Argumento opcional: se vazio, helper decide via ADM_CHROOT/LFS ou /mnt/lfs
    local chroot_dir="${1:-}"

    local helper="/usr/local/sbin/adm-chroot.sh"
    if [[ ! -x "$helper" ]]; then
        die "Helper $helper não encontrado ou não executável. Instale-o antes."
    fi

    if [[ -n "$chroot_dir" ]]; then
        log_info "Preparando chroot $chroot_dir via $helper"
        "$helper" prepare "$chroot_dir"
    else
        log_info "Preparando chroot via $helper (DIR via ADM_CHROOT/LFS ou /mnt/lfs)"
        "$helper" prepare
    fi
}

cmd_chroot_teardown() {
    # Argumento opcional: se vazio, helper decide via ADM_CHROOT/LFS ou /mnt/lfs
    local chroot_dir="${1:-}"

    local helper="/usr/local/sbin/adm-chroot.sh"
    if [[ ! -x "$helper" ]]; then
        die "Helper $helper não encontrado ou não executável. Instale-o antes."
    fi

    if [[ -n "$chroot_dir" ]]; then
        log_info "Desmontando chroot $chroot_dir via $helper"
        "$helper" teardown "$chroot_dir"
    else
        log_info "Desmontando chroot via $helper (DIR via ADM_CHROOT/LFS ou /mnt/lfs)"
        "$helper" teardown
    fi
}

cmd_chroot_build_group() {
    local chroot_dir="$1"
    local group="$2"

    if [[ -z "$chroot_dir" || -z "$group" ]]; then
        die "Uso: adm chroot-build-group <dir> <grupo>"
    fi

    local helper="/usr/local/sbin/adm-chroot.sh"

    if [[ ! -x "$helper" ]]; then
        die "Helper $helper não encontrado ou não executável."
    fi

    log_info "Executando build-group '$group' no chroot $chroot_dir"

    # Passa todas as variáveis ADM_* para dentro do chroot
    "$helper" enter "$chroot_dir" <<EOF
export ADM_PREFIX="$ADM_PREFIX"
export ADM_STATE_DIR="$ADM_STATE_DIR"
export ADM_CACHE_DIR="$ADM_CACHE_DIR"
export ADM_SRC_CACHE="$ADM_SRC_CACHE"
export ADM_BIN_CACHE="$ADM_BIN_CACHE"
export ADM_BUILD_ROOT="$ADM_BUILD_ROOT"
export ADM_LOG_DIR="$ADM_LOG_DIR"
export ADM_DEFAULT_COMPRESS="$ADM_DEFAULT_COMPRESS"

adm build-group "$group"
EOF
}

# -------------------------------------------------------------
# Main
# -------------------------------------------------------------
main() {
  init_dirs

  # Logging global (tudo que aparece na tela também vai para o log)
  exec > >(tee -a "$ADM_LOG_DIR/adm.log") 2>&1
  log_info "Iniciando execução do adm em $(date)"

  local cmd="${1:-help}"
  shift || true

  case "$cmd" in
    build)
      [[ $# -eq 1 ]] || die "Uso: adm build <pacote|grupo>"
      cmd_build "$1"
      ;;
    install)
      (( $# >= 1 )) || die "Uso: adm install <pacote> [outro_pacote ...]"
      cmd_install "$@"
      ;;
    remove)
      [[ $# -eq 1 ]] || die "Uso: adm remove <pacote>"
      cmd_remove "$1"
      ;;
    deps)
      [[ $# -eq 1 ]] || die "Uso: adm deps <pacote>"
      cmd_deps "$1"
      ;;
    resolve)
      (( $# >= 1 )) || die "Uso: adm resolve <p1> [p2 ...]"
      cmd_resolve "$@"
      ;;
    list)
      cmd_list
      ;;
    info)
      [[ $# -eq 1 ]] || die "Uso: adm info <pacote>"
      cmd_info "$1"
      ;;
    verify)
      [[ $# -eq 1 ]] || die "Uso: adm verify <pacote>"
      cmd_verify "$1"
      ;;
    list-upgrades)
      cmd_list_upgrades
      ;;
    upgrade)
      cmd_upgrade "$@"
      ;;
    chroot-build)
      [[ $# -eq 2 ]] || die "Uso: adm chroot-build <dir> <pacote>"
      cmd_chroot_build "$1" "$2"
      ;;
    chroot-shell)
      (( $# <= 1 )) || die "Uso: adm chroot-shell [diretório-do-chroot]"
      cmd_chroot_shell "${1:-}"
      ;;
    chroot-prepare)
      (( $# <= 1 )) || die "Uso: adm chroot-prepare [diretório-do-chroot]"
      cmd_chroot_prepare "${1:-}"
      ;;
    chroot-teardown)
      (( $# <= 1 )) || die "Uso: adm chroot-teardown [diretório-do-chroot]"
      cmd_chroot_teardown "${1:-}"
      ;;
    chroot-build-group)
      [[ $# -eq 2 ]] || die "Uso: adm chroot-build-group <dir> <grupo>"
      cmd_chroot_build_group "$1" "$2"
      ;;
    version)
      printf 'adm versão %s\n' "$ADM_VERSION"
      ;;
    help|-h|--help)
      usage
      ;;
    *)
      die "Comando desconhecido: $cmd (use 'adm help')"
      ;;
  esac
}

main "$@"
