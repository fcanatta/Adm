Beleza, vamos transformar esse script em algo que voc√™ consegue confiar porque sabe testar tudo.
Vou montar um check-list por fase e depois um bloco s√≥ sobre valida√ß√£o do cross-toolchain com ‚Äúhello world‚Äù, readelf, etc.

Vou assumir:

LFS=/mnt/lfs
LFS_TGT=$(uname -m)-lfs-linux-gnu   # ex: x86_64-lfs-linux-gnu
./lfs-cross-helper.sh               # script j√° est√° execut√°vel


---

0. Antes de tudo ‚Äì checar ambiente do host

0.1. Ver se o host tem as ferramentas b√°sicas

Como root:

for t in bash binutils bison coreutils diff find gawk gcc g++ grep gzip \
         m4 make patch perl python3 sed tar xz wget; do
  command -v "$t" >/dev/null || echo "FALTA: $t"
done

Se aparecer algum FALTA, instala pela distro antes de continuar.

0.2. Testar o script rapidamente

bash -n lfs-cross-helper.sh   # n√£o deve imprimir nada (sintaxe ok)
./lfs-cross-helper.sh         # deve mostrar o usage


---

1. Testes depois de init-host

1.1. Rodar fase

sudo ./lfs-cross-helper.sh init-host

1.2. Conferir estado

sudo ./lfs-cross-helper.sh status

Sa√≠da esperada (algo assim):

[OK]   init-host
[....] download-sources
[....] verify-sources
...

1.3. Conferir layout e permiss√µes

ls -ld /mnt/lfs /mnt/lfs/{tools,usr,var,etc,sources}
id lfs
getent group lfs

Esperado:

/mnt/lfs e subdiret√≥rios existem.

Dono: lfs:lfs.

Usu√°rio lfs existe.


1.4. Testar ambiente do usu√°rio lfs

su - lfs -c 'echo "LFS=$LFS  LFS_TGT=$LFS_TGT"; echo "PATH=$PATH"'

Esperado:

LFS=/mnt/lfs

PATH come√ßa com /mnt/lfs/tools/bin: (ou o valor de $LFS/tools/bin).



---

2. Testes de download-sources e verify-sources

2.1. Rodar download

sudo ./lfs-cross-helper.sh download-sources

Depois:

ls $LFS/sources | head

Tem que ter um monte de .tar.xz, .tar.gz, etc.

2.2. Verificar checksums

sudo ./lfs-cross-helper.sh verify-sources

Se tudo ok:

No final ele mostra FALHOU: 0 e FALTANDO: 0.

status mostra verify-sources como [OK]:


sudo ./lfs-cross-helper.sh status


---

3. Check-list de testes do CROSS-TOOLCHAIN

Rodar:

sudo ./lfs-cross-helper.sh cross-toolchain

Isso vai passar por:

1. Binutils pass 1


2. GCC pass 1


3. Linux headers


4. Glibc ou Musl (dependendo de USE_MUSL)


5. Libstdc++ cross



Se falhar, ele para onde der erro (bom p/ debug).

3.1. Testes espec√≠ficos (como root ou como lfs)

3.1.1. Testar Binutils pass1

Como lfs:

su - lfs

which "$LFS_TGT-as"
which "$LFS_TGT-ld"
"$LFS_TGT-as" --version
"$LFS_TGT-ld" --version
exit

Esperado:

which mostra algo em /mnt/lfs/tools/bin/‚Ä¶.

--version imprime algo tipo GNU assembler (GNU Binutils) 2.45.1 (ou sua vers√£o).


3.1.2. Testar GCC pass1

Ainda como lfs:

su - lfs

which "$LFS_TGT-gcc"
"$LFS_TGT-gcc" --version

# onde est√° o sysroot?
"$LFS_TGT-gcc" -print-sysroot

# diret√≥rios de busca
"$LFS_TGT-gcc" -print-search-dirs
exit

Esperado:

which ‚Üí /mnt/lfs/tools/bin/$LFS_TGT-gcc

-print-sysroot ‚Üí $LFS (ou $LFS + algo), n√£o /.

Nenhum erro de ‚Äúcommand not found‚Äù.


3.1.3. Verificar Linux headers

Como root:

ls -R $LFS/usr/include | head

E confirmar que s√≥ tem .h (sem arquivos estranhos):

find $LFS/usr/include -type f ! -name '*.h'

Esperado: nenhuma linha nessa √∫ltima; s√≥ .h.

3.1.4. Verificar glibc/musl cross

Se estiver usando Glibc (padr√£o):

ls $LFS/usr/lib | egrep "crt1.o|crti.o|crtn.o"   # arquivos de start
ls $LFS/lib                                  # deve ter libc.so, etc. (ou /usr/lib)

Se estiver usando Musl:

ls $LFS/lib | grep "libc.so"

3.1.5. Verificar libstdc++ cross

ls $LFS/usr/lib | grep "libstdc++"
ls $LFS/usr/include/c++/$GCC_VER

(de dentro do script, $GCC_VER = 15.2.0; na shell, substitui direto)


---

3.2. Teste ‚ÄúHello World‚Äù com o cross-compiler

Esse √© o teste mais importante üí•

Como lfs:

su - lfs

cat > hello.c << 'EOF'
#include <stdio.h>

int main(void) {
    printf("Hello LFS cross-toolchain!\n");
    return 0;
}
EOF

"$LFS_TGT-gcc" hello.c -o hello
file hello
"$LFS_TGT-readelf" -l hello | grep 'Requesting program interpreter' || readelf -l hello | grep 'Requesting program interpreter'
exit

O que olhar:

file hello deve dizer algo como:

ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, ...


A linha do readelf mostra qual interpretador (linker din√¢mico) est√° sendo usado ‚Äì voc√™ quer algo compat√≠vel com a glibc/musl que est√° em $LFS, n√£o coisas do host.


> Se voc√™ copiar o hello pra dentro do chroot depois (quando ele existir), ele deve rodar l√° normalmente.




---

4. Check-list de testes das TEMPORARY TOOLS (Cap. 6)

Depois de rodar:

sudo ./lfs-cross-helper.sh temp-tools
sudo ./lfs-cross-helper.sh status   # temp-tools deve estar [OK]

4.1. Verificar se as ferramentas est√£o instaladas em $LFS

Como root:

ls $LFS/usr/bin | egrep 'bash|m4|grep|gawk|sed|tar|xz|gzip|make|patch|find|file'

4.2. Testar algumas delas pelo cross-ambiente (ainda como lfs)

su - lfs

# importantes
$LFS_TGT-gcc --version       # j√° vimos
bash --version               # precisa pegar /usr/bin/bash do $LFS via PATH?
grep --version
sed --version
tar --version
xz --version

exit

Esses comandos, rodados como lfs, v√£o usar o PATH configurado no .bashrc (com $LFS/tools/bin:/usr/bin:/bin).
Como as temporary tools foram instaladas com DESTDIR=$LFS, elas estar√£o em $LFS/usr/bin, e quando voc√™ entrar no chroot, se tornam /usr/bin.


---

5. Testes ap√≥s chroot-setup

Rodar:

sudo ./lfs-cross-helper.sh chroot-setup
sudo ./lfs-cross-helper.sh status   # chroot-setup deve estar [OK]

5.1. Conferir mounts

mount | egrep "$LFS"

Voc√™ deve ver coisas como:

/dev ‚Üí $LFS/dev

proc ‚Üí $LFS/proc

sysfs ‚Üí $LFS/sys

tmpfs ‚Üí $LFS/run

devpts ‚Üí $LFS/dev/pts


5.2. Tentar entrar manualmente no chroot

sudo chroot $LFS /usr/bin/env -i \
    HOME=/root TERM=$TERM PS1='(test) \u:\w\$ ' \
    PATH=/usr/bin:/usr/sbin:/bin:/sbin \
    /usr/bin/bash --login

Dentro do chroot:

echo "Estou no chroot, pwd = $(pwd)"
ls /
ls /usr/bin | head
cat /etc/passwd
cat /etc/group
ls -l /bin /sbin /lib
exit

Esperado:

/bin, /sbin, /lib s√£o symlinks para /usr/bin, /usr/sbin, /usr/lib.

/etc/passwd e /etc/group com o conte√∫do m√≠nimo criado pelo script.

/root, /tmp, /var/tmp existem com as permiss√µes corretas.



---

6. Testes ap√≥s chroot-tools (Cap. 7)

Rodar:

sudo ./lfs-cross-helper.sh chroot-tools
sudo ./lfs-cross-helper.sh status   # chroot-tools deve estar [OK]

6.1. Validar dentro do chroot

Entre no chroot (como acima ou com enter-chroot):

sudo ./lfs-cross-helper.sh enter-chroot

Dentro:

# gettext
which msgfmt && msgfmt --version

# bison
which bison && bison --version

# perl
which perl && perl -v

# python
which python3 && python3 --version

# texinfo
which makeinfo && makeinfo --version

# util-linux (exemplos)
which fdisk && fdisk --version
which mount && mount --version

exit

Se tudo responder com vers√µes ‚Äúnormais‚Äù (sem erro de ‚Äúcommand not found‚Äù), as ferramentas do cap. 7 est√£o ok.


---

7. Final ‚Äì desmontar chroot com seguran√ßa

Quando terminar:

sudo ./lfs-cross-helper.sh umount-chroot
mount | egrep "$LFS"   # n√£o deve sobrar nada

Se reclamar de ‚Äútarget is busy‚Äù, verifique se ainda tem shell/processo no chroot:

ps aux | grep "$LFS" | grep -v grep

Feche o que estiver preso e rode umount-chroot de novo.
