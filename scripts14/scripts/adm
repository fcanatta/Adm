#!/usr/bin/env bash
# adm - CLI principal do ADM 2.0
#
# Comandos:
#
#   build         PKG...         -> constrói (com deps) e instala pacote(s)
#   build-group   GRUPO          -> constrói todos os pacotes de um grupo (ex: xorg, toolchain)
#   install       PKG...         -> alias amigável para build (construir + instalar)
#
#   update        [alvos...]     -> orquestra adm-update
#   upgrade       [opções...]    -> orquestra adm-upgrade
#
#   check         PKG...         -> roda adm-check em pacotes instalados
#
#   search        PADRÃO         -> procura pacotes nos metadados
#   info          PKG_ID         -> mostra metadado de um pacote
#   list-installed               -> lista pacotes instalados (db/installed)
#
#   snapshot      ...            -> delega para adm-snapshot (create/diff/restore)
#   report        ...            -> delega para adm-report
#   tui                           -> abre adm-tui (monitor de builds)
#
#   help          [comando]      -> ajuda geral ou ajuda do subcomando
#
# Flags globais:
#
#   --profile ID      -> força o uso do profile ID em todos os builds (via ADM_BUILD_PROFILE_OVERRIDE)
#   --dry-run, -n     -> ADM_DRY_RUN=1 (mostra o que faria, sem executar)
#   --force           -> ADM_BUILD_FORCE=1, ADM_UPDATE_FORCE=1, ADM_UPGRADE_FORCE=1
#
# Cada comando é tratado como uma "tarefa" (task):
#   - ID único: task-YYYYMMDD-HHMMSS-PID-RANDOM
#   - arquivo em db/tasks/<ID>.task com status, comando, profile etc.
#   - eventos ADM_TASK_START / ADM_TASK_DONE / ADM_TASK_FAIL via adm-eventd.
#
# Instalação final: sempre em /usr (quem cuida é o adm-build).

set -o errexit
set -o nounset
set -o pipefail

# =========
# Descobrir diretório do script e carregar módulos base
# =========

_adm_cli_script_dir() {
    local src="${BASH_SOURCE[0]:-$0}"
    while [ -L "$src" ]; do
        local target
        target=$(readlink "$src") || break
        if [[ "$target" = /* ]]; then
            src="$target"
        else
            src="$(dirname "$src")/$target"
        fi
    done
    cd "$(dirname "$src")" >/dev/null 2>&1 || {
        printf 'ADM-ERROR: Não foi possível entrar no diretório do script adm.\n' >&2
        exit 1
    }
    pwd
}

_ADM_CLI_DIR="$(_adm_cli_script_dir)"

# shellcheck disable=SC1090
source "$_ADM_CLI_DIR/adm-env"
# shellcheck disable=SC1090
source "$_ADM_CLI_DIR/adm-log-ui"
# shellcheck disable=SC1090
source "$_ADM_CLI_DIR/adm-eventd"
# shellcheck disable=SC1090
source "$_ADM_CLI_DIR/adm-db"
# shellcheck disable=SC1090
source "$_ADM_CLI_DIR/adm-build"
# shellcheck disable=SC1090
source "$_ADM_CLI_DIR/adm-profile"

ADM_DB_TASKS_DIR="${ADM_DB_TASKS_DIR:-${ADM_DB_DIR}/tasks}"
ADM_PACKAGES_DIR="${ADM_PACKAGES_DIR:-${ADM_ROOT}/packages}"

mkdir -p "$ADM_DB_TASKS_DIR" >/dev/null 2>&1 || true

# Flags globais (podem vir do ambiente; CLI pode sobrescrever)
ADM_DRY_RUN="${ADM_DRY_RUN:-0}"
ADM_BUILD_FORCE="${ADM_BUILD_FORCE:-0}"
ADM_UPDATE_FORCE="${ADM_UPDATE_FORCE:-0}"
ADM_UPGRADE_FORCE="${ADM_UPGRADE_FORCE:-0}"
ADM_BUILD_PROFILE_OVERRIDE="${ADM_BUILD_PROFILE_OVERRIDE:-}"

# =========
# Utilidades de tasks
# =========

adm_task_new_id() {
    local ts pid rnd
    ts="$(date '+%Y%m%d-%H%M%S')"
    pid="$$"
    rnd="$RANDOM"
    printf 'task-%s-%s-%s\n' "$ts" "$pid" "$rnd"
}

adm_task_file() {
    local task_id="$1"
    printf '%s/%s.task\n' "$ADM_DB_TASKS_DIR" "$task_id"
}

adm_task_write_status() {
    local task_id="$1"
    local status="$2"
    local exit_code="$3"

    local file
    file="$(adm_task_file "$task_id")"

    {
        echo "id=$task_id"
        echo "status=$status"
        echo "exit_code=$exit_code"
        echo "ts=$(date '+%Y-%m-%dT%H:%M:%S%z')"
    } >>"$file"
}

adm_task_run() {
    # Uso:
    #   adm_task_run TYPE DESCR COMANDO...
    #
    # Ex:
    #   adm_task_run "build" "Build pkg foo" "$_ADM_CLI_DIR/adm-build" build-with-deps foo
    local type="$1"
    local descr="$2"
    shift 2 || true

    local task_cmd=( "$@" )

    local task_id
    task_id="$(adm_task_new_id)"

    local file
    file="$(adm_task_file "$task_id")"

    {
        echo "id=$task_id"
        echo "type=$type"
        echo "descr=$descr"
        echo "cmd=${task_cmd[*]}"
        echo "profile_override=${ADM_BUILD_PROFILE_OVERRIDE:-}"
        echo "dry_run=${ADM_DRY_RUN:-0}"
        echo "force_build=${ADM_BUILD_FORCE:-0}"
        echo "ts_start=$(date '+%Y-%m-%dT%H:%M:%S%z')"
    } >"$file"

    adm_event_emit "ADM_TASK_START" "$type" "task_id=$task_id descr=$(printf '%q' "$descr") cmd=$(printf '%q' "${task_cmd[*]}")"

    local rc=0
    if [[ "${ADM_DRY_RUN:-0}" -eq 1 && "$type" != "tui" && "$type" != "search" && "$type" != "info" && "$type" != "list-installed" ]]; then
        adm_log_info "[DRY-RUN][task=$task_id] Execução simulada: ${task_cmd[*]}"
        rc=0
    else
        "${task_cmd[@]}" || rc=$?
    fi

    if [[ "$rc" -eq 0 ]]; then
        adm_task_write_status "$task_id" "DONE" "$rc"
        adm_event_emit "ADM_TASK_DONE" "$type" "task_id=$task_id rc=$rc"
    else
        adm_task_write_status "$task_id" "FAIL" "$rc"
        adm_event_emit "ADM_TASK_FAIL" "$type" "task_id=$task_id rc=$rc"
    fi

    return "$rc"
}

# =========
# Parser de flags globais
# =========

adm_cli_parse_global_opts() {
    # Remove flags globais e ajusta variáveis globais.
    #
    # Uso:
    #   local filtered=()
    #   adm_cli_parse_global_opts filtered "$@"
    #   args=("${filtered[@]}")
    local -n _out_args="$1"
    shift || true

    local args=("$@")
    local filtered=()
    local i=0

    while [[ $i -lt ${#args[@]} ]]; do
        local a="${args[$i]}"
        case "$a" in
            --profile)
                i=$((i + 1))
                if [[ $i -lt ${#args[@]} ]]; then
                    ADM_BUILD_PROFILE_OVERRIDE="${args[$i]}"
                else
                    adm_log_fatal "--profile exige um ID de profile."
                fi
                ;;
            --dry-run|-n)
                ADM_DRY_RUN=1
                ;;
            --force)
                ADM_BUILD_FORCE=1
                ADM_UPDATE_FORCE=1
                ADM_UPGRADE_FORCE=1
                ;;
            *)
                filtered+=("$a")
                ;;
        esac
        i=$((i + 1))
    done

    _out_args=("${filtered[@]}")
}

# =========
# Helpers: metadados / grupos / busca
# =========

adm_cli_all_pkg_ids() {
    # Lista todos os pkg_id (categoria/nome) a partir de ADM_PACKAGES_DIR.
    if [[ ! -d "$ADM_PACKAGES_DIR" ]]; then
        return 0
    fi
    find "$ADM_PACKAGES_DIR" -mindepth 2 -maxdepth 2 -type d 2>/dev/null \
        | sed "s#^${ADM_PACKAGES_DIR}/##" \
        | sort
}

adm_cli_metadado_path() {
    # Resolve pkg_id -> caminho do metadado.
    #
    # Tenta usar adm_build_metadado_path se existir,
    # senão assume layout packages/<cat>/<name>/metadado.
    local pkg_id="$1"
    if type -t adm_build_metadado_path >/dev/null 2>&1; then
        adm_build_metadado_path "$pkg_id"
        return $?
    fi
    printf '%s/%s/metadado\n' "$ADM_PACKAGES_DIR" "$pkg_id"
}

adm_cli_packages_with_group() {
    # Lista todos os pkg_id que possuem o grupo informado no campo groups:
    #
    # Uso:
    #   adm_cli_packages_with_group xorg
    local group="$1"
    local ids
    ids="$(adm_cli_all_pkg_ids || true)"
    [[ -z "$ids" ]] && return 0

    local id meta groups
    while IFS= read -r id; do
        [[ -z "$id" ]] && continue
        meta="$(adm_cli_metadado_path "$id")"
        [[ ! -f "$meta" ]] && continue
        groups="$(awk -F':' '
            tolower($1) ~ /^[[:space:]]*groups[[:space:]]*$/ {
                $1=""; sub(/^[[:space:]]+/, "", $0); print tolower($0); exit 0
            }
        ' "$meta" 2>/dev/null || true)"
        if echo " $groups " | grep -q " $(printf '%s' "$group" | tr '[:upper:]' '[:lower:]') "; then
            echo "$id"
        fi
    done <<<"$ids"
}

adm_cli_search() {
    local pattern="${1:-}"
    if [[ -z "$pattern" ]]; then
        adm_log_fatal "Uso: adm search PADRÃO"
    fi

    local ids
    ids="$(adm_cli_all_pkg_ids || true)"
    if [[ -z "$ids" ]]; then
        adm_log_warn "Nenhum pacote encontrado em $ADM_PACKAGES_DIR."
        return 0
    fi

    pattern_lc="$(printf '%s' "$pattern" | tr '[:upper:]' '[:lower:]')"

    adm_log_phase_header "Busca por: $pattern"

    local id meta name desc hit
    hit=0
    while IFS= read -r id; do
        [[ -z "$id" ]] && continue
        meta="$(adm_cli_metadado_path "$id")"
        [[ ! -f "$meta" ]] && continue
        name="$(awk -F':' '
            tolower($1) ~ /^[[:space:]]*name[[:space:]]*$/ {
                $1=""; sub(/^[[:space:]]+/, "", $0); print; exit 0
            }
        ' "$meta" 2>/dev/null || true)"
        desc="$(awk -F':' '
            tolower($1) ~ /^[[:space:]]*description[[:space:]]*$/ {
                $1=""; sub(/^[[:space:]]+/, "", $0); print; exit 0
            }
        ' "$meta" 2>/dev/null || true)"

        local haystack
        haystack="$(printf '%s %s %s\n' "$id" "$name" "$desc" | tr '[:upper:]' '[:lower:]')"
        if echo "$haystack" | grep -q "$pattern_lc"; then
            printf "  %s - %s\n" "$id" "${name:-"(sem name)"}"
            hit=1
        fi
    done <<<"$ids"

    if [[ "$hit" -eq 0 ]]; then
        adm_log_info "Nenhum pacote encontrado para '$pattern'."
    fi
}

adm_cli_info() {
    local pkg_id="${1:-}"
    if [[ -z "$pkg_id" ]]; then
        adm_log_fatal "Uso: adm info PKG_ID"
    fi

    local meta
    meta="$(adm_cli_metadado_path "$pkg_id")"

    if [[ ! -f "$meta" ]]; then
        adm_log_fatal "Metadado não encontrado para $pkg_id em '$meta'."
    fi

    adm_log_phase_header "Metadado de $pkg_id ($meta)"
    cat "$meta"
}

adm_cli_list_installed() {
    adm_log_phase_header "Pacotes instalados (db/installed)"

    if ! type -t adm_db_list_installed >/dev/null 2>&1; then
        adm_log_fatal "adm_db_list_installed não está disponível (adm-db desatualizado?)."
    fi

    local line
    printf "%-40s %-12s %-8s %-20s %-8s\n" "PKG_ID" "VERSION" "REL" "PROFILE" "LIBC"
    printf "%-40s %-12s %-8s %-20s %-8s\n" "----------------------------------------" "------------" "--------" "--------------------" "--------"

    adm_db_list_installed | while read -r line; do
        # esperado: pkg_id version release profile libc
        set -- $line
        local pkg_id="$1" ver="$2" rel="$3" prof="$4" libc="$5"
        printf "%-40s %-12s %-8s %-20s %-8s\n" "$pkg_id" "$ver" "$rel" "$prof" "$libc"
    done
}

# =========
# Comandos de alto nível
# =========

adm_cli_cmd_build() {
    # adm build PKG... [--profile ID] [--dry-run] [--force]
    if [[ $# -lt 1 ]]; then
        adm_log_fatal "Uso: adm build PKG1 [PKG2 ...] [--profile ID] [--dry-run] [--force]"
    fi
    local pkgs=("$@")
    local descr="Build de pacotes: ${pkgs[*]}"
    adm_task_run "build" "$descr" "$_ADM_CLI_DIR/adm-build" build-with-deps "${pkgs[@]}"
}

adm_cli_cmd_install() {
    # Alias semântico para build (construir + instalar).
    adm_cli_cmd_build "$@"
}

adm_cli_cmd_build_group() {
    # adm build-group GRUPO [--profile ID] [--dry-run] [--force]
    local group="${1:-}"
    if [[ -z "$group" ]]; then
        adm_log_fatal "Uso: adm build-group GRUPO [--profile ID] [--dry-run] [--force]"
    fi

    shift || true
    # (flags globais já foram parseadas lá em cima e aplicadas)
    local pkgs
    pkgs="$(adm_cli_packages_with_group "$group" || true)"

    if [[ -z "$pkgs" ]]; then
        adm_log_fatal "Nenhum pacote encontrado com grupo '$group'."
    fi

    local pkgs_arr=()
    while IFS= read -r p; do
        [[ -z "$p" ]] && continue
        pkgs_arr+=("$p")
    done <<<"$pkgs"

    local descr="Build de grupo '$group' com pacotes: ${pkgs_arr[*]}"
    adm_task_run "build-group" "$descr" "$_ADM_CLI_DIR/adm-build" build-with-deps "${pkgs_arr[@]}"
}

adm_cli_cmd_update() {
    # adm update [alvos...] [--force] [--dry-run]
    #
    # Delegado para adm-update (CLI próprio).
    local descr="Update: $*"
    adm_task_run "update" "$descr" "$_ADM_CLI_DIR/adm-update" "$@"
}

adm_cli_cmd_upgrade() {
    # adm upgrade [opções...]
    local descr="Upgrade: $*"
    adm_task_run "upgrade" "$descr" "$_ADM_CLI_DIR/adm-upgrade" "$@"
}

adm_cli_cmd_check() {
    # adm check PKG... (ou sem args -> checa tudo instalado, se desejar evoluir)
    if [[ $# -lt 1 ]]; then
        adm_log_fatal "Uso: adm check PKG1 [PKG2 ...]"
    fi
    local pkgs=("$@")
    local descr="Check: ${pkgs[*]}"
    adm_task_run "check" "$descr" "$_ADM_CLI_DIR/adm-check" "${pkgs[@]}"
}

adm_cli_cmd_snapshot() {
    # adm snapshot <subcomandos do adm-snapshot...>
    if [[ $# -lt 1 ]]; then
        adm_log_fatal "Uso: adm snapshot (create|diff|restore ...)"
    fi
    local descr="Snapshot: $*"
    adm_task_run "snapshot" "$descr" "$_ADM_CLI_DIR/adm-snapshot" "$@"
}

adm_cli_cmd_report() {
    # adm report <subcomandos do adm-report...>
    if [[ $# -lt 1 ]]; then
        adm_log_fatal "Uso: adm report (usage|top-time|top-fail ...)"
    fi
    local descr="Report: $*"
    adm_task_run "report" "$descr" "$_ADM_CLI_DIR/adm-report" "$@"
}

adm_cli_cmd_tui() {
    # adm tui -> abre o adm-tui
    local descr="TUI (monitor de builds)"
    adm_task_run "tui" "$descr" "$_ADM_CLI_DIR/adm-tui"
}

# =========
# Help
# =========

adm_cli_usage() {
    cat <<EOF
adm - CLI principal do ADM 2.0

Uso geral:
  adm [FLAGS_GLOBAIS] comando [argumentos...]

Comandos:

  build          PKG1 [PKG2 ...]
      Constrói (com dependências) e instala o(s) pacote(s) informado(s).

  build-group    GRUPO
      Constrói todos os pacotes que possuem o grupo GRUPO no metadado
      (ex.: base, xorg, toolchain).

  install        PKG1 [PKG2 ...]
      Alias para "build": constrói tudo e instala, entregando o programa pronto.

  update         [alvos...]
      Wrapper para adm-update. Pode aceitar:
        - PKG_ID
        - grupo
        - --all
      (conforme CLI do adm-update).

  upgrade        [opções...]
      Wrapper para adm-upgrade. Usa db/upgrade-list ou arquivos passados.

  check          PKG1 [PKG2 ...]
      Wrapper para adm-check em um ou mais pacotes.

  search         PADRÃO
      Busca pacotes em packages/ lendo metadados (name, description, id).

  info           PKG_ID
      Mostra o metadado de um pacote.

  list-installed
      Lista os pacotes instalados (db/installed via adm-db).

  snapshot       (create|diff|restore ...)
      Wrapper para adm-snapshot.

  report         (usage|top-time|top-fail ...)
      Wrapper para adm-report.

  tui
      Abre o adm-tui (monitor de builds, fila, logs).

  help [comando]
      Mostra este help ou delega para o --help do subcomando apropriado.

Flags globais:

  --profile ID
      Força o uso do profile ID em todos os builds (seta ADM_BUILD_PROFILE_OVERRIDE).
      Exemplo:
        adm --profile glibc/extreme build base/coreutils

  --dry-run, -n
      Seta ADM_DRY_RUN=1. As tarefas de build/update/upgrade só logam o que fariam,
      sem executar de fato.

  --force
      Seta:
        ADM_BUILD_FORCE=1
        ADM_UPDATE_FORCE=1
        ADM_UPGRADE_FORCE=1

Integração com profiles:

  - TODO build passa pelo adm-build, que escolhe profile assim:
      1) Se ADM_BUILD_PROFILE_OVERRIDE estiver setado (via --profile ou ambiente),
         é usado esse profile.
      2) Caso contrário, usa o profile atual (adm-profile current), se existir.
      3) Se ainda não, heurística:
           * pacotes de toolchain -> toolchain/safe-<libc>
           * outros pacotes       -> <libc>/extreme
      4) Fallback: glibc/extreme ou toolchain/safe-glibc, se existirem.

  - O adm registra tasks em db/tasks e emite eventos ADM_TASK_*,
    enquanto adm-build emite PKG_BUILD_* e registra em db/installed/history.

Exemplos:

  adm build base/bash
  adm --profile glibc/extreme build base/coreutils base/sed
  adm build-group xorg
  adm update --all
  adm upgrade --plan safe
  adm search gcc
  adm info base/coreutils
  adm list-installed
  adm snapshot create before-big-upgrade
  adm report usage
  adm tui

EOF
}

adm_cli_help_subcommand() {
    local sub="$1"
    case "$sub" in
        build|install|build-group|update|upgrade|check|snapshot|report|tui|search|info|list-installed)
            case "$sub" in
                build|install|build-group)
                    adm_cli_usage
                    ;;
                update)
                    "$_ADM_CLI_DIR/adm-update" --help || true
                    ;;
                upgrade)
                    "$_ADM_CLI_DIR/adm-upgrade" --help || true
                    ;;
                check)
                    "$_ADM_CLI_DIR/adm-check" --help || true
                    ;;
                snapshot)
                    "$_ADM_CLI_DIR/adm-snapshot" --help || true
                    ;;
                report)
                    "$_ADM_CLI_DIR/adm-report" --help || true
                    ;;
                tui)
                    "$_ADM_CLI_DIR/adm-tui" --help || true
                    ;;
                search|info|list-installed)
                    adm_cli_usage
                    ;;
            esac
            ;;
        *)
            adm_cli_usage
            ;;
    esac
}

# =========
# Main
# =========

adm_main() {
    local cmd="${1:-}"
    [[ -n "$cmd" ]] && shift || true

    # parse flags globais
    local args=("$@")
    local filtered_args=()
    adm_cli_parse_global_opts filtered_args "${args[@]}"
    args=("${filtered_args[@]}")

    case "$cmd" in
        build)
            adm_cli_cmd_build "${args[@]}"
            ;;
        install)
            adm_cli_cmd_install "${args[@]}"
            ;;
        build-group)
            if [[ ${#args[@]} -lt 1 ]]; then
                adm_log_fatal "Uso: adm build-group GRUPO [--profile ID] [--dry-run] [--force]"
            fi
            adm_cli_cmd_build_group "${args[@]}"
            ;;
        update)
            adm_cli_cmd_update "${args[@]}"
            ;;
        upgrade)
            adm_cli_cmd_upgrade "${args[@]}"
            ;;
        check)
            adm_cli_cmd_check "${args[@]}"
            ;;
        search)
            adm_cli_search "${args[0]:-}"
            ;;
        info)
            adm_cli_info "${args[0]:-}"
            ;;
        list-installed)
            adm_cli_list_installed
            ;;
        snapshot)
            adm_cli_cmd_snapshot "${args[@]}"
            ;;
        report)
            adm_cli_cmd_report "${args[@]}"
            ;;
        tui)
            adm_cli_cmd_tui
            ;;
        help|"")
            if [[ ${#args[@]} -ge 1 ]]; then
                adm_cli_help_subcommand "${args[0]}"
            else
                adm_cli_usage
            fi
            ;;
        *)
            adm_log_fatal "Comando desconhecido para adm: '$cmd'"
            ;;
    esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    adm_main "$@"
fi

# Fim do adm
