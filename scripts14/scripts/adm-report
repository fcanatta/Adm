#!/usr/bin/env bash
# adm-report - Relatórios de métricas e histórico do ADM 2.0
#
# Lê:
#   - db/metrics (arquivos metrics-YYYYMMDD.log)
#   - db/history.log (ou caminho definido em ADM_DB_HISTORY_FILE)
#
# Comandos:
#
#   1) Pacotes que mais demoram:
#      adm-report top-time [N]
#
#   2) Pacotes que mais falham:
#      adm-report top-fail [N]
#
#   3) Estatísticas gerais de uso:
#      adm-report usage
#
#     - A partir de métricas:
#         * total de registros
#         * pacotes distintos
#         * contagem por op (BUILD, FETCH, SCAN, CHECK, UPDATE, etc.)
#         * top 5 pacotes em BUILD por nº de execuções
#     - A partir de history (rico):
#         * total de entradas
#         * contagem por tipo: install / upgrade / downgrade / remove / snapshot / other
#         * top 5 pacotes mais:
#               - instalados
#               - upgradados
#               - downgrades
#         * contagem de snapshots: create / restore / outros
#
# Formato de métricas (adm-metrics):
#   ts<TAB>pid<TAB>op<TAB>pkg<TAB>metric<TAB>value<TAB>unit<TAB>extra
#
# Formato de history (adm-db):
#   ts<TAB>pid<TAB>action<TAB>pkg_id<TAB>version<TAB>release<TAB>status<TAB>msg
#
# Onde msg (rico) recomenda-se:
#   key1=val1 key2=val2 ... :: texto livre
# Ex:
#   type=install profile=glibc/extreme libc=glibc build_id=xyz files=120 :: instalação concluída

set -o errexit
set -o nounset
set -o pipefail

# =========
# Descobrir diretório e carregar módulos
# =========

_adm_report_script_dir() {
    local src="${BASH_SOURCE[0]:-$0}"
    while [ -L "$src" ]; do
        local target
        target=$(readlink "$src") || break
        if [[ "$target" = /* ]]; then
            src="$target"
        else
            src="$(dirname "$src")/$target"
        fi
    done
    cd "$(dirname "$src")" >/dev/null 2>&1 || {
        printf 'ADM-ERROR: Não foi possível entrar no diretório do script adm-report.\n' >&2
        exit 1
    }
    pwd
}

_ADM_REPORT_DIR="$(_adm_report_script_dir)"

# shellcheck disable=SC1090
source "$_ADM_REPORT_DIR/adm-env"
# shellcheck disable=SC1090
source "$_ADM_REPORT_DIR/adm-log-ui"
# shellcheck disable=SC1090
source "$_ADM_REPORT_DIR/adm-eventd"
# shellcheck disable=SC1090
source "$_ADM_REPORT_DIR/adm-metrics"
# shellcheck disable=SC1090
source "$_ADM_REPORT_DIR/adm-db"

ADM_DB_HISTORY_FILE="${ADM_DB_HISTORY_FILE:-${ADM_DB_DIR}/history.log}"

# =========
# Utilidades: arquivos de métricas
# =========

adm_report_metrics_files() {
    # Lista todos arquivos de métricas existentes, ordenados.
    if [[ ! -d "$ADM_DB_METRICS_DIR" ]]; then
        return 0
    fi

    ls "$ADM_DB_METRICS_DIR"/metrics-*.log 2>/dev/null | sort || true
}

adm_report_require_metrics() {
    local files
    files="$(adm_report_metrics_files || true)"
    if [[ -z "$files" ]]; then
        adm_log_warn "Nenhum arquivo de métricas encontrado em '$ADM_DB_METRICS_DIR'."
        return 1
    fi
    return 0
}

# =========
# Relatório: pacotes que mais demoram (top-time)
# =========

adm_report_top_time() {
    local limit="${1:-10}"

    if ! [[ "$limit" =~ ^[0-9]+$ ]]; then
        adm_log_warn "Valor de N inválido em top-time, usando 10."
        limit=10
    fi

    if ! adm_report_require_metrics; then
        return 0
    fi

    local files
    files=$(adm_report_metrics_files)

    adm_log_phase_header "Relatório: Pacotes que mais demoram (top $limit por tempo médio)"

    # Formato:
    #   ts pid op pkg metric value unit extra
    # metric == "duration" em segundos
    local tmp
    tmp="$(mktemp "$ADM_TMP_DIR/report-top-time-XXXXXX")" || adm_log_fatal "Falha ao criar tmp para top-time."

    awk -F '\t' '
        NF >= 8 && $5 == "duration" {
            pkg=$4
            val=$6
            if (val+0 == val) {
                sum[pkg] += val
                count[pkg] += 1
            }
        }
        END {
            for (p in sum) {
                avg = sum[p] / count[p]
                printf "%s\t%.6f\t%d\t%.6f\n", p, avg, count[p], sum[p]
            }
        }
    ' $files >"$tmp"

    if [[ ! -s "$tmp" ]]; then
        adm_log_info "Nenhuma métrica de duração encontrada."
        rm -f "$tmp" || true
        return 0
    fi

    adm_log_info ""
    printf '%-4s %-40s %10s %10s %10s\n' "Rank" "Pacote" "avg(s)" "total(s)" "runs"
    printf '%-4s %-40s %10s %10s %10s\n' "----" "----------------------------------------" "----------" "----------" "----------"

    local rank=0
    while IFS=$'\t' read -r pkg avg count total; do
        rank=$((rank + 1))
        printf '%-4d %-40s %10.3f %10.3f %10d\n' "$rank" "$pkg" "$avg" "$total" "$count"
        if [[ "$rank" -ge "$limit" ]]; then
            break
        fi
    done < <(sort -t $'\t' -k2,2nr "$tmp")

    rm -f "$tmp" || true
}

# =========
# Relatório: pacotes que mais falham (top-fail)
# =========

adm_report_top_fail() {
    local limit="${1:-10}"

    if ! [[ "$limit" =~ ^[0-9]+$ ]]; then
        adm_log_warn "Valor de N inválido em top-fail, usando 10."
        limit=10
    fi

    if ! adm_report_require_metrics; then
        return 0
    fi

    local files
    files=$(adm_report_metrics_files)

    adm_log_phase_header "Relatório: Pacotes que mais falham (top $limit por número de falhas)"

    # Considera duration + extra com rc=...
    local tmp
    tmp="$(mktemp "$ADM_TMP_DIR/report-top-fail-XXXXXX")" || adm_log_fatal "Falha ao criar tmp para top-fail."

    awk -F '\t' '
        NF >= 8 && $5 == "duration" {
            pkg=$4
            extra=$8
            rc=""
            n = split(extra, a, " ")
            for (i=1; i<=n; i++) {
                if (a[i] ~ /^rc=/) {
                    rc=a[i]
                    sub(/^rc=/, "", rc)
                    sub(/[^0-9-].*/, "", rc)
                }
            }
            if (rc == "") rc=0
            total[pkg] += 1
            if (rc != 0) fails[pkg] += 1
        }
        END {
            for (p in total) {
                f = fails[p]
                if (f == "") f = 0
                t = total[p]
                rate = (t > 0 ? (100.0 * f / t) : 0)
                printf "%s\t%d\t%d\t%.2f\n", p, f, t, rate
            }
        }
    ' $files >"$tmp"

    if [[ ! -s "$tmp" ]]; then
        adm_log_info "Nenhuma métrica de duração encontrada."
        rm -f "$tmp" || true
        return 0
    fi

    adm_log_info ""
    printf '%-4s %-40s %10s %10s %8s\n' "Rank" "Pacote" "fails" "runs" "fail%"
    printf '%-4s %-40s %10s %10s %8s\n' "----" "----------------------------------------" "----------" "----------" "--------"

    local rank=0
    while IFS=$'\t' read -r pkg fails total rate; do
        rank=$((rank + 1))
        printf '%-4d %-40s %10d %10d %7.2f%%\n' "$rank" "$pkg" "$fails" "$total" "$rate"
        if [[ "$rank" -ge "$limit" ]]; then
            break
        fi
    done < <(sort -t $'\t' -k2,2nr -k4,4nr "$tmp")

    rm -f "$tmp" || true
}

# =========
# Relatório: estatísticas de uso (métricas)
# =========

adm_report_usage_metrics() {
    if ! adm_report_require_metrics; then
        adm_log_phase_header "Estatísticas de uso (métricas)"
        adm_log_info "Sem arquivos de métricas em '$ADM_DB_METRICS_DIR'."
        return 0
    fi

    local files
    files=$(adm_report_metrics_files)

    adm_log_phase_header "Estatísticas de uso (a partir de métricas)"

    local tmp_summary tmp_build
    tmp_summary="$(mktemp "$ADM_TMP_DIR/report-usage-sum-XXXXXX")" || adm_log_fatal "Falha ao criar tmp summary."
    tmp_build="$(mktemp "$ADM_TMP_DIR/report-usage-build-XXXXXX")" || adm_log_fatal "Falha ao criar tmp build."

    awk -F '\t' '
        NF >= 8 {
            total_lines++
            pkg=$4
            op=$3
            if (pkg != "") {
                pkgs[pkg]=1
            }
            ops[op]++
            if ($5 == "duration" && op == "BUILD") {
                builds[pkg]++
            }
        }
        END {
            n_pkgs=0
            for (p in pkgs) { n_pkgs++ }
            printf "%d\t%d\n", total_lines, n_pkgs
            for (o in ops) {
                printf "OP\t%s\t%d\n", o, ops[o]
            }
            for (b in builds) {
                printf "BUILD\t%s\t%d\n", b, builds[b]
            }
        }
    ' $files >"$tmp_summary"

    local total_lines total_pkgs
    IFS=$'\t' read -r total_lines total_pkgs <"$tmp_summary"

    adm_log_info "Total de registros de métricas : $total_lines"
    adm_log_info "Número de pacotes distintos    : $total_pkgs"
    adm_log_info ""

    adm_log_info "Contagem de operações por tipo (op):"
    awk -F '\t' '
        $1 == "OP" {
            printf "  - %-10s : %d\n", $2, $3
        }
    ' "$tmp_summary" | sort

    adm_log_info ""
    adm_log_info "Top 5 pacotes por número de builds (op=BUILD):"

    awk -F '\t' '$1 == "BUILD" {print $2 "\t" $3}' "$tmp_summary" >"$tmp_build"

    if [[ ! -s "$tmp_build" ]]; then
        adm_log_info "  (nenhum build registrado)"
    else
        local rank=0
        printf '%-4s %-40s %10s\n' "Rank" "Pacote" "builds"
        printf '%-4s %-40s %10s\n' "----" "----------------------------------------" "----------"
        while IFS=$'\t' read -r pkg count; do
            rank=$((rank + 1))
            printf '%-4d %-40s %10d\n' "$rank" "$pkg" "$count"
            if [[ "$rank" -ge 5 ]]; then
                break
            fi
        done < <(sort -t $'\t' -k2,2nr "$tmp_build")
    fi

    rm -f "$tmp_summary" "$tmp_build" || true
}

# =========
# Relatório: estatísticas de uso (history rico)
# =========

adm_report_usage_history() {
    adm_log_info ""
    adm_log_phase_header "Resumo do histórico (db/history)"

    if [[ ! -f "$ADM_DB_HISTORY_FILE" ]]; then
        adm_log_info "  Arquivo de histórico não encontrado: $ADM_DB_HISTORY_FILE"
        return 0
    fi

    local lines size
    lines=$(wc -l <"$ADM_DB_HISTORY_FILE" 2>/dev/null || echo 0)
    size=$(wc -c <"$ADM_DB_HISTORY_FILE" 2>/dev/null || echo 0)

    adm_log_info "Arquivo : $ADM_DB_HISTORY_FILE"
    adm_log_info "Linhas  : $lines"
    adm_log_info "Tamanho : $size bytes"
    adm_log_info ""

    # Agora, faz parsing rico do history:
    #   ts pid action pkg_id version release status msg
    #
    # msg com key=value ... :: texto
    local tmp
    tmp="$(mktemp "$ADM_TMP_DIR/report-history-XXXXXX")" || adm_log_fatal "Falha ao criar tmp history."

    awk -F '\t' '
        NF >= 8 {
            total++

            action=$3
            pkg=$4
            msg=$8

            type=""
            dir=""

            # parse key=value
            n = split(msg, a, " ")
            for (i=1; i<=n; i++) {
                if (a[i] ~ /^type=/) {
                    split(a[i], kv, "=")
                    type=kv[2]
                } else if (a[i] ~ /^direction=/) {
                    split(a[i], kv, "=")
                    dir=kv[2]
                }
            }

            # inferência se type vazio (retrocompat)
            if (type == "") {
                if (action == "INSTALL") {
                    type="install"
                } else if (action == "REMOVE") {
                    type="remove"
                } else if (action == "UPGRADE") {
                    # se direção não veio, assume upgrade
                    if (dir == "downgrade") {
                        type="downgrade"
                    } else {
                        type="upgrade"
                    }
                } else if (action ~ /^SNAPSHOT/) {
                    type="snapshot"
                } else {
                    type="other"
                }
            }

            count_type[type]++

            if (type == "install") {
                if (pkg != "") inst_pkg[pkg]++
            } else if (type == "remove") {
                if (pkg != "") rem_pkg[pkg]++
            } else if (type == "upgrade") {
                if (pkg != "") upg_pkg[pkg]++
            } else if (type == "downgrade") {
                if (pkg != "") down_pkg[pkg]++
            } else if (type == "snapshot") {
                if (action == "SNAPSHOT_CREATE") snaps_create++
                else if (action == "SNAPSHOT_RESTORE") snaps_restore++
                else snaps_other++
            }
        }
        END {
            # SUMMARY
            printf "SUMMARY\tlines\t%d\n", total
            # tipos
            for (t in count_type) {
                printf "TYPE\t%s\t%d\n", t, count_type[t]
            }
            # pacotes por tipo
            for (p in inst_pkg)   printf "INST_PKG\t%s\t%d\n", p, inst_pkg[p]
            for (p in upg_pkg)    printf "UPG_PKG\t%s\t%d\n", p, upg_pkg[p]
            for (p in down_pkg)   printf "DOWN_PKG\t%s\t%d\n", p, down_pkg[p]
            for (p in rem_pkg)    printf "REM_PKG\t%s\t%d\n", p, rem_pkg[p]
            # snapshots
            printf "SNAPS\tcreate\t%d\n", (snaps_create+0)
            printf "SNAPS\trestore\t%d\n", (snaps_restore+0)
            printf "SNAPS\tother\t%d\n", (snaps_other+0)
        }
    ' "$ADM_DB_HISTORY_FILE" >"$tmp"

    if [[ ! -s "$tmp" ]]; then
        adm_log_info "History vazio."
        rm -f "$tmp" || true
        return 0
    fi

    # Ler SUMMARY
    local total_hist
    total_hist=$(awk -F '\t' '$1=="SUMMARY"{print $3}' "$tmp" 2>/dev/null || echo 0)
    adm_log_info "Entradas totais no history: $total_hist"
    adm_log_info ""

    adm_log_info "Contagem por tipo (type=...):"
    awk -F '\t' '
        $1=="TYPE" {
            printf "  - %-10s : %d\n", $2, $3
        }
    ' "$tmp" | sort

    adm_log_info ""
    adm_log_info "Snapshots:"
    awk -F '\t' '
        $1=="SNAPS" {
            printf "  - %-8s : %d\n", $2, $3
        }
    ' "$tmp" | sort

    # Top 5 por install/upgrade/downgrade

    adm_log_info ""
    adm_log_info "Top 5 pacotes mais instalados:"
    local rank
    rank=0
    awk -F '\t' '$1=="INST_PKG"{print $2 "\t" $3}' "$tmp" \
        | sort -t $'\t' -k2,2nr \
        | while IFS=$'\t' read -r pkg count; do
            rank=$((rank + 1))
            printf "  %2d. %-40s %6d installs\n" "$rank" "$pkg" "$count"
            if [[ "$rank" -ge 5 ]]; then
                break
            fi
        done

    adm_log_info ""
    adm_log_info "Top 5 pacotes mais upgradados:"
    rank=0
    awk -F '\t' '$1=="UPG_PKG"{print $2 "\t" $3}' "$tmp" \
        | sort -t $'\t' -k2,2nr \
        | while IFS=$'\t' read -r pkg count; do
            rank=$((rank + 1))
            printf "  %2d. %-40s %6d upgrades\n" "$rank" "$pkg" "$count"
            if [[ "$rank" -ge 5 ]]; then
                break
            fi
        done

    adm_log_info ""
    adm_log_info "Top 5 pacotes com mais downgrades:"
    rank=0
    awk -F '\t' '$1=="DOWN_PKG"{print $2 "\t" $3}' "$tmp" \
        | sort -t $'\t' -k2,2nr \
        | while IFS=$'\t' read -r pkg count; do
            rank=$((rank + 1))
            printf "  %2d. %-40s %6d downgrades\n" "$rank" "$pkg" "$count"
            if [[ "$rank" -ge 5 ]]; then
                break
            fi
        done

    rm -f "$tmp" || true

    adm_log_info ""
    adm_log_info "Últimas 5 entradas do history:"
    tail -n 5 "$ADM_DB_HISTORY_FILE" 2>/dev/null | sed 's/^/    /'
}

# =========
# Relatório: usage completo (métricas + history)
# =========

adm_report_usage() {
    adm_report_usage_metrics
    adm_report_usage_history
}

# =========
# CLI
# =========

adm_report_usage_text() {
    cat <<EOF
adm-report - Relatórios de métricas e histórico do ADM 2.0

Uso:

  Pacotes que mais demoram (por tempo médio, top N):
    adm-report top-time [N]

      - Usa métricas "duration" de todos os ops.
      - Mostra: Rank, Pacote, tempo médio, tempo total, número de execuções.

  Pacotes que mais falham (top N por falhas):
    adm-report top-fail [N]

      - Usa "duration" + campo extra com "rc=..." do adm-metrics.
      - Mostra: Rank, Pacote, número de falhas, número de execuções, taxa de falha (%).

  Estatísticas gerais de uso (métricas + history):
    adm-report usage

      - A partir de métricas:
          * total de registros
          * número de pacotes distintos
          * contagem por op (BUILD, FETCH, SCAN, CHECK, UPDATE, etc.)
          * top 5 pacotes com mais BUILD

      - A partir de history:
          * total de entradas
          * contagem por tipo:
                install / upgrade / downgrade / remove / snapshot / other
          * top 5 pacotes:
                - mais instalados
                - mais upgradados
                - mais downgrades
          * contagem de snapshots:
                - create
                - restore
                - outros
          * últimas 5 linhas do history para inspeção rápida.

  Ajuda:
    adm-report --help

EOF
}

adm_report_main() {
    local cmd="${1:-}"

    case "$cmd" in
        top-time)
            shift || true
            adm_report_top_time "${1:-10}"
            ;;
        top-fail)
            shift || true
            adm_report_top_fail "${1:-10}"
            ;;
        usage)
            shift || true
            adm_report_usage
            ;;
        --help|-h|"")
            adm_report_usage_text
            ;;
        *)
            adm_log_fatal "Comando desconhecido para adm-report: '$cmd'"
            ;;
    esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    adm_report_main "$@"
fi

# Fim do adm-report
