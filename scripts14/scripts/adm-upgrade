#!/usr/bin/env bash
# adm-upgrade - Orquestrador de upgrades do ADM 2.0
#
# Responsável por:
#   - Ler lista de pacotes pendentes (gerada pelo adm-update) ou listas manuais
#   - Resolver ordem de build com base em dependências (adm-deps)
#   - Rebuildar apenas o que realmente precisa (versão/release diferente ou ausente)
#   - Suportar --force para rebuildar mesmo sem nova versão
#   - Integrar com adm-build (pipeline completo) e adm-db
#
# Fonte padrão da lista:
#   - ${ADM_DB_DIR}/updates/pending.list  (manipulado por adm-update)
#
# CLI:
#   adm-upgrade pending [--force]
#       - Lê pending.list, resolve deps e upgradeia apenas o necessário.
#
#   adm-upgrade pending-group GROUP [--force]
#       - Usa apenas os pacotes que estão em pending.list E no grupo GROUP.
#
#   adm-upgrade base [--force]
#       - Atalho para: pending-group base
#
#   adm-upgrade xorg [--force]
#       - Atalho para: pending-group xorg
#
#   adm-upgrade toolchain [--force]
#       - Atalho para: pending-group toolchain
#
#   adm-upgrade file LISTA.txt [--force]
#       - Lê pacotes (um por linha) de LISTA.txt, resolve deps e upgradeia.
#
#   adm-upgrade pkgs PKG1 [PKG2 ...] [--force]
#       - Usa a lista passada na linha de comando.
#
#   
## upgrade de tudo que está pendente
#  adm-upgrade pending
# 
# só o que é do grupo base dentro do pending.list
#  adm-upgrade base
# 
# só xorg pendente
#  adm-upgrade xorg
# 
# só toolchain pendente
#  adm-upgrade toolchain
#   adm-upgrade list-pending
#   adm-upgrade clear-pending
#
# Exemplos:
#   # Descobrir updates primeiro:
#   adm-update apply base/coreutils
#   adm-update apply base/bash
#
#   # Forçar rebuild:
#   ADM_UPGRADE_FORCE=1 adm-upgrade pending
#   adm-upgrade pending --force
#
# Flags:
#   --force -> força rebuild (passa ADM_BUILD_FORCE=1 para adm-build)
#   ADM_UPGRADE_FORCE=1 (equivalente ao --force)
#
# Lógica de "rebuild só se precisar":
#   - Se houver funções adm_db_get_installed_version/adm_db_get_installed_release:
#       * lê versão/release instalados e compara com metadado atual
#       * se meta==instalado e not --force -> pula pacote
#   - Se não houver função no adm-db:
#       * assume que precisa rebuildar (comportamento conservador)

set -o errexit
set -o nounset
set -o pipefail

# =========
# Carrega ambiente e módulos
# =========

_adm_upgrade_script_dir() {
    local src="${BASH_SOURCE[0]:-$0}"

    while [ -L "$src" ]; do
        local target
        target=$(readlink "$src") || break
        if [[ "$target" = /* ]]; then
            src="$target"
        else
            src="$(dirname "$src")/$target"
        fi
    done

    cd "$(dirname "$src")" >/dev/null 2>&1 || {
        printf 'ADM-ERROR: Não foi possível entrar no diretório do script adm-upgrade.\n' >&2
        exit 1
    }
    pwd
}

_ADM_UPGRADE_DIR="$(_adm_upgrade_script_dir)"

# shellcheck disable=SC1090
source "$_ADM_UPGRADE_DIR/adm-env"
# shellcheck disable=SC1090
source "$_ADM_UPGRADE_DIR/adm-log-ui"
# shellcheck disable=SC1090
source "$_ADM_UPGRADE_DIR/adm-eventd"
# shellcheck disable=SC1090
source "$_ADM_UPGRADE_DIR/adm-metrics"
# shellcheck disable=SC1090
source "$_ADM_UPGRADE_DIR/adm-db"
# shellcheck disable=SC1090
source "$_ADM_UPGRADE_DIR/adm-deps"
# shellcheck disable=SC1090
source "$_ADM_UPGRADE_DIR/adm-knowledge"
# shellcheck disable=SC1090
source "$_ADM_UPGRADE_DIR/adm-build"
# shellcheck disable=SC1090
source "$_ADM_UPGRADE_DIR/adm-update"

ADM_UPGRADE_FORCE="${ADM_UPGRADE_FORCE:-0}"

ADM_DB_UPDATES_DIR="${ADM_DB_DIR}/updates"
ADM_DB_UPDATES_PENDING="${ADM_DB_UPDATES_DIR}/pending.list"

# =========
# Utilidades de metadado / versões
# =========

adm_upgrade_metadado_path() {
    adm_deps_metadado_path "$1"
}

adm_upgrade_read_meta_single() {
    local file="${1:-}"
    local key="${2:-}"

    if [[ ! -f "$file" ]]; then
        adm_log_fatal "adm-upgrade: metadado não encontrado: '$file'"
    fi

    awk -v k="$key" -F':' '
        $1 ~ "^[[:space:]]*"k"[[:space:]]*$" && NF==1 {
            if (getline line > 0) {
                sub(/^[[:space:]]+/, "", line)
                sub(/[[:space:]]+$/, "", line)
                print line
                exit 0
            }
        }
        $1 ~ "^[[:space:]]*"k"[[:space:]]*" && NF>=2 {
            $1=""
            sub(/^[[:space:]]+/, "", $0)
            print $0
            exit 0
        }
    ' "$file"
}

adm_upgrade_meta_version_for_pkg() {
    local pkg_id="$1"
    local meta
    meta="$(adm_upgrade_metadado_path "$pkg_id")"
    adm_upgrade_read_meta_single "$meta" "version" || echo "unknown"
}

adm_upgrade_meta_release_for_pkg() {
    local pkg_id="$1"
    local meta
    meta="$(adm_upgrade_metadado_path "$pkg_id")"
    adm_upgrade_read_meta_single "$meta" "release" || echo "1"
}

adm_upgrade_db_version_for_pkg() {
    # Tenta obter versão instalada do adm-db, se houver função disponível.
    #
    # Uso:
    #   adm_upgrade_db_version_for_pkg PKG_ID
    #
    # Saída:
    #   version (ou vazio se não conseguir)
    local pkg_id="$1"

    if [[ "$(type -t adm_db_get_installed_version || true)" == "function" ]]; then
        adm_db_get_installed_version "$pkg_id" || true
    else
        # Sem suporte no adm-db: não sabemos
        printf '\n'
    fi
}

adm_upgrade_db_release_for_pkg() {
    # Tenta obter release instalado do adm-db, se houver função disponível.
    local pkg_id="$1"

    if [[ "$(type -t adm_db_get_installed_release || true)" == "function" ]]; then
        adm_db_get_installed_release "$pkg_id" || true
    else
        printf '\n'
    fi
}

# =========
# Pending list compatível com adm-update
# =========

adm_upgrade_pending_list() {
    if [[ ! -f "$ADM_DB_UPDATES_PENDING" ]]; then
        return 0
    fi
    cat "$ADM_DB_UPDATES_PENDING"
}

adm_upgrade_pending_remove_pkg() {
    # Remove PKG_ID da pending.list após upgrade bem sucedido.
    local pkg_id="${1:-}"

    if [[ -z "$pkg_id" ]]; then
        return 0
    fi
    if [[ ! -f "$ADM_DB_UPDATES_PENDING" ]]; then
        return 0
    fi

    adm_with_lock "updates-pending" bash -c '
        local file="$1" pkg="$2"
        if [[ ! -f "$file" ]]; then
            exit 0
        fi
        tmp="${file}.tmp"
        grep -vxF "$pkg" "$file" >"$tmp" 2>/dev/null || true
        mv "$tmp" "$file"
    ' _ "$ADM_DB_UPDATES_PENDING" "$pkg_id"
}

adm_upgrade_pending_clear() {
    if [[ -f "$ADM_DB_UPDATES_PENDING" ]]; then
        rm -f "$ADM_DB_UPDATES_PENDING" \
            || adm_log_fatal "Não foi possível remover '$ADM_DB_UPDATES_PENDING'."
    fi
    adm_log_ok "Fila de upgrade (pending.list) limpa."
}

# =========
# Carregar lista de pacotes a partir de várias fontes
# =========

adm_upgrade_load_list_from_pending() {
    # Lê pending.list, ignorando linhas vazias e comentários.
    if [[ ! -f "$ADM_DB_UPDATES_PENDING" ]]; then
        adm_log_info "Nenhum pacote pendente em '$ADM_DB_UPDATES_PENDING'."
        return 0
    fi

    awk 'NF>0 && $1 !~ /^#/ {print $1}' "$ADM_DB_UPDATES_PENDING"
}

adm_upgrade_load_list_from_file() {
    local file="${1:-}"

    if [[ -z "$file" ]]; then
        adm_log_fatal "adm-upgrade: nenhum arquivo fornecido para lista."
    fi
    if [[ ! -f "$file" ]]; then
        adm_log_fatal "Lista não encontrada: '$file'"
    fi

    awk 'NF>0 && $1 !~ /^#/ {print $1}' "$file"
}

adm_upgrade_load_list_from_args() {
    # Apenas ecoa argumentos, filtrando vazios.
    local out=()
    local p
    for p in "$@"; do
        [[ -z "$p" ]] && continue
        out+=("$p")
    done
    printf '%s\n' "${out[@]:-}"
}

adm_upgrade_pkg_in_group() {
    # Retorna 0 se PKG_ID tiver GROUP em "groups:" do metadado
    local pkg_id="${1:-}"
    local group="${2:-}"

    if [[ -z "$pkg_id" || -z "$group" ]]; then
        return 1
    fi

    local groups
    groups="$(adm_deps_get_groups "$pkg_id" 2>/dev/null || true)"

    local g
    for g in $groups; do
        if [[ "$g" == "$group" ]]; then
            return 0
        fi
    done

    return 1
}

adm_upgrade_load_list_from_pending_group() {
    # Interseção: pending.list ∩ pacotes que pertencem ao grupo GROUP
    #
    # Uso:
    #   adm_upgrade_load_list_from_pending_group GROUP
    local group="${1:-}"

    if [[ -z "$group" ]]; then
        adm_log_fatal "Uso: adm_upgrade_load_list_from_pending_group GROUP"
    fi

    local p
    while IFS= read -r p; do
        [[ -z "$p" ]] && continue
        if adm_upgrade_pkg_in_group "$p" "$group"; then
            printf '%s\n' "$p"
        fi
    done < <(adm_upgrade_load_list_from_pending)
}

# =========
# Decidir se um pacote precisa rebuild
# =========

adm_upgrade_should_build_pkg() {
    # Decide se precisa rebuildar PKG_ID.
    #
    # Uso:
    #   adm_upgrade_should_build_pkg PKG_ID
    #
    # Retorno:
    #   0 -> deve buildar
    #   1 -> pode pular
    #
    # Lógica:
    #   - Se ADM_UPGRADE_FORCE=1 -> sempre 0 (build)
    #   - Se metadado não existe -> build (erro é tratado antes)
    #   - Se não houver funções de DB -> build (comportamento conservador)
    #   - Se houver DB:
    #       * lê versão/release do meta e do DB
    #       * se DB vazio -> build
    #       * se meta != DB -> build
    #       * se meta == DB -> skip (retorna 1)
    local pkg_id="$1"

    if [[ "$ADM_UPGRADE_FORCE" -eq 1 ]]; then
        return 0
    fi

    local meta
    meta="$(adm_upgrade_metadado_path "$pkg_id")"

    if [[ ! -f "$meta" ]]; then
        # Chamador já deve emitir erro de metadado; aqui, treat as "needs build"
        return 0
    fi

    local meta_ver meta_rel db_ver db_rel
    meta_ver="$(adm_upgrade_meta_version_for_pkg "$pkg_id")"
    meta_rel="$(adm_upgrade_meta_release_for_pkg "$pkg_id")"
    db_ver="$(adm_upgrade_db_version_for_pkg "$pkg_id")"
    db_rel="$(adm_upgrade_db_release_for_pkg "$pkg_id")"

    # Se DB não sabe nada, assume que precisa rebuild
    if [[ -z "$db_ver" && -z "$db_rel" ]]; then
        return 0
    fi

    if [[ "$meta_ver" == "$db_ver" && "$meta_rel" == "$db_rel" ]]; then
        # Já instalada mesma versão/release
        return 1
    fi

    # Versão ou release mudou -> rebuild
    return 0
}

# =========
# Upgrade de um pacote (chama adm-build)
# =========

adm_upgrade_build_pkg_core() {
    # Uso:
    #   adm_upgrade_build_pkg_core PKG_ID
    #
    # - Verifica se deve buildar (adm_upgrade_should_build_pkg)
    # - Se sim, chama adm-build build-one com ADM_BUILD_FORCE ajustado.
    local pkg_id="$1"

    local meta
    meta="$(adm_upgrade_metadado_path "$pkg_id")"
    if [[ ! -f "$meta" ]]; then
        adm_log_error "Metadado não encontrado para $pkg_id; não é possível upgradear."
        return 1
    fi

    local meta_ver meta_rel db_ver db_rel
    meta_ver="$(adm_upgrade_meta_version_for_pkg "$pkg_id")"
    meta_rel="$(adm_upgrade_meta_release_for_pkg "$pkg_id")"
    db_ver="$(adm_upgrade_db_version_for_pkg "$pkg_id")"
    db_rel="$(adm_upgrade_db_release_for_pkg "$pkg_id")"

    if adm_upgrade_should_build_pkg "$pkg_id"; then
        if [[ "$ADM_UPGRADE_FORCE" -eq 1 ]]; then
            adm_log_phase_header "Upgrade (FORÇADO) de $pkg_id -> $meta_ver-$meta_rel"
        else
            adm_log_phase_header "Upgrade de $pkg_id: $db_ver-$db_rel → $meta_ver-$meta_rel"
        fi

        if ! command -v adm-build >/dev/null 2>&1; then
            adm_log_fatal "'adm-build' não encontrado no PATH; não é possível upgradear."
        fi

        # Passa ADM_BUILD_FORCE conforme ADM_UPGRADE_FORCE
        if [[ "$ADM_UPGRADE_FORCE" -eq 1 ]]; then
            ADM_BUILD_FORCE=1 adm-build build-one "$pkg_id"
        else
            ADM_BUILD_FORCE=0 adm-build build-one "$pkg_id"
        fi

        # Se sucesso, removemos da pending.list
        adm_upgrade_pending_remove_pkg "$pkg_id"
        adm_event_pkg "PKG_UPGRADE_DONE" "$pkg_id" "version=$meta_ver release=$meta_rel"
        return 0
    else
        adm_log_info "Pacote já está na versão/release atual: $pkg_id ($meta_ver-$meta_rel); pulando (use --force para rebuild)."
        # Mesmo assim, se estava na lista pending, removemos – já está atualizado
        adm_upgrade_pending_remove_pkg "$pkg_id"
        adm_event_pkg "PKG_UPGRADE_SKIPPED" "$pkg_id" "reason=up-to-date"
        return 0
    fi
}

adm_upgrade_build_pkg() {
    # Wrapper com métricas
    local pkg_id="$1"
    adm_metrics_time_block "UPGRADE" "$pkg_id" "adm_upgrade_build_pkg" \
        adm_upgrade_build_pkg_core "$pkg_id"
}

# =========
# Orquestra upgrade de uma lista de pacotes
# =========

adm_upgrade_run_for_list() {
    # Uso:
    #   adm_upgrade_run_for_list PKG1 [PKG2 ...]
    #
    # Passos:
    #   - Limpa entradas duplicadas
    #   - Calcula ordem de build com adm-deps (deps antes dos dependentes)
    #   - Para cada pacote na ordem:
    #       * Decidir se precisa rebuild (adm_upgrade_should_build_pkg)
    #       * Chamar adm-build se necessário
    if [[ $# -lt 1 ]]; then
        adm_log_warn "adm-upgrade: lista vazia; nada para fazer."
        return 0
    fi

    local pkgs=()
    local p
    for p in "$@"; do
        [[ -z "$p" ]] && continue
        pkgs+=("$p")
    done

    # Dedup
    local tmp
    tmp="$(mktemp "$ADM_TMP_DIR/upgrade-list-XXXXXX")" \
        || adm_log_fatal "Falha ao criar tmp para upgrade list."

    printf '%s\n' "${pkgs[@]}" \
        | awk 'NF>0 {print $1}' \
        | awk '!seen[$0]++' >"$tmp"

    mapfile -t pkgs <"$tmp"
    rm -f "$tmp" || true

    if [[ ${#pkgs[@]} -eq 0 ]]; then
        adm_log_warn "adm-upgrade: lista final vazia; nada para fazer."
        return 0
    fi

    adm_log_phase_header "Resolvendo ordem de upgrade para: ${pkgs[*]}"

    # Ordem de build com deps (adm-deps)
    local order
    if ! order="$(adm_deps_build_order "${pkgs[@]}")"; then
        adm_log_fatal "Falha ao calcular ordem de build para upgrade."
    fi

    adm_log_info "Ordem de build calculada:"
    printf '%s\n' "$order" | sed 's/^/ - /'

    adm_event_emit "UPGRADE_START" "-" "pkgs=${pkgs[*]}"

    local pkg rc
    rc=0
    while IFS= read -r pkg; do
        [[ -z "$pkg" ]] && continue
        if ! adm_upgrade_build_pkg "$pkg"; then
            adm_log_error "Falha ao upgradear $pkg."
            rc=1
            # não abortamos a sequência inteira; tentamos continuar
        fi
    done <<<"$order"

    adm_event_emit "UPGRADE_DONE" "-" "rc=$rc"
    return "$rc"
}

# =========
# CLI
# =========

adm_upgrade_usage() {
    cat <<EOF
adm-upgrade - Orquestrador de upgrades do ADM 2.0

Uso:
  adm-upgrade pending [--force]
      Upgradeia todos os pacotes listados em:
        ${ADM_DB_UPDATES_PENDING}

  adm-upgrade pending-group GROUP [--force]
      Upgradeia apenas os pacotes que:
        - estão em pending.list
        - e pertencem ao grupo GROUP (campo groups: do metadado)

  # Atalhos de grupos comuns (consomem pending.list):

  adm-upgrade base [--force]
      -> equivalente a: adm-upgrade pending-group base

  adm-upgrade xorg [--force]
      -> equivalente a: adm-upgrade pending-group xorg

  adm-upgrade toolchain [--force]
      -> equivalente a: adm-upgrade pending-group toolchain

  # Outras fontes de lista:

  adm-upgrade file LISTA.txt [--force]
      Lê pacotes (um por linha) de LISTA.txt e upgradeia.

  adm-upgrade pkgs PKG1 [PKG2 ...] [--force]
      Usa a lista passada na linha de comando.

  # Gerenciamento da pending.list:

  adm-upgrade list-pending
      Mostra o conteúdo bruto de pending.list.

  adm-upgrade clear-pending
      Limpa a pending.list.

Flags:
  --force
      Força rebuild mesmo se versão/release instalada já for igual ao metadado.
      Equivalente a:
        ADM_UPGRADE_FORCE=1

Exemplos:
  adm-update apply base/coreutils
  adm-update apply base/bash
  adm-upgrade pending

  adm-upgrade base
  adm-upgrade xorg --force
  ADM_UPGRADE_FORCE=1 adm-upgrade pending
EOF
}

adm_upgrade_main() {
    local args=()
    local a

    # Parse de flags globais (por enquanto só --force)
    for a in "$@"; do
        case "$a" in
            --force)
                ADM_UPGRADE_FORCE=1
                ;;
            *)
                args+=("$a")
                ;;
        esac
    done

    set -- "${args[@]:-}"

    local cmd="${1:-}"
    shift || true

    local pkgs=()

    case "$cmd" in
        pending)
            mapfile -t pkgs < <(adm_upgrade_load_list_from_pending)
            ;;
        pending-group)
            if [[ $# -lt 1 ]]; then
                adm_log_fatal "Uso: adm-upgrade pending-group GROUP [--force]"
            fi
            local group="$1"; shift || true
            mapfile -t pkgs < <(adm_upgrade_load_list_from_pending_group "$group")
            ;;
        base|xorg|toolchain)
            # atalhos fixos de grupo usando pending.list
            mapfile -t pkgs < <(adm_upgrade_load_list_from_pending_group "$cmd")
            ;;
        file)
            if [[ $# -lt 1 ]]; then
                adm_log_fatal "Uso: adm-upgrade file LISTA.txt [--force]"
            fi
            local file="$1"; shift || true
            mapfile -t pkgs < <(adm_upgrade_load_list_from_file "$file")
            ;;
        pkgs)
            if [[ $# -lt 1 ]]; then
                adm_log_fatal "Uso: adm-upgrade pkgs PKG1 [PKG2 ...] [--force]"
            fi
            mapfile -t pkgs < <(adm_upgrade_load_list_from_args "$@")
            ;;
        list-pending)
            adm_upgrade_pending_list
            return 0
            ;;
        clear-pending)
            adm_upgrade_pending_clear
            return 0
            ;;
        help|--help|-h|"")
            adm_upgrade_usage
            return 0
            ;;
        *)
            adm_log_fatal "Comando desconhecido para adm-upgrade: '$cmd'"
            ;;
    esac

    if [[ ${#pkgs[@]} -eq 0 ]]; then
        adm_log_warn "adm-upgrade: nenhuma entrada para '$cmd'; nada para fazer."
        return 0
    fi

    adm_upgrade_run_for_list "${pkgs[@]}"
}

if [[ "${BASH_SOURCE[0]:-$0}" == "$0" ]]; then
    adm_upgrade_main "$@"
fi
