#!/usr/bin/env bash
# adm-db - Camada de acesso ao banco de dados do ADM 2.0
# /root/usr/src/adm/scripts/
#
# Responsável por:
#   - Registrar/leitura de pacotes instalados (db/installed/)
#   - Registrar histórico de ações (db/history/)
#   - Gerenciar upgrade-list (db/upgrade-list)
#
# Pode ser sourceado por outros scripts ou usado via CLI para debug.
#
# Histórico rico:
#   - adm_db_history_install    -> INSTALL
#   - adm_db_history_remove     -> REMOVE
#   - adm_db_history_upgrade    -> UPGRADE (upgrade/downgrade, planned/applied)
#   - adm_db_history_snapshot   -> SNAPSHOT_CREATE / SNAPSHOT_DIFF / SNAPSHOT_RESTORE / etc.
#
# Formato history:
#   ts\tpid\taction\tpkg_id\tversion\trelease\tstatus\tmsg
#
# Onde msg é uma string "k=v ... :: extra texto livre"

set -o errexit
set -o nounset
set -o pipefail

# =========
# Carrega ambiente, UI e eventos
# =========

_adm_db_script_dir() {
    local src="${BASH_SOURCE[0]:-$0}"

    while [ -L "$src" ]; do
        local target
        target=$(readlink "$src") || break
        if [[ "$target" = /* ]]; then
            src="$target"
        else
            src="$(dirname "$src")/$target"
        fi
    done

    cd "$(dirname "$src")" >/dev/null 2>&1 || {
        printf 'ADM-ERROR: Não foi possível entrar no diretório do script adm-db.\n' >&2
        exit 1
    }
    pwd
}

_ADM_DB_DIR="$(_adm_db_script_dir)"

# shellcheck disable=SC1090
source "$_ADM_DB_DIR/adm-env"
# shellcheck disable=SC1090
source "$_ADM_DB_DIR/adm-log-ui"
# shellcheck disable=SC1090
source "$_ADM_DB_DIR/adm-eventd"

# Garante diretórios básicos do DB
if [[ ! -d "$ADM_DB_INSTALLED_DIR" ]]; then
    mkdir -p "$ADM_DB_INSTALLED_DIR" \
        || adm_log_fatal "Falha ao criar '$ADM_DB_INSTALLED_DIR'."
fi

if [[ ! -d "$ADM_DB_HISTORY_DIR" ]]; then
    mkdir -p "$ADM_DB_HISTORY_DIR" \
        || adm_log_fatal "Falha ao criar '$ADM_DB_HISTORY_DIR'."
fi

# =========
# Utilidades internas
# =========

adm_db_pkg_parse_id() {
    # Divide um pkg_id no formato categoria/pacote
    # Uso:
    #   read cat name < <(adm_db_pkg_parse_id "base/kmod")
    local pkg_id="${1:-}"

    if [[ "$pkg_id" != */* ]]; then
        adm_log_fatal "pkg_id inválido (esperado categoria/pacote): '$pkg_id'"
    fi

    local cat="${pkg_id%%/*}"
    local name="${pkg_id##*/}"
    printf '%s %s\n' "$cat" "$name"
}

adm_db_pkg_file() {
    # Retorna o caminho do arquivo de DB para um pkg_id
    # Uso:
    #   f=$(adm_db_pkg_file "base/kmod")
    local pkg_id="${1:-}"
    local cat name
    read -r cat name < <(adm_db_pkg_parse_id "$pkg_id")
    printf '%s/%s__%s.pkg\n' "$ADM_DB_INSTALLED_DIR" "$cat" "$name"
}

adm_db_pkg_exists() {
    # Retorna 0 se um pkg_id está instalado (arquivo existe), 1 caso contrário
    local pkg_id="${1:-}"
    local file
    file="$(adm_db_pkg_file "$pkg_id")"
    [[ -f "$file" ]]
}

# =========
# Registro de instalação
# =========

adm_db_register_install() {
    # Registra que um pacote foi instalado.
    #
    # Uso:
    #   adm_db_register_install \
    #       pkg_id version release profile libc files_list_path [build_id]
    #
    # Onde:
    #   - pkg_id: "categoria/pacote"
    #   - version: versão
    #   - release: release
    #   - profile: perfil (pode ser "-")
    #   - libc: libc usada (glibc, musl, etc. pode ser "-")
    #   - files_list_path: arquivo temporário com lista de arquivos (um por linha)
    #   - build_id: identificador de build (opcional; pode ser "-")

    if [[ $# -lt 6 ]]; then
        adm_log_fatal "adm_db_register_install: uso: adm_db_register_install pkg_id version release profile libc files_list_path [build_id]"
    fi

    local pkg_id="$1"
    local version="$2"
    local release="$3"
    local profile="$4"
    local libc="$5"
    local files_list="$6"
    local build_id="${7:-"-"}"

    if [[ ! -f "$files_list" ]]; then
        adm_log_fatal "adm_db_register_install: lista de arquivos não encontrada: '$files_list'"
    fi

    local cat name file ts_epoch ts_human
    read -r cat name < <(adm_db_pkg_parse_id "$pkg_id")
    file="$(adm_db_pkg_file "$pkg_id")"
    ts_epoch="$(date +%s)"
    ts_human="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"

    adm_with_lock "db-installed" bash -c '
        local file="$1" pkg_id="$2" cat="$3" name="$4"
        local version="$5" release="$6" profile="$7" libc="$8"
        local files_list="$9" ts_epoch="${10}" ts_human="${11}" build_id="${12}"

        # Garante diretório
        mkdir -p "$(dirname "$file")" || {
            printf "ADM-ERROR: falha ao criar diretório para %s\n" "$file" >&2
            exit 1
        }

        {
            printf "[meta]\n"
            printf "pkg_id=%s\n" "$pkg_id"
            printf "name=%s\n" "$name"
            printf "category=%s\n" "$cat"
            printf "version=%s\n" "$version"
            printf "release=%s\n" "$release"
            printf "profile=%s\n" "$profile"
            printf "libc=%s\n" "$libc"
            printf "build_id=%s\n" "$build_id"
            printf "install_time_epoch=%s\n" "$ts_epoch"
            printf "install_time_human=%s\n" "$ts_human"
            printf "\n[files]\n"
            cat "$files_list"
        } >"$file.tmp" || {
            printf "ADM-ERROR: falha ao escrever arquivo temporário para %s\n" "$file" >&2
            exit 1
        }

        mv "$file.tmp" "$file" || {
            printf "ADM-ERROR: falha ao substituir arquivo de instalado %s\n" "$file" >&2
            exit 1
        }
    ' _ "$file" "$pkg_id" "$cat" "$name" "$version" "$release" "$profile" "$libc" \
        "$files_list" "$ts_epoch" "$ts_human" "$build_id"

    adm_log_ok "Registrado pacote instalado: $pkg_id $version-$release"
    adm_event_pkg "PKG_INSTALL_REGISTERED" "$pkg_id" \
        "version=$version release=$release profile=$profile libc=$libc"

    # Histórico rico de instalação
    local files_count
    files_count=$(wc -l <"$files_list" 2>/dev/null || echo 0)
    adm_db_history_install \
        "$pkg_id" "$version" "$release" "$profile" "$libc" "$build_id" \
        "OK" "files=${files_count}"
}

adm_db_remove_install() {
    # Remove registro de instalação de um pacote (não remove arquivos de /usr)
    # Uso:
    #   adm_db_remove_install pkg_id
    local pkg_id="${1:-}"

    if [[ -z "$pkg_id" ]]; then
        adm_log_fatal "adm_db_remove_install: pkg_id não informado."
    fi

    local file
    file="$(adm_db_pkg_file "$pkg_id")"

    if [[ ! -f "$file" ]]; then
        adm_log_warn "adm_db_remove_install: registro de $pkg_id não existe."
        return 0
    fi

    # Lê alguns metadados ANTES de remover o arquivo, para log/histórico
    local version release profile libc
    version="$(adm_db_get_meta_value "$pkg_id" "version" || echo "-")"
    release="$(adm_db_get_meta_value "$pkg_id" "release" || echo "-")"
    profile="$(adm_db_get_meta_value "$pkg_id" "profile" || echo "-")"
    libc="$(adm_db_get_meta_value "$pkg_id" "libc" || echo "-")"

    adm_with_lock "db-installed" bash -c '
        local file="$1"
        rm -f "$file" || {
            printf "ADM-ERROR: falha ao remover arquivo %s\n" "$file" >&2
            exit 1
        }
    ' _ "$file"

    adm_log_ok "Removido registro de instalado: $pkg_id"
    adm_event_pkg "PKG_INSTALL_REMOVED" "$pkg_id" ""

    # Histórico rico de remoção
    adm_db_history_remove "$pkg_id" "$version" "$release" "$profile" "$libc" \
        "OK" "db-record-removed=1"
}

# =========
# Leitura de instalados
# =========

adm_db_list_installed() {
    # Lista pacotes instalados em formato:
    #   pkg_id<TAB>version<TAB>release<TAB>profile<TAB>libc
    local f pkg_id version release profile libc

    for f in "$ADM_DB_INSTALLED_DIR"/*.pkg; do
        [[ -e "$f" ]] || continue

        pkg_id=""
        version=""
        release=""
        profile=""
        libc=""

        while IFS='=' read -r key val; do
            case "$key" in
                pkg_id)  pkg_id="$val" ;;
                version) version="$val" ;;
                release) release="$val" ;;
                profile) profile="$val" ;;
                libc)    libc="$val" ;;
            esac
        done < <(awk '
            BEGIN{inmeta=0}
            /^\[meta\]/{inmeta=1;next}
            /^\[/{inmeta=0}
            inmeta && NF>0{print}
        ' "$f")

        if [[ -n "$pkg_id" ]]; then
            printf '%s\t%s\t%s\t%s\t%s\n' \
                "$pkg_id" "$version" "$release" "$profile" "$libc"
        fi
    done
}

adm_db_get_meta_value() {
    # Lê um valor específico do [meta] de um pacote.
    #
    # Uso:
    #   adm_db_get_meta_value pkg_id chave
    # Saída:
    #   valor (stdout). Retorno 0 se encontrado, 1 se não.
    if [[ $# -lt 2 ]]; then
        adm_log_fatal "adm_db_get_meta_value: uso: adm_db_get_meta_value pkg_id chave"
    fi

    local pkg_id="$1"
    local key_target="$2"
    local file
    file="$(adm_db_pkg_file "$pkg_id")"

    if [[ ! -f "$file" ]]; then
        adm_log_warn "adm_db_get_meta_value: pacote não registrado: $pkg_id"
        return 1
    fi

    local key val
    while IFS='=' read -r key val; do
        if [[ "$key" == "$key_target" ]]; then
            printf '%s\n' "$val"
            return 0
        fi
    done < <(awk '
        BEGIN{inmeta=0}
        /^\[meta\]/{inmeta=1;next}
        /^\[/{inmeta=0}
        inmeta && NF>0{print}
    ' "$file")

    return 1
}

adm_db_list_files() {
    # Lista arquivos de um pacote (seção [files])
    #
    # Uso:
    #   adm_db_list_files pkg_id
    if [[ $# -lt 1 ]]; then
        adm_log_fatal "adm_db_list_files: uso: adm_db_list_files pkg_id"
    fi

    local pkg_id="$1"
    local file
    file="$(adm_db_pkg_file "$pkg_id")"

    if [[ ! -f "$file" ]]; then
        adm_log_warn "adm_db_list_files: pacote não registrado: $pkg_id"
        return 1
    fi

    awk '
        BEGIN{infiles=0}
        /^\[files\]/{infiles=1;next}
        /^\[/{infiles=0}
        infiles{print}
    ' "$file"
}

# =========
# Histórico
# =========

adm_db_history_file_for_today() {
    local day
    day="$(date '+%Y%m%d')"
    printf '%s/history-%s.log\n' "$ADM_DB_HISTORY_DIR" "$day"
}

adm_db_history_append() {
    # Registra uma entrada no histórico.
    #
    # Uso:
    #   adm_db_history_append action pkg_id version release status "mensagem..."
    #
    # Exemplo:
    #   adm_db_history_append BUILD base/kmod 1.0 1 OK "Build concluído"

    if [[ $# -lt 5 ]]; then
        adm_log_fatal "adm_db_history_append: uso: adm_db_history_append action pkg_id version release status [mensagem...]"
    fi

    local action="$1"
    local pkg_id="$2"
    local version="$3"
    local release="$4"
    local status="$5"
    shift 5 || true
    local msg="$*"

    local ts pid file line
    ts="$(date '+%Y-%m-%dT%H:%M:%S%z')"
    pid="$$"
    file="$(adm_db_history_file_for_today)"

    # Sanitiza tabs
    action="${action//$'\t'/ }"
    pkg_id="${pkg_id//$'\t'/ }"
    version="${version//$'\t'/ }"
    release="${release//$'\t'/ }"
    status="${status//$'\t'/ }"
    msg="${msg//$'\t'/ }"

    line=$(printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\n' \
        "$ts" "$pid" "$action" "$pkg_id" "$version" "$release" "$status" "$msg")

    adm_with_lock "db-history" bash -c '
        local file="$1" line="$2"
        mkdir -p "$(dirname "$file")" || {
            printf "ADM-ERROR: falha ao criar diretório de history.\n" >&2
            exit 1
        }
        printf "%s\n" "$line" >>"$file" || {
            printf "ADM-ERROR: falha ao gravar histórico em %s\n" "$file" >&2
            exit 1
        }
    ' _ "$file" "$line"

    adm_event_pkg "HISTORY_$action" "$pkg_id" "status=$status msg=$msg"
}

# =========
# Helpers de histórico ricos
# =========

adm_db_history_install() {
    # Registra evento de instalação.
    #
    # Uso:
    #   adm_db_history_install pkg_id version release profile libc build_id status [msg_livre...]
    #
    # Exemplo:
    #   adm_db_history_install base/bash 5.2 1 glibc/extreme glibc build123 OK "instalação concluída"

    if [[ $# -lt 7 ]]; then
        adm_log_fatal "adm_db_history_install: uso: adm_db_history_install pkg_id version release profile libc build_id status [msg...]"
    fi

    local pkg_id="$1"
    local version="$2"
    local release="$3"
    local profile="$4"
    local libc="$5"
    local build_id="$6"
    local status="$7"
    shift 7 || true
    local extra_msg="$*"

    local kv_msg
    kv_msg="type=install profile=${profile} libc=${libc} build_id=${build_id}"
    if [[ -n "$extra_msg" ]]; then
        kv_msg="${kv_msg} :: ${extra_msg}"
    fi

    adm_db_history_append "INSTALL" "$pkg_id" "$version" "$release" "$status" "$kv_msg"
}

adm_db_history_remove() {
    # Registra evento de remoção de registro de instalação.
    #
    # Uso:
    #   adm_db_history_remove pkg_id version release profile libc status [msg_livre...]

    if [[ $# -lt 6 ]]; then
        adm_log_fatal "adm_db_history_remove: uso: adm_db_history_remove pkg_id version release profile libc status [msg...]"
    fi

    local pkg_id="$1"
    local version="$2"
    local release="$3"
    local profile="$4"
    local libc="$5"
    local status="$6"
    shift 6 || true
    local extra_msg="$*"

    local kv_msg
    kv_msg="type=remove profile=${profile} libc=${libc}"
    if [[ -n "$extra_msg" ]]; then
        kv_msg="${kv_msg} :: ${extra_msg}"
    fi

    adm_db_history_append "REMOVE" "$pkg_id" "$version" "$release" "$status" "$kv_msg"
}

adm_db_history_upgrade() {
    # Registra evento de upgrade/downgrade planejado ou realizado.
    #
    # Uso:
    #   adm_db_history_upgrade pkg_id old_ver old_rel new_ver new_rel status direction [reason] [msg_livre...]
    #
    # direction: "upgrade" ou "downgrade"

    if [[ $# -lt 7 ]]; then
        adm_log_fatal "adm_db_history_upgrade: uso: adm_db_history_upgrade pkg_id old_ver old_rel new_ver new_rel status direction [reason] [msg...]"
    fi

    local pkg_id="$1"
    local old_ver="$2"
    local old_rel="$3"
    local new_ver="$4"
    local new_rel="$5"
    local status="$6"
    local direction="$7"
    shift 7 || true

    local reason="${1:-}"
    if [[ -n "${1:-}" ]]; then
        shift 1 || true
    fi

    local extra_msg="$*"

    local version_for_line="$new_ver"
    local release_for_line="$new_rel"

    local kv_msg
    kv_msg="type=${direction} from=${old_ver}-${old_rel} to=${new_ver}-${new_rel}"
    if [[ -n "$reason" ]]; then
        kv_msg="${kv_msg} reason=${reason}"
    fi
    if [[ -n "$extra_msg" ]]; then
        kv_msg="${kv_msg} :: ${extra_msg}"
    fi

    adm_db_history_append "UPGRADE" "$pkg_id" "$version_for_line" "$release_for_line" "$status" "$kv_msg"
}

adm_db_history_snapshot() {
    # Registra eventos relacionados a snapshots (create/diff/restore).
    #
    # Uso:
    #   adm_db_history_snapshot action snapshot_name status [msg_livre...]
    #
    # Onde "action" pode ser:
    #   SNAPSHOT_CREATE, SNAPSHOT_DIFF, SNAPSHOT_RESTORE, etc.

    if [[ $# -lt 3 ]]; then
        adm_log_fatal "adm_db_history_snapshot: uso: adm_db_history_snapshot action snapshot_name status [msg...]"
    fi

    local action="$1"
    local snap_name="$2"
    local status="$3"
    shift 3 || true
    local extra_msg="$*"

    local kv_msg
    kv_msg="type=snapshot name=${snap_name}"
    if [[ -n "$extra_msg" ]]; then
        kv_msg="${kv_msg} :: ${extra_msg}"
    fi

    # pkg_id é o snapshot, version/release ficam "-"
    adm_db_history_append "$action" "$snap_name" "-" "-" "$status" "$kv_msg"
}

# =========
# Upgrade-list
# =========

adm_db_upgrade_add() {
    # Adiciona/atualiza uma entrada na upgrade-list.
    #
    # Formato da linha:
    #   pkg_id old_ver old_rel new_ver new_rel reason
    #
    # Uso:
    #   adm_db_upgrade_add pkg_id old_ver old_rel new_ver new_rel reason

    if [[ $# -lt 6 ]]; then
        adm_log_fatal "adm_db_upgrade_add: uso: adm_db_upgrade_add pkg_id old_ver old_rel new_ver new_rel reason"
    fi

    local pkg_id="$1"
    local old_ver="$2"
    local old_rel="$3"
    local new_ver="$4"
    local new_rel="$5"
    local reason="$6"

    # Sanitiza tabs
    pkg_id="${pkg_id//$'\t'/ }"
    old_ver="${old_ver//$'\t'/ }"
    old_rel="${old_rel//$'\t'/ }"
    new_ver="${new_ver//$'\t'/ }"
    new_rel="${new_rel//$'\t'/ }"
    reason="${reason//$'\t'/ }"

    adm_with_lock "upgrade-list" bash -c '
        local file="$1" pkg_id="$2" old_ver="$3" old_rel="$4"
        local new_ver="$5" new_rel="$6" reason="$7"

        mkdir -p "$(dirname "$file")" || {
            printf "ADM-ERROR: falha ao criar diretório para upgrade-list.\n" >&2
            exit 1
        }

        # Remove qualquer linha existente para este pkg_id
        local tmp="${file}.tmp"
        if [[ -f "$file" ]]; then
            grep -v -F -e "$pkg_id"$'\t' "$file" >"$tmp" || true
        else
            : >"$tmp"
        fi

        printf "%s\t%s\t%s\t%s\t%s\t%s\n" \
            "$pkg_id" "$old_ver" "$old_rel" "$new_ver" "$new_rel" "$reason" \
            >>"$tmp" || {
            printf "ADM-ERROR: falha ao escrever upgrade-list temporário.\n" >&2
            exit 1
        }

        mv "$tmp" "$file" || {
            printf "ADM-ERROR: falha ao atualizar upgrade-list.\n" >&2
            exit 1
        }
    ' _ "$ADM_DB_UPGRADE_LIST" "$pkg_id" "$old_ver" "$old_rel" "$new_ver" "$new_rel" "$reason"

    adm_log_ok "Adicionada entrada na upgrade-list: $pkg_id $old_ver-$old_rel -> $new_ver-$new_rel ($reason)"
    adm_event_pkg "UPGRADE_LIST_ADD" "$pkg_id" \
        "from=$old_ver-$old_rel to=$new_ver-$new_rel reason=$reason"

    # Histórico rico de upgrade planejado
    local direction="upgrade"  # se quiser, pode detectar downgrade comparando versões
    adm_db_history_upgrade \
        "$pkg_id" "$old_ver" "$old_rel" "$new_ver" "$new_rel" \
        "PLANNED" "$direction" "$reason" "source=upgrade-list"
}

adm_db_upgrade_list() {
    # Mostra o conteúdo atual da upgrade-list
    if [[ ! -f "$ADM_DB_UPGRADE_LIST" ]]; then
        return 0
    fi
    cat "$ADM_DB_UPGRADE_LIST"
}

adm_db_upgrade_clear() {
    # Limpa a upgrade-list
    adm_with_lock "upgrade-list" bash -c '
        local file="$1"
        : >"$file" || {
            printf "ADM-ERROR: falha ao limpar upgrade-list.\n" >&2
            exit 1
        }
    ' _ "$ADM_DB_UPGRADE_LIST"

    adm_log_ok "upgrade-list limpa."
    adm_event_simple "UPGRADE_LIST_CLEARED"
}

# =========
# CLI de debug
# =========

adm_db_usage() {
    cat <<'EOF'
adm-db - Camada de DB do ADM 2.0 (debug/inspeção)

Uso:
  adm-db list-installed
  adm-db meta PKG_ID KEY
  adm-db files PKG_ID
  adm-db history-tail [N]
  adm-db upgrade-list
  adm-db upgrade-clear
  adm-db help

Comandos:
  list-installed    Lista pacotes instalados (pkg_id version release profile libc)
  meta PKG KEY      Lê um campo do [meta] de um pacote
  files PKG         Lista arquivos registrados para um pacote
  history-tail [N]  Mostra últimas N linhas do histórico (default 50)
  upgrade-list      Mostra o conteúdo de db/upgrade-list
  upgrade-clear     Limpa db/upgrade-list
EOF
}

adm_db_main() {
    local cmd="${1:-}"
    [[ -n "$cmd" ]] && shift || true

    case "$cmd" in
        list-installed)
            adm_db_list_installed
            ;;
        meta)
            if [[ $# -lt 2 ]]; then
                adm_log_fatal "Uso: adm-db meta PKG_ID KEY"
            fi
            adm_db_get_meta_value "$1" "$2"
            ;;
        files)
            if [[ $# -lt 1 ]]; then
                adm_log_fatal "Uso: adm-db files PKG_ID"
            fi
            adm_db_list_files "$1"
            ;;
        history-tail)
            local n="${1:-50}"
            local file
            file="$(adm_db_history_file_for_today)"
            if [[ ! -f "$file" ]]; then
                adm_log_warn "Nenhum histórico para hoje ainda: $file"
                return 0
            fi
            tail -n "$n" "$file"
            ;;
        upgrade-list)
            adm_db_upgrade_list
            ;;
        upgrade-clear)
            adm_db_upgrade_clear
            ;;
        help|"")
            adm_db_usage
            ;;
        *)
            adm_log_fatal "Comando desconhecido para adm-db: '$cmd'"
            ;;
    esac
}

if [[ "${BASH_SOURCE[0]:-$0}" == "$0" ]]; then
    adm_db_main "$@"
fi
