#!/usr/bin/env bash
# adm-db - Camada de acesso ao banco de dados do ADM 2.0
# /root/usr/src/adm/scripts/
# Responsável por:
#   - Registrar/leitura de pacotes instalados (db/installed/)
#   - Registrar histórico de ações (db/history/)
#   - Gerenciar upgrade-list (db/upgrade-list)
#
# Pode ser sourceado por outros scripts ou usado via CLI para debug.

set -o errexit
set -o nounset
set -o pipefail

# =========
# Carrega ambiente, UI e eventos
# =========

_adm_db_script_dir() {
    local src="${BASH_SOURCE[0]:-$0}"
    while [ -L "$src" ]; do
        local target
        target=$(readlink "$src") || break
        if [[ "$target" = /* ]]; then
            src="$target"
        else
            src="$(dirname "$src")/$target"
        fi
    done
    cd "$(dirname "$src")" >/dev/null 2>&1 || {
        printf 'ADM-ERROR: Não foi possível entrar no diretório do script adm-db.\n' >&2
        exit 1
    }
    pwd
}

_ADM_DB_DIR="$(_adm_db_script_dir)"

# shellcheck disable=SC1090
source "$_ADM_DB_DIR/adm-env"
# shellcheck disable=SC1090
source "$_ADM_DB_DIR/adm-log-ui"
# shellcheck disable=SC1090
source "$_ADM_DB_DIR/adm-eventd"

# Garante diretórios básicos do DB
if [[ ! -d "$ADM_DB_INSTALLED_DIR" ]]; then
    mkdir -p "$ADM_DB_INSTALLED_DIR" || adm_log_fatal "Falha ao criar '$ADM_DB_INSTALLED_DIR'."
fi

if [[ ! -d "$ADM_DB_HISTORY_DIR" ]]; then
    mkdir -p "$ADM_DB_HISTORY_DIR" || adm_log_fatal "Falha ao criar '$ADM_DB_HISTORY_DIR'."
fi

# =========
# Utilidades internas
# =========

adm_db_pkg_parse_id() {
    # Divide um pkg_id no formato categoria/pacote
    # Uso:
    #   read cat name < <(adm_db_pkg_parse_id "base/kmod")
    local pkg_id="${1:-}"
    if [[ "$pkg_id" != */* ]]; then
        adm_log_fatal "pkg_id inválido (esperado categoria/pacote): '$pkg_id'"
    fi
    local cat="${pkg_id%%/*}"
    local name="${pkg_id##*/}"
    printf '%s %s\n' "$cat" "$name"
}

adm_db_pkg_file() {
    # Retorna o caminho do arquivo de DB para um pkg_id
    # Uso:
    #   f=$(adm_db_pkg_file "base/kmod")
    local pkg_id="${1:-}"
    local cat name
    read -r cat name < <(adm_db_pkg_parse_id "$pkg_id")
    printf '%s/%s__%s.pkg' "$ADM_DB_INSTALLED_DIR" "$cat" "$name"
}

adm_db_pkg_exists() {
    # Retorna 0 se um pkg_id está instalado (arquivo existe), 1 caso contrário
    local pkg_id="${1:-}"
    local file
    file="$(adm_db_pkg_file "$pkg_id")"
    [[ -f "$file" ]]
}

# =========
# Registro de instalação
# =========

adm_db_register_install() {
    # Registra que um pacote foi instalado.
    #
    # Uso:
    #   adm_db_register_install \
    #       pkg_id version release profile libc files_list_path [build_id]
    #
    # Onde:
    #   - pkg_id: "categoria/pacote"
    #   - version: versão
    #   - release: release
    #   - profile: perfil (pode ser "-")
    #   - libc: libc usada (glibc, musl, etc. pode ser "-")
    #   - files_list_path: arquivo temporário com lista de arquivos (um por linha)
    #   - build_id: identificador de build (opcional; pode ser "-")
    if [[ $# -lt 6 ]]; then
        adm_log_fatal "adm_db_register_install: uso: adm_db_register_install pkg_id version release profile libc files_list_path [build_id]"
    fi

    local pkg_id="$1"
    local version="$2"
    local release="$3"
    local profile="$4"
    local libc="$5"
    local files_list="$6"
    local build_id="${7:-"-"}"

    if [[ ! -f "$files_list" ]]; then
        adm_log_fatal "adm_db_register_install: lista de arquivos não encontrada: '$files_list'"
    fi

    local cat name file ts_epoch ts_human
    read -r cat name < <(adm_db_pkg_parse_id "$pkg_id")
    file="$(adm_db_pkg_file "$pkg_id")"
    ts_epoch="$(date +%s)"
    ts_human="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"

    adm_with_lock "db-installed" bash -c '
        local file="$1" pkg_id="$2" cat="$3" name="$4"
        local version="$5" release="$6" profile="$7" libc="$8"
        local files_list="$9" ts_epoch="${10}" ts_human="${11}" build_id="${12}"

        # Garante diretório
        mkdir -p "$(dirname "$file")" || {
            printf "ADM-ERROR: falha ao criar diretório para %s\n" "$file" >&2
            exit 1
        }

        {
            printf "[meta]\n"
            printf "pkg_id=%s\n" "$pkg_id"
            printf "name=%s\n" "$name"
            printf "category=%s\n" "$cat"
            printf "version=%s\n" "$version"
            printf "release=%s\n" "$release"
            printf "profile=%s\n" "$profile"
            printf "libc=%s\n" "$libc"
            printf "build_id=%s\n" "$build_id"
            printf "install_time_epoch=%s\n" "$ts_epoch"
            printf "install_time_human=%s\n" "$ts_human"
            printf "\n[files]\n"
            cat "$files_list"
        } >"$file.tmp" || {
            printf "ADM-ERROR: falha ao escrever arquivo temporário para %s\n" "$file" >&2
            exit 1
        }

        mv "$file.tmp" "$file" || {
            printf "ADM-ERROR: falha ao substituir arquivo de instalado %s\n" "$file" >&2
            exit 1
        }
    ' _ "$file" "$pkg_id" "$cat" "$name" "$version" "$release" "$profile" "$libc" "$files_list" "$ts_epoch" "$ts_human" "$build_id"

    adm_log_ok "Registrado pacote instalado: $pkg_id $version-$release"
    adm_event_pkg "PKG_INSTALL_REGISTERED" "$pkg_id" "version=$version release=$release profile=$profile libc=$libc"
}

adm_db_remove_install() {
    # Remove registro de instalação de um pacote (não remove arquivos de /usr)
    # Uso:
    #   adm_db_remove_install pkg_id
    local pkg_id="${1:-}"
    if [[ -z "$pkg_id" ]]; then
        adm_log_fatal "adm_db_remove_install: pkg_id não informado."
    fi
    local file
    file="$(adm_db_pkg_file "$pkg_id")"

    if [[ ! -f "$file" ]]; then
        adm_log_warn "adm_db_remove_install: registro de $pkg_id não existe."
        return 0
    fi

    adm_with_lock "db-installed" bash -c '
        local file="$1"
        rm -f "$file" || {
            printf "ADM-ERROR: falha ao remover arquivo %s\n" "$file" >&2
            exit 1
        }
    ' _ "$file"

    adm_log_ok "Removido registro de instalado: $pkg_id"
    adm_event_pkg "PKG_INSTALL_REMOVED" "$pkg_id" ""
}

# =========
# Leitura de instalados
# =========

adm_db_list_installed() {
    # Lista pacotes instalados em formato:
    # pkg_id<TAB>version<TAB>release<TAB>profile<TAB>libc
    local f pkg_id version release profile libc
    for f in "$ADM_DB_INSTALLED_DIR"/*.pkg; do
        [[ -e "$f" ]] || continue

        pkg_id=""
        version=""
        release=""
        profile=""
        libc=""

        while IFS='=' read -r key val; do
            case "$key" in
                pkg_id) pkg_id="$val" ;;
                version) version="$val" ;;
                release) release="$val" ;;
                profile) profile="$val" ;;
                libc) libc="$val" ;;
            esac
        done < <(awk 'BEGIN{inmeta=0} /^\[meta\]/{inmeta=1;next} /^\[/{inmeta=0} inmeta && NF>0{print}' "$f")

        if [[ -n "$pkg_id" ]]; then
            printf '%s\t%s\t%s\t%s\t%s\n' "$pkg_id" "$version" "$release" "$profile" "$libc"
        fi
    done
}

adm_db_get_meta_value() {
    # Lê um valor específico do [meta] de um pacote.
    # Uso:
    #   adm_db_get_meta_value pkg_id chave
    # Saída: valor (stdout).  Retorno 0 se encontrado, 1 se não.
    if [[ $# -lt 2 ]]; then
        adm_log_fatal "adm_db_get_meta_value: uso: adm_db_get_meta_value pkg_id chave"
    fi
    local pkg_id="$1"
    local key_target="$2"
    local file
    file="$(adm_db_pkg_file "$pkg_id")"

    if [[ ! -f "$file" ]]; then
        adm_log_warn "adm_db_get_meta_value: pacote não registrado: $pkg_id"
        return 1
    fi

    local line key val
    while IFS='=' read -r key val; do
        if [[ "$key" == "$key_target" ]]; then
            printf '%s\n' "$val"
            return 0
        fi
    done < <(awk 'BEGIN{inmeta=0} /^\[meta\]/{inmeta=1;next} /^\[/{inmeta=0} inmeta && NF>0{print}' "$file")

    return 1
}

adm_db_list_files() {
    # Lista arquivos de um pacote (seção [files])
    # Uso:
    #   adm_db_list_files pkg_id
    if [[ $# -lt 1 ]]; then
        adm_log_fatal "adm_db_list_files: uso: adm_db_list_files pkg_id"
    fi
    local pkg_id="$1"
    local file
    file="$(adm_db_pkg_file "$pkg_id")"

    if [[ ! -f "$file" ]]; then
        adm_log_warn "adm_db_list_files: pacote não registrado: $pkg_id"
        return 1
    fi

    awk 'BEGIN{infiles=0} /^\[files\]/{infiles=1;next} /^\[/{infiles=0} infiles{print}' "$file"
}

# =========
# Histórico
# =========

adm_db_history_file_for_today() {
    local day
    day="$(date '+%Y%m%d')"
    printf '%s/history-%s.log' "$ADM_DB_HISTORY_DIR" "$day"
}

adm_db_history_append() {
    # Registra uma entrada no histórico.
    #
    # Uso:
    #   adm_db_history_append action pkg_id version release status "mensagem..."
    #
    # Exemplo:
    #   adm_db_history_append BUILD base/kmod 1.0 1 OK "Build concluído"
    if [[ $# -lt 5 ]]; then
        adm_log_fatal "adm_db_history_append: uso: adm_db_history_append action pkg_id version release status [mensagem...]"
    fi

    local action="$1"
    local pkg_id="$2"
    local version="$3"
    local release="$4"
    local status="$5"
    shift 5 || true
    local msg="$*"

    local ts pid file line
    ts="$(date '+%Y-%m-%dT%H:%M:%S%z')"
    pid="$$"
    file="$(adm_db_history_file_for_today)"

    # Sanitiza tabs
    action="${action//$'\t'/ }"
    pkg_id="${pkg_id//$'\t'/ }"
    version="${version//$'\t'/ }"
    release="${release//$'\t'/ }"
    status="${status//$'\t'/ }"
    msg="${msg//$'\t'/ }"

    line=$(printf '%s\t%s\t%s\t%s\t%s\t%s\t%s\n' "$ts" "$pid" "$action" "$pkg_id" "$version" "$release" "$status" "$msg")

    adm_with_lock "db-history" bash -c '
        local file="$1" line="$2"
        mkdir -p "$(dirname "$file")" || {
            printf "ADM-ERROR: falha ao criar diretório de history.\n" >&2
            exit 1
        }
        printf "%s\n" "$line" >>"$file" || {
            printf "ADM-ERROR: falha ao gravar histórico em %s\n" "$file" >&2
            exit 1
        }
    ' _ "$file" "$line"

    adm_event_pkg "HISTORY_$action" "$pkg_id" "status=$status msg=$msg"
}

# =========
# Upgrade-list
# =========

adm_db_upgrade_add() {
    # Adiciona/atualiza uma entrada na upgrade-list.
    #
    # Formato da linha:
    #   pkg_id<TAB>old_ver<TAB>old_rel<TAB>new_ver<TAB>new_rel<TAB>reason
    #
    # Uso:
    #   adm_db_upgrade_add pkg_id old_ver old_rel new_ver new_rel reason
    if [[ $# -lt 6 ]]; then
        adm_log_fatal "adm_db_upgrade_add: uso: adm_db_upgrade_add pkg_id old_ver old_rel new_ver new_rel reason"
    fi

    local pkg_id="$1"
    local old_ver="$2"
    local old_rel="$3"
    local new_ver="$4"
    local new_rel="$5"
    local reason="$6"

    # Sanitiza tabs
    pkg_id="${pkg_id//$'\t'/ }"
    old_ver="${old_ver//$'\t'/ }"
    old_rel="${old_rel//$'\t'/ }"
    new_ver="${new_ver//$'\t'/ }"
    new_rel="${new_rel//$'\t'/ }"
    reason="${reason//$'\t'/ }"

    adm_with_lock "upgrade-list" bash -c '
        local file="$1" pkg_id="$2" old_ver="$3" old_rel="$4" new_ver="$5" new_rel="$6" reason="$7"
        mkdir -p "$(dirname "$file")" || {
            printf "ADM-ERROR: falha ao criar diretório para upgrade-list.\n" >&2
            exit 1
        }

        # Remove qualquer linha existente para este pkg_id
        local tmp="${file}.tmp"
        if [[ -f "$file" ]]; then
            grep -v -F -e "$pkg_id"$'"'\t'"'" "$file" >"$tmp" || true
        else
            : >"$tmp"
        fi

        printf "%s\t%s\t%s\t%s\t%s\t%s\n" "$pkg_id" "$old_ver" "$old_rel" "$new_ver" "$new_rel" "$reason" >>"$tmp" || {
            printf "ADM-ERROR: falha ao escrever upgrade-list temporário.\n" >&2
            exit 1
        }

        mv "$tmp" "$file" || {
            printf "ADM-ERROR: falha ao atualizar upgrade-list.\n" >&2
            exit 1
        }
    ' _ "$ADM_DB_UPGRADE_LIST" "$pkg_id" "$old_ver" "$old_rel" "$new_ver" "$new_rel" "$reason"

    adm_log_ok "Adicionada entrada na upgrade-list: $pkg_id $old_ver-$old_rel -> $new_ver-$new_rel ($reason)"
    adm_event_pkg "UPGRADE_LIST_ADD" "$pkg_id" "from=$old_ver-$old_rel to=$new_ver-$new_rel reason=$reason"
}

adm_db_upgrade_list() {
    # Mostra o conteúdo atual da upgrade-list
    if [[ ! -f "$ADM_DB_UPGRADE_LIST" ]]; then
        return 0
    fi
    cat "$ADM_DB_UPGRADE_LIST"
}

adm_db_upgrade_clear() {
    # Limpa a upgrade-list
    adm_with_lock "upgrade-list" bash -c '
        local file="$1"
        : >"$file" || {
            printf "ADM-ERROR: falha ao limpar upgrade-list.\n" >&2
            exit 1
        }
    ' _ "$ADM_DB_UPGRADE_LIST"

    adm_log_ok "upgrade-list limpa."
    adm_event_simple "UPGRADE_LIST_CLEARED"
}

# =========
# CLI de debug
# =========

adm_db_usage() {
    cat <<EOF
adm-db - Acesso ao banco de dados do ADM

Uso:
  adm-db list-installed
      Lista pacotes instalados (pkg_id, versão, release, profile, libc).

  adm-db is-installed pkg_id
      Retorna 0 se o pacote está instalado, 1 caso contrário.

  adm-db show-meta pkg_id
      Mostra seção [meta] do registro de instalado.

  adm-db list-files pkg_id
      Lista os arquivos associados ao pacote (seção [files]).

  adm-db upgrade-list
      Mostra o conteúdo de db/upgrade-list.

  adm-db upgrade-clear
      Limpa db/upgrade-list.

  adm-db history-add action pkg_id version release status [mensagem...]
      Adiciona uma entrada no histórico.

  adm-db --help
      Mostra esta ajuda.

ATENÇÃO:
  - Funções de alto nível para registrar instalações e upgrade-list
    devem ser usadas pelos scripts de build/update/upgrade.
EOF
}

adm_db_main() {
    local cmd="${1:-}"

    case "$cmd" in
        list-installed)
            adm_db_list_installed
            ;;
        is-installed)
            shift || true
            if [[ $# -lt 1 ]]; then
                adm_log_fatal "Uso: adm-db is-installed pkg_id"
            fi
            if adm_db_pkg_exists "$1"; then
                adm_log_ok "Pacote instalado: $1"
                exit 0
            else
                adm_log_warn "Pacote NÃO instalado: $1"
                exit 1
            fi
            ;;
        show-meta)
            shift || true
            if [[ $# -lt 1 ]]; then
                adm_log_fatal "Uso: adm-db show-meta pkg_id"
            fi
            local file
            file="$(adm_db_pkg_file "$1")"
            if [[ ! -f "$file" ]]; then
                adm_log_fatal "Registro não encontrado para $1"
            fi
            awk 'BEGIN{inmeta=0} /^\[meta\]/{inmeta=1;next} /^\[/{inmeta=0} inmeta{print}' "$file"
            ;;
        list-files)
            shift || true
            if [[ $# -lt 1 ]]; then
                adm_log_fatal "Uso: adm-db list-files pkg_id"
            fi
            adm_db_list_files "$1"
            ;;
        upgrade-list)
            adm_db_upgrade_list
            ;;
        upgrade-clear)
            adm_db_upgrade_clear
            ;;
        history-add)
            shift || true
            if [[ $# -lt 5 ]]; then
                adm_log_fatal "Uso: adm-db history-add action pkg_id version release status [mensagem...]"
            fi
            adm_db_history_append "$@"
            ;;
        --help|-h|"")
            adm_db_usage
            ;;
        *)
            adm_log_fatal "Comando desconhecido para adm-db: '$cmd'"
            ;;
    esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    adm_db_main "$@"
fi

# Fim do adm-db
