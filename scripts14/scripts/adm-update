#!/usr/bin/env bash
# adm-update - Atualizador de metadados / versão do ADM 2.0
#
# Responsável por:
#   - Descobrir nova versão no upstream (hoje: foco em URLs git via 'url:' ou 'source_uri:')
#   - Fazer backup seguro do metadado atual
#   - Atualizar:
#       * version:
#       * source_uri: (substitui old_version -> new_version quando possível)
#       * source_checksum: (recalculado via adm-fetch + sha256sum)
#   - Rodar adm-fetch + adm-scan na nova versão
#   - Detectar novas dependências de build (comparando com as antigas)
#   - Gerar metadados stub para novas deps (se não existirem)
#   - Registrar pacote + novas deps em uma lista de upgrade (para adm-upgrade)
#
# API CLI:
#   adm-update check PKG_ID
#       - Só checa se existe nova versão upstream, sem alterar nada.
#
#   adm-update apply PKG_ID
#       - Aplica update de versão + URIs + checksums + scan + deps + lista de upgrade.
#
#   adm-update list-pending
#       - Lista pacotes pendentes de upgrade (fila gerada pelo adm-update apply).
#
#   adm-update clear-pending
#       - Limpa fila de upgrade.
#
# Variáveis importantes:
#   ADM_DRY_RUN=1   -> não altera arquivos, nem escreve lista; só mostra o que faria.
#
# Limitações intencionais:
#   - Descoberta de nova versão hoje é implementada apenas para upstreams git
#     (url: ou source_uri: apontando para repositório git).
#   - Outros casos geram warning e não fazem update automático (podem ser tratados
#     via hooks no futuro).

set -o errexit
set -o nounset
set -o pipefail

# =========
# Carrega ambiente e módulos
# =========

_adm_update_script_dir() {
    local src="${BASH_SOURCE[0]:-$0}"
    while [ -L "$src" ]; do
        local target
        target=$(readlink "$src") || break
        if [[ "$target" = /* ]]; then
            src="$target"
        else
            src="$(dirname "$src")/$target"
        fi
    done
    cd "$(dirname "$src")" >/dev/null 2>&1 || {
        printf 'ADM-ERROR: Não foi possível entrar no diretório do script adm-update.\n' >&2
        exit 1
    }
    pwd
}

_ADM_UPDATE_DIR="$(_adm_update_script_dir)"

# shellcheck disable=SC1090
source "$_ADM_UPDATE_DIR/adm-env"
# shellcheck disable=SC1090
source "$_ADM_UPDATE_DIR/adm-log-ui"
# shellcheck disable=SC1090
source "$_ADM_UPDATE_DIR/adm-eventd"
# shellcheck disable=SC1090
source "$_ADM_UPDATE_DIR/adm-metrics"
# shellcheck disable=SC1090
source "$_ADM_UPDATE_DIR/adm-db"
# shellcheck disable=SC1090
source "$_ADM_UPDATE_DIR/adm-deps"
# shellcheck disable=SC1090
source "$_ADM_UPDATE_DIR/adm-knowledge"
# shellcheck disable=SC1090
source "$_ADM_UPDATE_DIR/adm-fetch"
# shellcheck disable=SC1090
source "$_ADM_UPDATE_DIR/adm-scan"

ADM_DRY_RUN="${ADM_DRY_RUN:-0}"

# diretório/lista de upgrades
ADM_DB_UPDATES_DIR="${ADM_DB_DIR}/updates"
ADM_DB_UPDATES_PENDING="${ADM_DB_UPDATES_DIR}/pending.list"

# =========
# Utilidades de metadado / pkg
# =========

adm_update_metadado_path() {
    adm_deps_metadado_path "$1"
}

adm_update_read_meta_single() {
    local file="${1:-}"
    local key="${2:-}"

    if [[ ! -f "$file" ]]; then
        adm_log_fatal "adm-update: metadado não encontrado: '$file'"
    fi

    awk -v k="$key" -F':' '
        $1 ~ "^[[:space:]]*"k"[[:space:]]*$" && NF==1 {
            if (getline line > 0) {
                sub(/^[[:space:]]+/, "", line)
                sub(/[[:space:]]+$/, "", line)
                print line
                exit 0
            }
        }
        $1 ~ "^[[:space:]]*"k"[[:space:]]*" && NF>=2 {
            $1=""
            sub(/^[[:space:]]+/, "", $0)
            print $0
            exit 0
        }
    ' "$file"
}

adm_update_version_for_pkg() {
    local pkg_id="$1"
    local meta
    meta="$(adm_update_metadado_path "$pkg_id")"
    adm_update_read_meta_single "$meta" "version" || echo "unknown"
}

adm_update_release_for_pkg() {
    local pkg_id="$1"
    local meta
    meta="$(adm_update_metadado_path "$pkg_id")"
    adm_update_read_meta_single "$meta" "release" || echo "1"
}

adm_update_guess_upstream_url() {
    # Decide qual URL usar para consultar upstream:
    #   - preferimos 'url:' se for git
    #   - senão, primeiro 'source_uri:' que seja git
    #
    # Uso:
    #   adm_update_guess_upstream_url META
    # Saída:
    #   URL ou vazio
    local meta="${1:-}"

    local url
    url="$(adm_update_read_meta_single "$meta" "url" || true)"

    if [[ -n "$url" && "$(adm_fetch_is_git_uri "$url"; echo $?)" -eq 0 ]]; then
        printf '%s\n' "$url"
        return 0
    fi

    # pega primeira source_uri
    local first_src
    first_src="$(adm_fetch_read_meta_field_all "$meta" "source_uri" | head -n1 || true)"

    if [[ -n "$first_src" && "$(adm_fetch_is_git_uri "$first_src"; echo $?)" -eq 0 ]]; then
        printf '%s\n' "$first_src"
        return 0
    fi

    printf '\n'
}

# =========
# Lista de pending upgrades
# =========

adm_update_pending_add() {
    # Adiciona PKG_ID à lista pending.list (com lock e sem duplicar).
    local pkg_id="${1:-}"

    if [[ -z "$pkg_id" ]]; then
        return 0
    fi

    if [[ "$ADM_DRY_RUN" -eq 1 ]]; then
        adm_log_info "[DRY-RUN] Não adicionando $pkg_id à lista de upgrade (pendente)."
        return 0
    fi

    mkdir -p "$ADM_DB_UPDATES_DIR" || adm_log_fatal "Falha ao criar '$ADM_DB_UPDATES_DIR'."

    adm_with_lock "updates-pending" bash -c '
        local file="$1" pkg="$2"

        touch "$file" || {
            printf "ADM-ERROR: não foi possível acessar %s\n" "$file" >&2
            exit 1
        }

        if grep -qxF "$pkg" "$file" 2>/dev/null; then
            exit 0
        fi

        printf "%s\n" "$pkg" >>"$file" || {
            printf "ADM-ERROR: falha ao adicionar %s em %s\n" "$pkg" "$file" >&2
            exit 1
        }
    ' _ "$ADM_DB_UPDATES_PENDING" "$pkg_id"

    adm_log_ok "Adicionado à fila de upgrade: $pkg_id"
}

adm_update_pending_list() {
    if [[ ! -f "$ADM_DB_UPDATES_PENDING" ]]; then
        adm_log_info "Nenhum pacote pendente de upgrade."
        return 0
    fi
    cat "$ADM_DB_UPDATES_PENDING"
}

adm_update_pending_clear() {
    if [[ "$ADM_DRY_RUN" -eq 1 ]]; then
        adm_log_info "[DRY-RUN] Não limpando pending.list."
        return 0
    fi
    if [[ -f "$ADM_DB_UPDATES_PENDING" ]]; then
        rm -f "$ADM_DB_UPDATES_PENDING" || adm_log_fatal "Não foi possível remover '$ADM_DB_UPDATES_PENDING'."
    fi
    adm_log_ok "Fila de upgrade limpa."
}

# =========
# Descobrir nova versão no upstream (git)
# =========

adm_update_detect_latest_git_tag() {
    # Uso:
    #   adm_update_detect_latest_git_tag URL CURRENT_VERSION
    #
    # Saída:
    #   new_version<TAB>new_tag  (se new_version > current_version)
    #
    # Retornos:
    #   0 -> sucesso, há versão nova
    #   1 -> erro (não conseguiu listar tags)
    #   2 -> nenhuma tag encontrada
    #   3 -> não há versão mais nova (<= atual)
    local url="${1:-}"
    local current="${2:-}"

    if [[ -z "$url" ]]; then
        return 1
    fi

    if ! command -v git >/dev/null 2>&1; then
        adm_log_warn "git não encontrado para consulta de upstream em '$url'."
        return 1
    fi

    # lista tags
    local tags
    if ! tags="$(git ls-remote --tags "$url" 2>/dev/null | awk '{print $2}' | sed 's#refs/tags/##' | sed 's/\^{}$//' )"; then
        adm_log_warn "Falha ao executar 'git ls-remote --tags' em '$url'."
        return 1
    fi

    if [[ -z "$tags" ]]; then
        adm_log_warn "Nenhuma tag encontrada em '$url'."
        return 2
    fi

    # escolhe a "maior" via sort -V
    if ! sort -V </dev/null >/dev/null 2>&1; then
        adm_log_warn "sort -V não disponível; comparação de versões pode ser imprecisa."
    fi

    local best_tag best_ver
    best_tag="$(printf '%s\n' "$tags" | sort -V | tail -n1)"
    # remove prefixo 'v' se houver
    best_ver="${best_tag#v}"
    best_ver="${best_ver#V}"

    if [[ -z "$best_ver" ]]; then
        return 2
    fi

    if [[ "$best_ver" == "$current" ]]; then
        return 3
    fi

    # compara current vs best_ver
    if sort -V </dev/null >/dev/null 2>&1; then
        local highest
        highest="$(printf '%s\n%s\n' "$current" "$best_ver" | sort -V | tail -n1)"
        if [[ "$highest" == "$current" && "$current" != "$best_ver" ]]; then
            # current > best -> não faz sentido atualizar
            adm_log_warn "Versão atual ($current) é >= última tag ($best_ver) em '$url'."
            return 3
        fi
    fi

    printf '%s\t%s\n' "$best_ver" "$best_tag"
    return 0
}

adm_update_detect_new_version() {
    # Uso:
    #   adm_update_detect_new_version PKG_ID
    #
    # Saída:
    #   new_version<TAB>new_tag
    #
    # Retornos:
    #   0 -> ok, existe nova versão
    #   1 -> erro ou não suportado
    #   2 -> sem nova versão (igual ou mais antiga)
    local pkg_id="${1:-}"

    local meta
    meta="$(adm_update_metadado_path "$pkg_id")"
    if [[ ! -f "$meta" ]]; then
        adm_log_fatal "Metadado não encontrado para $pkg_id: '$meta'"
    fi

    local current
    current="$(adm_update_read_meta_single "$meta" "version" || echo "unknown")"

    local upstream
    upstream="$(adm_update_guess_upstream_url "$meta" || true)"

    if [[ -z "$upstream" ]]; then
        adm_log_warn "Não foi possível determinar upstream para $pkg_id (sem URL git em 'url:' ou 'source_uri:')."
        return 1
    fi

    if ! adm_fetch_is_git_uri "$upstream"; then
        adm_log_warn "Upstream não git ainda não suportado em adm-update: $upstream"
        return 1
    fi

    local out
    if ! out="$(adm_update_detect_latest_git_tag "$upstream" "$current")"; then
        return 1
    fi

    local new_ver new_tag
    new_ver="${out%%$'\t'*}"
    new_tag="${out##*$'\t'}"

    if [[ -z "$new_ver" ]]; then
        return 1
    fi

    # se new_ver == current, não há nova
    if [[ "$new_ver" == "$current" ]]; then
        return 2
    fi

    printf '%s\t%s\n' "$new_ver" "$new_tag"
    return 0
}

# =========
# Backup e edição de metadado
# =========

adm_update_backup_metadado() {
    local meta="${1:-}"

    if [[ ! -f "$meta" ]]; then
        adm_log_fatal "adm-update: não há metadado para backup: '$meta'"
    fi

    local ts backup
    ts="$(date '+%Y%m%d-%H%M%S')"
    backup="${meta}.bak-${ts}"

    if [[ "$ADM_DRY_RUN" -eq 1 ]]; then
        adm_log_info "[DRY-RUN] Faria backup do metadado: $meta -> $backup"
        return 0
    fi

    cp -a "$meta" "$backup" || adm_log_fatal "Falha ao criar backup '$backup'."
    adm_log_ok "Backup de metadado criado: $backup"
}

adm_update_edit_meta_version_and_sources() {
    # Atualiza:
    #   - version: OLD -> NEW
    #   - source_uri: substitui OLD_VERSION por NEW_VERSION quando aparecer
    #   - remove linhas source_checksum: (serão recalculadas)
    #
    # Uso:
    #   adm_update_edit_meta_version_and_sources META OLD_VER NEW_VER
    local meta="${1:-}"
    local oldver="${2:-}"
    local newver="${3:-}"

    if [[ ! -f "$meta" ]]; then
        adm_log_fatal "Metadado não encontrado em adm_update_edit_meta_version_and_sources: '$meta'"
    fi

    if [[ "$ADM_DRY_RUN" -eq 1 ]]; then
        adm_log_info "[DRY-RUN] Atualizaria 'version:' $oldver -> $newver e 'source_uri:' em $meta (removendo source_checksum)."
        return 0
    fi

    local tmp
    tmp="$(mktemp "$ADM_TMP_DIR/meta-update-XXXXXX")" || adm_log_fatal "Falha ao criar tmp para meta update."

    # 1) Atualiza versão e URIs
    awk -v oldv="$oldver" -v newv="$newver" '
        function replace_version_in_uri(line,    idx) {
            idx = index(line, oldv)
            if (idx > 0) {
                sub(oldv, newv, line)
            }
            return line
        }
        {
            # remove source_checksum (serão reescritos depois)
            if ($1 ~ "^[[:space:]]*source_checksum[[:space:]]*:") {
                next
            }
            # version:
            if ($1 ~ "^[[:space:]]*version[[:space:]]*:") {
                print "version: " newv
                next
            }
            # source_uri:
            if ($1 ~ "^[[:space:]]*source_uri[[:space:]]*:") {
                # reconstrói linha
                line=$0
                sub(/^[[:space:]]*source_uri[[:space:]]*:[[:space:]]*/, "source_uri: ", line)
                line=replace_version_in_uri(line)
                print line
                next
            }
            print
        }
    ' "$meta" >"$tmp" || adm_log_fatal "Falha ao reescrever metadado temporário para '$meta'."

    mv "$tmp" "$meta" || adm_log_fatal "Falha ao aplicar atualização de metadado em '$meta'."
    adm_log_ok "Metadado atualizado para versão $newver (URIs ajustadas e checksums limpos)."
}

adm_update_recompute_checksums() {
    # Recalcula source_checksum: chamando adm-fetch para baixar novas fontes
    # e anotando sha256 para cada source_uri.
    #
    # Uso:
    #   adm_update_recompute_checksums PKG_ID META
    local pkg_id="${1:-}"
    local meta="${2:-}"

    if [[ ! -f "$meta" ]]; then
        adm_log_fatal "Metadado não encontrado para recálculo de checksums: '$meta'"
    fi

    if [[ "$ADM_DRY_RUN" -eq 1 ]]; then
        adm_log_info "[DRY-RUN][$pkg_id] Recalcularia source_checksum usando adm-fetch + sha256sum."
        return 0
    fi

    if ! command -v adm-fetch >/dev/null 2>&1; then
        adm_log_fatal "'adm-fetch' não encontrado no PATH; não é possível recalcular checksums."
    fi

    if ! command -v sha256sum >/dev/null 2>&1; then
        adm_log_fatal "'sha256sum' não encontrado; não é possível recalcular checksums."
    fi

    adm_log_phase "Recalculando checksums para $pkg_id a partir de $meta"

    local src_list
    src_list="$(adm-fetch fetch-from-meta "$pkg_id" "$meta")" || adm_log_fatal "Falha em adm-fetch para $pkg_id durante recálculo."

    # append novas linhas source_checksum: ao final do metadado
    local f sum
    while IFS= read -r f; do
        [[ -z "$f" ]] && continue
        if [[ ! -f "$f" ]]; then
            adm_log_fatal "Fonte baixada não encontrada para checksum: '$f'"
        fi
        sum="$(sha256sum "$f" | awk '{print $1}')"
        echo "source_checksum: $sum" >>"$meta" || adm_log_fatal "Falha ao escrever source_checksum em '$meta'."
    done <<<"$src_list"

    adm_log_ok "Checksums recalculados e gravados em $meta."
}

# =========
# Novas dependências e metadados stub
# =========

adm_update_compare_build_deps() {
    # Compara lista antiga x nova e imprime apenas as novas deps.
    #
    # Uso:
    #   adm_update_compare_build_deps "dep1 dep2" "dep1 dep2 dep3"
    # Saída:
    #   dep3
    local old="$1"
    local new="$2"

    # bota cada um em uma linha e usa awk para diferença
    printf '%s\n' "$new" \
        | tr ' ' '\n' \
        | sed '/^$/d' \
        | awk -v old_list="$old" '
            BEGIN {
                n_old = split(old_list, a, " ")
                for (i=1; i<=n_old; i++) {
                    if (a[i] != "") seen[a[i]] = 1
                }
            }
            {
                if (!($0 in seen)) {
                    print $0
                }
            }
        '
}

adm_update_ensure_stub_metadata_for_pkg() {
    # Gera metadado stub para dependência que ainda não existe.
    #
    # Uso:
    #   adm_update_ensure_stub_metadata_for_pkg PKG_ID
    local dep_id="${1:-}"
    if [[ -z "$dep_id" ]]; then
        return 0
    fi

    local meta
    meta="$(adm_deps_metadado_path "$dep_id")"

    if [[ -f "$meta" ]]; then
        return 0
    fi

    local cat name
    read -r cat name < <(adm_deps_pkg_id_to_parts "$dep_id")

    local dir
    dir="$(dirname "$meta")"

    if [[ "$ADM_DRY_RUN" -eq 1 ]]; then
        adm_log_info "[DRY-RUN] Criaria metadado stub para dep $dep_id em $meta"
        return 0
    fi

    mkdir -p "$dir" || adm_log_fatal "Falha ao criar diretório para metadado de dep $dep_id: '$dir'"

    cat >"$meta" <<EOF
name: $name
version: 0
release: 1
category: $cat
license: UNKNOWN
url:

build_deps:
run_deps:
opt_deps:

groups:

# TODO: preencher source_uri/source_checksum manualmente
source_uri:
source_checksum:
EOF

    adm_log_warn "Metadado stub criado para dependência nova: $dep_id ($meta)"
    adm_event_pkg "PKG_STUB_META_CREATED" "$dep_id" "meta=$meta"
}

adm_update_scan_and_new_deps() {
    # Depois de atualizar metadado e checksums:
    #   - roda adm-scan para gerar novo .plan
    #   - obtém novos build_deps via adm-deps
    #   - compara com build_deps antigos e gera metas stub para novos
    #   - adiciona deps novas na fila de upgrade
    #
    # Uso:
    #   adm_update_scan_and_new_deps PKG_ID META OLD_BUILD_DEPS
    local pkg_id="${1:-}"
    local meta="${2:-}"
    local old_build_deps="${3:-}"

    if [[ ! -f "$meta" ]]; then
        adm_log_fatal "Metadado não encontrado em adm_update_scan_and_new_deps: '$meta'"
    fi

    if ! command -v adm-scan >/dev/null 2>&1; then
        adm_log_fatal "'adm-scan' não encontrado no PATH; não é possível recalcular plano/deps."
    fi

    # Precisamos de fontes baixadas; adm_update_recompute_checksums já fez adm-fetch,
    # mas aqui garantimos com fetch de novo (sem custo em cache).
    local src_list
    if [[ "$ADM_DRY_RUN" -eq 1 ]]; then
        adm_log_info "[DRY-RUN][$pkg_id] Rodaria adm-fetch + adm-scan para descobrir novas dependências."
        return 0
    fi

    src_list="$(adm-fetch fetch-from-meta "$pkg_id" "$meta")"

    local plan
    # shellcheck disable=SC2086
    plan="$(adm-scan scan-from-meta "$pkg_id" "$meta" $src_list)"

    if [[ ! -f "$plan" ]]; then
        adm_log_fatal "Plano não encontrado após adm-scan em update: '$plan'"
    fi

    # Como o plan foi gerado, adm-deps_get_build_deps já considera auto_build_deps
    local new_build_deps
    new_build_deps="$(adm_deps_get_build_deps "$pkg_id" || true)"

    adm_log_info "Build deps antigos de $pkg_id: ${old_build_deps:-<nenhum>}"
    adm_log_info "Build deps novos de $pkg_id:   ${new_build_deps:-<nenhum>}"

    local new_only
    new_only="$(adm_update_compare_build_deps "$old_build_deps" "$new_build_deps" || true)"

    if [[ -z "$new_only" ]]; then
        adm_log_ok "Nenhuma dependência de build nova detectada para $pkg_id."
        return 0
    fi

    adm_log_warn "Novas dependências de build detectadas para $pkg_id: $new_only"

    local d
    for d in $new_only; do
        adm_update_ensure_stub_metadata_for_pkg "$d"
        adm_update_pending_add "$d"
    done
}

# =========
# Fluxos principais: check / apply
# =========

adm_update_check_one() {
    # Apenas consulta upstream e mostra o que seria atualizado.
    #
    # Uso:
    #   adm_update_check_one PKG_ID
    local pkg_id="${1:-}"

    local meta
    meta="$(adm_update_metadado_path "$pkg_id")"
    if [[ ! -f "$meta" ]]; then
        adm_log_fatal "Metadado não encontrado para $pkg_id: '$meta'"
    fi

    local current
    current="$(adm_update_version_for_pkg "$pkg_id")"

    adm_log_phase_header "Checando upstream para $pkg_id (versão atual: $current)"
    adm_event_pkg "PKG_UPDATE_CHECK_START" "$pkg_id" "current=$current"

    local out
    if ! out="$(adm_update_detect_new_version "$pkg_id")"; then
        adm_log_warn "Não foi possível determinar nova versão para $pkg_id automaticamente."
        adm_event_pkg "PKG_UPDATE_CHECK_DONE" "$pkg_id" "result=error"
        return 1
    fi

    local new_ver new_tag
    new_ver="${out%%$'\t'*}"
    new_tag="${out##*$'\t'}"

    if [[ -z "$new_ver" || "$new_ver" == "$current" ]]; then
        adm_log_ok "Nenhuma versão mais nova encontrada para $pkg_id (continua em $current)."
        adm_event_pkg "PKG_UPDATE_CHECK_DONE" "$pkg_id" "result=up-to-date"
        return 0
    fi

    adm_log_ok "Nova versão disponível para $pkg_id: $current → $new_ver (tag upstream: $new_tag)"
    adm_event_pkg "PKG_UPDATE_CHECK_DONE" "$pkg_id" "result=has-update new=$new_ver"

    return 0
}

adm_update_apply_one_core() {
    # Core da aplicação de update (sem métricas).
    #
    # Uso interno:
    #   adm_update_apply_one_core PKG_ID
    local pkg_id="${1:-}"

    local meta
    meta="$(adm_update_metadado_path "$pkg_id")"
    if [[ ! -f "$meta" ]]; then
        adm_log_fatal "Metadado não encontrado para $pkg_id: '$meta'"
    fi

    local current
    current="$(adm_update_version_for_pkg "$pkg_id")"

    adm_log_phase_header "Aplicando update para $pkg_id (versão atual: $current)"

    local out
    if ! out="$(adm_update_detect_new_version "$pkg_id")"; then
        adm_log_warn "Não foi possível determinar nova versão para $pkg_id automaticamente."
        return 1
    fi

    local new_ver new_tag
    new_ver="${out%%$'\t'*}"
    new_tag="${out##*$'\t'}"

    if [[ -z "$new_ver" || "$new_ver" == "$current" ]]; then
        adm_log_ok "Nenhuma versão mais nova para aplicar em $pkg_id (continua em $current)."
        return 0
    fi

    adm_log_info "Nova versão detectada em upstream de $pkg_id: $current → $new_ver (tag=$new_tag)"
    adm_event_pkg "PKG_UPDATE_APPLY_START" "$pkg_id" "current=$current new=$new_ver tag=$new_tag"

    # Captura build_deps antigos antes da mudança
    local old_build_deps
    old_build_deps="$(adm_deps_read_meta_field_list "$meta" "build_deps" || true)"

    # 1) backup
    adm_update_backup_metadado "$meta"

    # 2) editar metadado: version + source_uri + limpar checksums
    adm_update_edit_meta_version_and_sources "$meta" "$current" "$new_ver"

    # 3) recalcular checksums (fazendo fetch)
    adm_update_recompute_checksums "$pkg_id" "$meta"

    # 4) rodar scan + detectar deps novas + gerar metadados stub + por na fila
    adm_update_scan_and_new_deps "$pkg_id" "$meta" "$old_build_deps"

    # 5) colocar o próprio pacote na fila de upgrade
    adm_update_pending_add "$pkg_id"

    adm_event_pkg "PKG_UPDATE_APPLY_DONE" "$pkg_id" "new=$new_ver"
    adm_log_ok "Update de metadado aplicado para $pkg_id ($current → $new_ver)."

    return 0
}

adm_update_apply_one() {
    # Wrapper com métricas
    local pkg_id="${1:-}"
    adm_metrics_time_block "UPDATE" "$pkg_id" "adm_update_apply" adm_update_apply_one_core "$pkg_id"
}

# =========
# CLI
# =========

adm_update_usage() {
    cat <<EOF
adm-update - Atualizador de metadados / versão do ADM 2.0

Uso:

  Checar se existe nova versão no upstream (sem modificar nada):
    adm-update check PKG_ID

  Aplicar update de versão/URIs/checksums/scan/deps e registrar na fila de upgrade:
    adm-update apply PKG_ID

  Ver fila de pacotes pendentes de upgrade:
    adm-update list-pending

  Limpar fila de pendentes:
    adm-update clear-pending

Notas:

  - Hoje, a detecção automática de nova versão funciona para upstreams git
    (url: ou source_uri: apontando para repositório git).
  - Outros tipos de upstream podem ser suportados futuramente (hooks específicos, etc).

Variáveis:

  ADM_DRY_RUN=1
      Não altera arquivos (metadado, pending.list, etc).
      Apenas mostra (logs) o que seria feito.

EOF
}

adm_update_main() {
    local cmd="${1:-}"

    case "$cmd" in
        check)
            shift || true
            if [[ $# -lt 1 ]]; then
                adm_log_fatal "Uso: adm-update check PKG_ID"
            fi
            adm_update_check_one "$1"
            ;;
        apply)
            shift || true
            if [[ $# -lt 1 ]]; then
                adm_log_fatal "Uso: adm-update apply PKG_ID"
            fi
            adm_update_apply_one "$1"
            ;;
        list-pending)
            adm_update_pending_list
            ;;
        clear-pending)
            adm_update_pending_clear
            ;;
        --help|-h|"")
            adm_update_usage
            ;;
        *)
            adm_log_fatal "Comando desconhecido para adm-update: '$cmd'"
            ;;
    esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    adm_update_main "$@"
fi

# Fim do adm-update
