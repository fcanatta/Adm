#!/usr/bin/env bash
# adm-snapshot - Snapshots de estado do ADM 2.0
#
# Comandos:
#
#   adm-snapshot create [NOME]
#       - Cria snapshot em:
#           ${ADM_DB_SNAPSHOTS_DIR}/snap-<nome>.snap
#         (se NOME não for passado, usa timestamp).
#       - Registra:
#           [meta]
#           [packages] (pkg_id, version, release, profile, libc)
#           [profiles] (perfis extremos glibc/musl e simple para toolchain)
#           [toolchains] (placeholder por enquanto)
#       - Registra evento em history 2.0:
#           action=SNAPSHOT_CREATE type=snapshot
#
#   adm-snapshot diff SNAP_A SNAP_B
#       - Compara dois snapshots (nomes lógicos ou caminhos).
#       - Mostra:
#           * pacotes só em A (removidos)
#           * pacotes só em B (novos)
#           * pacotes mudados (upgrade/downgrade A→B)
#       - Registra evento em history:
#           action=SNAPSHOT_DIFF type=snapshot
#
#   adm-snapshot restore SNAP
#       - Compara estado atual (db/installed) com snapshot alvo.
#       - Calcula plano para voltar ao snapshot:
#           * install   (existem no snapshot, não instalados)
#           * upgrade   (instalado < snapshot)
#           * downgrade (instalado > snapshot)
#           * remove    (instalados mas não no snapshot)
#       - Gera planos:
#           ${ADM_DB_SNAPSHOTS_DIR}/restore-<snap>-<timestamp>.install
#           ${ADM_DB_SNAPSHOTS_DIR}/restore-<snap>-<timestamp>.upgrade
#           ${ADM_DB_SNAPSHOTS_DIR}/restore-<snap>-<timestamp>.downgrade
#           ${ADM_DB_SNAPSHOTS_DIR}/restore-<snap>-<timestamp>.remove
#       - Registra evento em history:
#           action=SNAPSHOT_RESTORE type=snapshot
#
# Requisitos:
#   - adm-env, adm-log-ui, adm-eventd, adm-metrics, adm-db
#
# Notas:
#   - Perfis extremos são sempre registrados em [profiles]:
#       glibc/extreme   (otimizações extremas glibc)
#       musl/extreme    (otimizações extremas musl)
#       toolchain/simple (perfil simples para toolchain)

set -o errexit
set -o nounset
set -o pipefail

# =========
# Descobrir diretório do script e carregar módulos
# =========

_adm_snapshot_script_dir() {
    local src="${BASH_SOURCE[0]:-$0}"

    while [ -L "$src" ]; do
        local target
        target=$(readlink "$src") || break
        if [[ "$target" = /* ]]; then
            src="$target"
        else
            src="$(dirname "$src")/$target"
        fi
    done

    cd "$(dirname "$src")" >/dev/null 2>&1 || {
        printf 'ADM-ERROR: Não foi possível entrar no diretório do script adm-snapshot.\n' >&2
        exit 1
    }
    pwd
}

_ADM_SNAPSHOT_DIR="$(_adm_snapshot_script_dir)"

# shellcheck disable=SC1090
source "$_ADM_SNAPSHOT_DIR/adm-env"
# shellcheck disable=SC1090
source "$_ADM_SNAPSHOT_DIR/adm-log-ui"
# shellcheck disable=SC1090
source "$_ADM_SNAPSHOT_DIR/adm-eventd"
# shellcheck disable=SC1090
source "$_ADM_SNAPSHOT_DIR/adm-metrics"
# shellcheck disable=SC1090
source "$_ADM_SNAPSHOT_DIR/adm-db"

# Usa diretório de snapshots do adm-env; permite override por ADM_SNAPSHOT_DIR se for definido externamente.
ADM_SNAPSHOT_DIR="${ADM_SNAPSHOT_DIR:-$ADM_DB_SNAPSHOTS_DIR}"

# =========
# Utilidades de path / nome
# =========

adm_snapshot_ensure_dir() {
    if [[ ! -d "$ADM_SNAPSHOT_DIR" ]]; then
        mkdir -p "$ADM_SNAPSHOT_DIR" || adm_log_fatal "Falha ao criar '$ADM_SNAPSHOT_DIR'."
    fi
}

adm_snapshot_normalize_name() {
    # Converte um nome "foo" em "<ADM_SNAPSHOT_DIR>/snap-foo.snap".
    local name="$1"

    # Se já parece caminho, devolve como veio
    if [[ "$name" == */* ]]; then
        printf '%s\n' "$name"
        return 0
    fi

    # Se já tem .snap, assume
    if [[ "$name" == *.snap ]]; then
        printf '%s\n' "${ADM_SNAPSHOT_DIR}/$name"
    else
        printf '%s\n' "${ADM_SNAPSHOT_DIR}/snap-${name}.snap"
    fi
}

adm_snapshot_default_name() {
    date '+snap-%Y%m%d-%H%M%S'
}

adm_snapshot_path_for_create() {
    local name="${1:-}"

    adm_snapshot_ensure_dir

    if [[ -z "$name" ]]; then
        name="$(adm_snapshot_default_name)"
    fi

    # tira prefixo "snap-" se o usuário passar, pra não duplicar
    name="${name#snap-}"

    printf '%s\n' "${ADM_SNAPSHOT_DIR}/snap-${name}.snap"
}

adm_snapshot_readable_name_from_path() {
    local path="$1"

    path="${path##*/}"   # tira diretórios
    path="${path%.snap}" # tira extensão
    path="${path#snap-}" # tira prefixo snap-

    printf '%s\n' "$path"
}

# =========
# Leitura do estado atual (db/installed)
# =========

adm_snapshot_current_packages_to_tmp() {
    # Gera arquivo temporário com:
    #   pkg_id  version  release  profile  libc
    #
    # Saída:
    #   imprime caminho do arquivo temporário.

    local tmp
    tmp="$(mktemp "$ADM_TMP_DIR/snap-current-pkgs-XXXXXX")" \
        || adm_log_fatal "Falha ao criar tmp para current pkgs."

    adm_db_list_installed \
        | awk 'NF>=2 {print $1 "\t" $2 "\t" $3 "\t" $4 "\t" $5}' \
        >"$tmp"

    printf '%s\n' "$tmp"
}

# =========
# Escrita de seção [profiles] (perfis extremos)
# =========

adm_snapshot_write_profiles_extreme() {
    # Escreve perfis "extremos" básicos em stdout, no formato:
    #   profile_id  kind  libc  opt_level
    #
    # Para agora, definimos:
    #   glibc/extreme    -> kind=extreme, libc=glibc,    opt_level=O3-LTO-PGO
    #   musl/extreme     -> kind=extreme, libc=musl,     opt_level=O3-LTO
    #   toolchain/simple -> kind=simple,  libc=toolchain,opt_level=O2-safe

    printf 'glibc/extreme\textreme\tglibc\tO3-LTO-PGO\n'
    printf 'musl/extreme\textreme\tmusl\tO3-LTO\n'
    printf 'toolchain/simple\tsimple\ttoolchain\tO2-safe\n'
}

adm_snapshot_write_toolchains_placeholder() {
    # Placeholder; quando existir adm-toolchain, pode ser:
    #   adm-toolchain list
    # Formato sugerido:
    #   toolchain_id  libc  profile  comment
    :
}

# =========
# Criação de snapshot
# =========

adm_snapshot_create_core() {
    # Uso interno: adm_snapshot_create_core NOME_SNAP
    local name="${1:-}"

    local path
    path="$(adm_snapshot_path_for_create "$name")"

    local short_name
    short_name="$(adm_snapshot_readable_name_from_path "$path")"

    adm_log_phase_header "Criando snapshot '$short_name' em $path"
    adm_event_emit "SNAPSHOT_CREATE_START" "-" "name=$short_name path=$path"

    local tmp_pkgs
    tmp_pkgs="$(adm_snapshot_current_packages_to_tmp)"

    local ts_epoch ts_human pid
    ts_epoch="$(date +%s)"
    ts_human="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
    pid="$$"

    # Conta quantos pacotes foram registrados
    local pkgs_count
    pkgs_count=$(wc -l <"$tmp_pkgs" 2>/dev/null || echo 0)

    {
        echo "[meta]"
        echo "name=$short_name"
        echo "created_epoch=$ts_epoch"
        echo "created_human=$ts_human"
        echo "creator_pid=$pid"
        echo "adm_version=$ADM_VERSION"
        echo

        echo "[packages]"
        # pkg_id version release profile libc
        awk 'NF>=2 {print}' "$tmp_pkgs"
        echo

        echo "[profiles]"
        adm_snapshot_write_profiles_extreme
        echo

        echo "[toolchains]"
        adm_snapshot_write_toolchains_placeholder
        echo
    } >"$path.tmp" || adm_log_fatal "Falha ao escrever snapshot temporário em '$path.tmp'."

    mv "$path.tmp" "$path" || adm_log_fatal "Falha ao mover snapshot temporário para '$path'."

    rm -f "$tmp_pkgs" || true

    adm_log_ok "Snapshot criado: $path"

    # Registra eventos
    adm_event_emit "SNAPSHOT_CREATE_DONE" "-" "name=$short_name path=$path count=$pkgs_count"
    adm_db_history_snapshot "SNAPSHOT_CREATE" "$short_name" "OK" \
        "type=snapshot path=$path pkgs=$pkgs_count"
}

adm_snapshot_create() {
    local name="${1:-}"

    adm_metrics_time_block "SNAPSHOT" "SNAPSHOT_CREATE" "adm-snapshot create $name" \
        adm_snapshot_create_core "$name"
}

# =========
# Leitura de pacotes de um snapshot
# =========

adm_snapshot_read_packages_to_tmp() {
    # Uso:
    #   adm_snapshot_read_packages_to_tmp SNAP_PATH
    #
    # Saída:
    #   caminho de arquivo temporário com:
    #       pkg_id  version  release  profile  libc
    local snap="$1"

    if [[ ! -f "$snap" ]]; then
        adm_log_fatal "Snapshot não encontrado: '$snap'"
    fi

    local tmp
    tmp="$(mktemp "$ADM_TMP_DIR/snap-pkgs-XXXXXX")" \
        || adm_log_fatal "Falha ao criar tmp para snapshot pkgs."

    awk '
        BEGIN { inpk = 0 }
        /^\[packages\]/ { inpk = 1; next }
        /^\[/ && $0 !~ /^\[packages\]/ { inpk = 0 }
        inpk && NF > 0 {
            # Aceita campos separados por tab ou espaço.
            # Esperamos: pkg_id version release profile libc
            pkg  = $1
            ver  = $2
            rel  = $3
            prof = $4
            libc = $5
            if (ver  == "") ver  = "-"
            if (rel  == "") rel  = "-"
            if (prof == "") prof = "-"
            if (libc == "") libc = "-"
            printf "%s\t%s\t%s\t%s\t%s\n", pkg, ver, rel, prof, libc
        }
    ' "$snap" >"$tmp"

    printf '%s\n' "$tmp"
}

# =========
# Comparação de versões (sort -V)
# =========

adm_snapshot_vercmp() {
    # Compara duas strings de versão (pode incluir release junto, ex: "1.2-1").
    #
    # Uso:
    #   result=$(adm_snapshot_vercmp V1 V2)
    #
    # Retorno (via stdout):
    #   -1 se V1 < V2
    #    0 se V1 == V2
    #    1 se V1 > V2

    local v1="$1"
    local v2="$2"

    if [[ "$v1" == "$v2" ]]; then
        echo "0"
        return 0
    fi

    if sort -V /dev/null 2>&1; then
        local highest
        highest="$(printf '%s\n%s\n' "$v1" "$v2" | sort -V | tail -n1)"
        if [[ "$highest" == "$v1" ]]; then
            echo "1"
        else
            echo "-1"
        fi
    else
        # fallback: comparação lexicográfica simples
        if [[ "$v1" > "$v2" ]]; then
            echo "1"
        else
            echo "-1"
        fi
    fi
}

# =========
# Diff entre dois snapshots
# =========

adm_snapshot_diff_core() {
    # Uso:
    #   adm_snapshot_diff_core SNAP_A SNAP_B
    #
    # Interpretação:
    #   - A = "antes"
    #   - B = "depois"

    local snap_a="$1"
    local snap_b="$2"

    local path_a path_b
    path_a="$(adm_snapshot_normalize_name "$snap_a")"
    path_b="$(adm_snapshot_normalize_name "$snap_b")"

    local name_a name_b
    name_a="$(adm_snapshot_readable_name_from_path "$path_a")"
    name_b="$(adm_snapshot_readable_name_from_path "$path_b")"

    adm_log_phase_header "Diff entre snapshots '$name_a' e '$name_b'"
    adm_event_emit "SNAPSHOT_DIFF_START" "-" "A=$name_a B=$name_b"

    local tmp_a tmp_b
    tmp_a="$(adm_snapshot_read_packages_to_tmp "$path_a")"
    tmp_b="$(adm_snapshot_read_packages_to_tmp "$path_b")"

    # sort por pkg_id
    local sa sb
    sa="$(mktemp "$ADM_TMP_DIR/snapA-sorted-XXXXXX")" || adm_log_fatal "Falha ao criar tmp."
    sb="$(mktemp "$ADM_TMP_DIR/snapB-sorted-XXXXXX")" || adm_log_fatal "Falha ao criar tmp."

    sort -k1,1 "$tmp_a" >"$sa"
    sort -k1,1 "$tmp_b" >"$sb"

    adm_log_info "Pacotes removidos (presentes em $name_a, não em $name_b):"
    local any_removed=0
    # join com -a1 para ver entradas só em A
    while IFS=$'\t' read -r pkg a_ver a_rel b_ver b_rel; do
        if [[ -n "$a_ver" && -z "$b_ver" ]]; then
            adm_log_info " - $pkg $a_ver-$a_rel"
            any_removed=1
        fi
    done < <(join -t $'\t' -a 1 -e '' -o '0,1.2,1.3,2.2,2.3' "$sa" "$sb")

    if [[ $any_removed -eq 0 ]]; then
        adm_log_info " (nenhum)"
    fi

    adm_log_info ""
    adm_log_info "Pacotes novos (presentes em $name_b, não em $name_a):"
    local any_new=0
    while IFS=$'\t' read -r pkg a_ver a_rel b_ver b_rel; do
        if [[ -z "$a_ver" && -n "$b_ver" ]]; then
            adm_log_info " + $pkg $b_ver-$b_rel"
            any_new=1
        fi
    done < <(join -t $'\t' -a 2 -e '' -o '0,1.2,1.3,2.2,2.3' "$sa" "$sb")

    if [[ $any_new -eq 0 ]]; then
        adm_log_info " (nenhum)"
    fi

    adm_log_info ""
    adm_log_info "Pacotes com versão diferente ($name_a → $name_b):"

    local any_changed=0
    while IFS=$'\t' read -r pkg a_ver a_rel b_ver b_rel; do
        if [[ -n "$a_ver" && -n "$b_ver" ]]; then
            local v_old v_new cmp
            v_old="${a_ver}-${a_rel}"
            v_new="${b_ver}-${b_rel}"

            if [[ "$v_old" != "$v_new" ]]; then
                cmp="$(adm_snapshot_vercmp "$v_old" "$v_new")"
                any_changed=1
                if [[ "$cmp" -lt 0 ]]; then
                    adm_log_info " ↑ $pkg $v_old -> $v_new (upgrade)"
                elif [[ "$cmp" -gt 0 ]]; then
                    adm_log_info " ↓ $pkg $v_old -> $v_new (downgrade)"
                else
                    adm_log_info " * $pkg $v_old -> $v_new (diferença não ordenável)"
                fi
            fi
        fi
    done < <(join -t $'\t' -e '' -o '0,1.2,1.3,2.2,2.3' "$sa" "$sb")

    if [[ $any_changed -eq 0 ]]; then
        adm_log_info " (nenhum)"
    fi

    rm -f "$tmp_a" "$tmp_b" "$sa" "$sb" || true

    adm_event_emit "SNAPSHOT_DIFF_DONE" "-" "A=$name_a B=$name_b removed=$any_removed new=$any_new changed=$any_changed"
    adm_db_history_snapshot "SNAPSHOT_DIFF" "${name_a}->${name_b}" "OK" \
        "type=snapshot removed=$any_removed new=$any_new changed=$any_changed"
}

adm_snapshot_diff() {
    local snap_a="$1"
    local snap_b="$2"

    adm_metrics_time_block "SNAPSHOT" "SNAPSHOT_DIFF" "adm-snapshot diff $snap_a $snap_b" \
        adm_snapshot_diff_core "$snap_a" "$snap_b"
}

# =========
# Restore (plano para voltar ao snapshot)
# =========

adm_snapshot_restore_core() {
    # Uso:
    #   adm_snapshot_restore_core SNAP_NAME_OR_PATH
    #
    # Interpretação:
    #   - estado atual = A
    #   - snapshot     = B (alvo)

    local snap="$1"

    adm_snapshot_ensure_dir

    local path
    path="$(adm_snapshot_normalize_name "$snap")"

    local name
    name="$(adm_snapshot_readable_name_from_path "$path")"

    if [[ ! -f "$path" ]]; then
        adm_log_fatal "Snapshot alvo não encontrado: '$path'"
    fi

    adm_log_phase_header "Calculando plano de restore para snapshot '$name' ($path)"
    adm_event_emit "SNAPSHOT_RESTORE_START" "-" "name=$name path=$path"

    local tmp_current tmp_target
    tmp_current="$(adm_snapshot_current_packages_to_tmp)"
    tmp_target="$(adm_snapshot_read_packages_to_tmp "$path")"

    local sa sb
    sa="$(mktemp "$ADM_TMP_DIR/restore-current-XXXXXX")" || adm_log_fatal "Falha ao criar tmp."
    sb="$(mktemp "$ADM_TMP_DIR/restore-target-XXXXXX")" || adm_log_fatal "Falha ao criar tmp."

    sort -k1,1 "$tmp_current" >"$sa"
    sort -k1,1 "$tmp_target" >"$sb"

    local ts
    ts="$(date '+%Y%m%d-%H%M%S')"

    local base="${ADM_SNAPSHOT_DIR}/restore-${name}-${ts}"
    local f_install="${base}.install"
    local f_upgrade="${base}.upgrade"
    local f_downgrade="${base}.downgrade"
    local f_remove="${base}.remove"

    : >"$f_install"
    : >"$f_upgrade"
    : >"$f_downgrade"
    : >"$f_remove"

    # join: pkg_id, cur_ver, cur_rel, tgt_ver, tgt_rel
    while IFS=$'\t' read -r pkg cur_ver cur_rel tgt_ver tgt_rel; do
        if [[ -z "$pkg" ]]; then
            continue
        fi

        if [[ -n "$cur_ver" && -z "$tgt_ver" ]]; then
            # existe na instalação atual, não existe no snapshot alvo -> remove
            printf '%s\n' "$pkg" >>"$f_remove"
            continue
        fi

        if [[ -z "$cur_ver" && -n "$tgt_ver" ]]; then
            # não instalado, mas existe no snapshot -> install
            printf '%s\n' "$pkg" >>"$f_install"
            continue
        fi

        if [[ -n "$cur_ver" && -n "$tgt_ver" ]]; then
            local v_cur v_tgt
            v_cur="${cur_ver}-${cur_rel}"
            v_tgt="${tgt_ver}-${tgt_rel}"

            if [[ "$v_cur" == "$v_tgt" ]]; then
                # já na versão do snapshot
                continue
            fi

            local cmp
            cmp="$(adm_snapshot_vercmp "$v_cur" "$v_tgt")"

            if [[ "$cmp" -lt 0 ]]; then
                # cur < tgt -> upgrade pra versão do snapshot
                printf '%s\n' "$pkg" >>"$f_upgrade"
            elif [[ "$cmp" -gt 0 ]]; then
                # cur > tgt -> downgrade pra versão do snapshot
                printf '%s\n' "$pkg" >>"$f_downgrade"
            else
                # empate "esquisito" mas diferente de string: trata como upgrade
                printf '%s\n' "$pkg" >>"$f_upgrade"
            fi
        fi
    done < <(join -t $'\t' -a 1 -a 2 -e '' -o '0,1.2,1.3,2.2,2.3' "$sa" "$sb")

    rm -f "$tmp_current" "$tmp_target" "$sa" "$sb" || true

    adm_log_phase_header "Plano de restore para snapshot '$name' (arquivos):"
    adm_log_info " Instalar : $f_install"
    adm_log_info " Upgrade  : $f_upgrade"
    adm_log_info " Downgrade: $f_downgrade"
    adm_log_info " Remover  : $f_remove"
    adm_log_info ""

    adm_log_info "Resumo (contagem):"

    local c_install c_upgrade c_downgrade c_remove
    c_install=$(wc -l <"$f_install" 2>/dev/null || echo 0)
    c_upgrade=$(wc -l <"$f_upgrade" 2>/dev/null || echo 0)
    c_downgrade=$(wc -l <"$f_downgrade" 2>/dev/null || echo 0)
    c_remove=$(wc -l <"$f_remove" 2>/dev/null || echo 0)

    adm_log_info " instalar : $c_install"
    adm_log_info " upgrade  : $c_upgrade"
    adm_log_info " downgrade: $c_downgrade"
    adm_log_info " remover  : $c_remove"
    adm_log_info ""

    adm_log_info "Você pode, por exemplo:"
    adm_log_info " - Rodar upgrades : adm-upgrade file $f_upgrade"
    adm_log_info " - Rodar installs : adm-upgrade file $f_install"
    adm_log_info " - Rodar downgrades (estratégia a definir, ex. travar metadados)"
    adm_log_info " - Remover        : script de remoção lendo $f_remove"

    adm_event_emit "SNAPSHOT_RESTORE_DONE" "-" "name=$name install=$c_install upgrade=$c_upgrade downgrade=$c_downgrade remove=$c_remove"
    adm_db_history_snapshot "SNAPSHOT_RESTORE" "$name" "OK" \
        "type=snapshot plan_base=$base install=$c_install upgrade=$c_upgrade downgrade=$c_downgrade remove=$c_remove"
}

adm_snapshot_restore() {
    local snap="$1"

    adm_metrics_time_block "SNAPSHOT" "SNAPSHOT_RESTORE" "adm-snapshot restore $snap" \
        adm_snapshot_restore_core "$snap"
}

# =========
# CLI
# =========

adm_snapshot_usage() {
    cat <<EOF
Uso: adm-snapshot <comando> [opções]

Comandos:

  create [NOME]
      Cria snapshot do estado atual dos pacotes instalados.
      O arquivo é salvo em:
          ${ADM_SNAPSHOT_DIR}/snap-<nome>.snap
      Se NOME não for informado, é usado um timestamp.
      Registra perfis extremos (glibc/extreme, musl/extreme, toolchain/simple)
      e um placeholder em [toolchains].
      Também registra evento em history 2.0 com action=SNAPSHOT_CREATE.

  diff SNAP_A SNAP_B
      Compara dois snapshots (nomes lógicos ou caminhos).
      Mostra:
        - pacotes removidos (presentes em A, ausentes em B)
        - pacotes novos (presentes em B, ausentes em A)
        - pacotes com versões diferentes (upgrade/downgrade).
      Também registra evento em history 2.0 com action=SNAPSHOT_DIFF.

  restore SNAP
      Compara o estado atual (db/installed) com o snapshot SNAP e gera um plano
      em arquivos:
        ${ADM_SNAPSHOT_DIR}/restore-<snap>-<ts>.install
        ${ADM_SNAPSHOT_DIR}/restore-<snap>-<ts>.upgrade
        ${ADM_SNAPSHOT_DIR}/restore-<snap>-<ts>.downgrade
        ${ADM_SNAPSHOT_DIR}/restore-<snap>-<ts>.remove
      que podem ser consumidos por adm-upgrade e scripts de remoção.
      Também registra evento em history 2.0 com action=SNAPSHOT_RESTORE.

  --help, -h
      Mostra esta ajuda.
EOF
}

adm_snapshot_main() {
    local cmd="${1:-}"

    case "$cmd" in
        create)
            shift || true
            local name="${1:-}"
            adm_snapshot_create "$name"
            ;;
        diff)
            shift || true
            if [[ $# -lt 2 ]]; then
                adm_log_fatal "Uso: adm-snapshot diff SNAP_A SNAP_B"
            fi
            adm_snapshot_diff "$1" "$2"
            ;;
        restore)
            shift || true
            if [[ $# -lt 1 ]]; then
                adm_log_fatal "Uso: adm-snapshot restore SNAP"
            fi
            adm_snapshot_restore "$1"
            ;;
        --help|-h|"")
            adm_snapshot_usage
            ;;
        *)
            adm_log_fatal "Comando desconhecido para adm-snapshot: '$cmd'"
            ;;
    esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    adm_snapshot_main "$@"
fi
