#!/usr/bin/env bash
# adm-tui - Interface TUI (texto) para monitorar builds do ADM 2.0
#
# Funcionalidades:
#
# - Mostra fila de pacotes, status e progresso global.
# - Usa eventos do adm-eventd (PKG_BUILD_*) para estado dos pacotes.
# - Usa adm_build_log_file_for_pkg para mostrar logs do build do pacote selecionado.
#
# Controles:
#   q           -> sair
#   ↑ / k       -> mover seleção para cima
#   ↓ / j       -> mover seleção para baixo
#   espaço      -> pausar/resumir builds (db/control/build.paused)
#   p           -> priorizar pacote selecionado (db/control/build.priority)
#   r           -> refresh manual (além do refresh automático por tempo)
#
# O TUI não executa builds; ele só observa/controla via arquivos:
#
#   - Pausa/Resume:
#       ${ADM_DB_CONTROL_DIR}/build.paused    (arquivo sentinel)
#
#   - Prioridade:
#       ${ADM_DB_CONTROL_DIR}/build.priority  (uma linha por pkg_id, topo = mais prioritário)
#
# Estado vem de:
#
#   - pending.list (fila de updates):
#       ${ADM_DB_UPDATES_DIR}/pending.list
#
#   - eventos (adm-eventd):
#       ${ADM_DB_EVENTS_DIR}/events-*.log
#
# Formato de evento (TSV):
#   ts  pid  event  pkg_id  extra
#
# Eventos considerados:
#   PKG_BUILD_QUEUED
#   PKG_BUILD_START
#   PKG_BUILD_DONE
#   PKG_BUILD_FAIL

set -o errexit
set -o nounset
set -o pipefail

# =========
# Descobrir diretório do script e carregar módulos
# =========

_adm_tui_script_dir() {
    local src="${BASH_SOURCE[0]:-$0}"

    while [ -L "$src" ]; do
        local target
        target=$(readlink "$src") || break
        if [[ "$target" = /* ]]; then
            src="$target"
        else
            src="$(dirname "$src")/$target"
        fi
    done

    cd "$(dirname "$src")" >/dev/null 2>&1 || {
        printf 'ADM-ERROR: Não foi possível entrar no diretório do script adm-tui.\n' >&2
        exit 1
    }
    pwd
}

_ADM_TUI_DIR="$(_adm_tui_script_dir)"

# shellcheck disable=SC1090
source "$_ADM_TUI_DIR/adm-env"
# shellcheck disable=SC1090
source "$_ADM_TUI_DIR/adm-log-ui"
# shellcheck disable=SC1090
source "$_ADM_TUI_DIR/adm-eventd"
# shellcheck disable=SC1090
source "$_ADM_TUI_DIR/adm-db"
# shellcheck disable=SC1090
source "$_ADM_TUI_DIR/adm-build"
# shellcheck disable=SC1090
source "$_ADM_TUI_DIR/adm-profile"

ADM_DB_EVENTS_DIR="${ADM_DB_EVENTS_DIR:-${ADM_DB_DIR}/events}"
ADM_DB_CONTROL_DIR="${ADM_DB_CONTROL_DIR:-${ADM_DB_DIR}/control}"
ADM_DB_UPDATES_DIR="${ADM_DB_UPDATES_DIR:-${ADM_DB_DIR}/updates}"
ADM_DB_UPDATES_PENDING="${ADM_DB_UPDATES_DIR}/pending.list"

mkdir -p "$ADM_DB_CONTROL_DIR" >/dev/null 2>&1 || true

ADM_TUI_REFRESH_INTERVAL="${ADM_TUI_REFRESH_INTERVAL:-0.5}"   # segs
ADM_TUI_LOG_LINES="${ADM_TUI_LOG_LINES:-10}"                  # linhas de log
ADM_TUI_MAX_ROWS="${ADM_TUI_MAX_ROWS:-20}"                    # máx de linhas da tabela

# =========
# Utilidades de terminal
# =========

adm_tui_term_init() {
    tput civis 2>/dev/null || true   # esconde cursor
    tput smcup 2>/dev/null || true   # salva tela
    tput clear 2>/dev/null || true
}

adm_tui_term_restore() {
    tput rmcup 2>/dev/null || true   # restaura tela
    tput cnorm 2>/dev/null || true   # mostra cursor
}

adm_tui_move() {
    local row="$1"
    local col="$2"
    tput cup "$row" "$col" 2>/dev/null || true
}

adm_tui_clear_screen() {
    tput clear 2>/dev/null || true
}

adm_tui_color_title()   { tput bold 2>/dev/null; tput setaf 6 2>/dev/null; } # ciano
adm_tui_color_header()  { tput bold 2>/dev/null; tput setaf 3 2>/dev/null; } # amarelo
adm_tui_color_ok()      { tput setaf 2 2>/dev/null; tput bold 2>/dev/null; } # verde
adm_tui_color_warn()    { tput setaf 3 2>/dev/null; }                         # amarelo
adm_tui_color_error()   { tput setaf 1 2>/dev/null; tput bold 2>/dev/null; }  # vermelho
adm_tui_color_dim()     { tput dim 2>/dev/null; }
adm_tui_color_reset()   { tput sgr0 2>/dev/null; }

# =========
# Estado / fila / controle
# =========

adm_tui_is_paused() {
    [[ -f "${ADM_DB_CONTROL_DIR}/build.paused" ]]
}

adm_tui_toggle_pause() {
    if adm_tui_is_paused; then
        rm -f "${ADM_DB_CONTROL_DIR}/build.paused" || true
    else
        touch "${ADM_DB_CONTROL_DIR}/build.paused" || true
    fi
}

adm_tui_priority_add() {
    # Adiciona PKG_ID ao topo da lista de prioridade (se não estiver já).
    local pkg_id="$1"
    local file="${ADM_DB_CONTROL_DIR}/build.priority"
    local tmp

    tmp="$(mktemp "$ADM_TMP_DIR/tui-prio-XXXXXX")" || return 1

    {
        echo "$pkg_id"
        if [[ -f "$file" ]]; then
            grep -vxF "$pkg_id" "$file" 2>/dev/null || true
        fi
    } >"$tmp"

    mv "$tmp" "$file" || true
}

adm_tui_read_pending_list() {
    # Lê pending.list (se existir) - fila "lógica" de updates.
    if [[ ! -f "$ADM_DB_UPDATES_PENDING" ]]; then
        return 0
    fi

    awk 'NF>0 && $1 !~ /^#/ {print $1}' "$ADM_DB_UPDATES_PENDING"
}

adm_tui_last_events_file() {
    # Pega o arquivo de eventos mais recente, se existir.
    if [[ ! -d "$ADM_DB_EVENTS_DIR" ]]; then
        return 1
    fi

    local f
    f=$(ls "$ADM_DB_EVENTS_DIR"/events-*.log 2>/dev/null | sort | tail -n1 || true)
    if [[ -z "$f" ]]; then
        return 1
    fi

    printf '%s\n' "$f"
}

adm_tui_collect_state() {
    # Gera o estado dos pacotes a partir de:
    # - pending.list (como fila base -> status=QUEUED)
    # - último arquivo de eventos (events-YYYYMMDD.log)
    #
    # Saída (TSV):
    #   pkg_id  status  last_ts
    #
    # status: QUEUED, BUILDING, DONE, FAIL

    local tmp pending_file events_file

    tmp="$(mktemp "$ADM_TMP_DIR/tui-state-XXXXXX")" || return 1
    pending_file="$(mktemp "$ADM_TMP_DIR/tui-pending-XXXXXX")" || return 1

    adm_tui_read_pending_list >"$pending_file" 2>/dev/null || true
    events_file="$(adm_tui_last_events_file || true)"

    awk -v pending_file="$pending_file" -v events_file="$events_file" '
        BEGIN {
            FS = "\t"
            # Primeiro, pending.list -> QUEUED
            if (pending_file != "") {
                while ((getline pl < pending_file) > 0) {
                    if (pl == "" || pl ~ /^#/) continue
                    pkg = pl
                    if (!(pkg in status)) {
                        status[pkg] = "QUEUED"
                        ts_last[pkg] = "-"
                    }
                }
                close(pending_file)
            }

            # Depois, eventos
            if (events_file != "") {
                while ((getline ev < events_file) > 0) {
                    # ts pid event pkg extra
                    if (NF < 4) continue
                    ts  = $1
                    evt = $3
                    pkg = $4
                    if (pkg == "") continue

                    if (evt == "PKG_BUILD_QUEUED") {
                        status[pkg] = "QUEUED"
                        ts_last[pkg] = ts
                    } else if (evt == "PKG_BUILD_START") {
                        status[pkg] = "BUILDING"
                        ts_last[pkg] = ts
                    } else if (evt == "PKG_BUILD_DONE") {
                        status[pkg] = "DONE"
                        ts_last[pkg] = ts
                    } else if (evt == "PKG_BUILD_FAIL") {
                        status[pkg] = "FAIL"
                        ts_last[pkg] = ts
                    }
                }
                close(events_file)
            }

            # Imprime estado final
            for (p in status) {
                printf "%s\t%s\t%s\n", p, status[p], ts_last[p]
            }
        }
    ' >"$tmp"

    cat "$tmp"
    rm -f "$pending_file" "$tmp" 2>/dev/null || true
}

adm_tui_build_log_tail() {
    # Imprime as últimas N linhas de log do pkg_id, se existir.
    local pkg_id="$1"
    local lines="${2:-$ADM_TUI_LOG_LINES}"

    if ! type -t adm_build_log_file_for_pkg >/dev/null 2>&1; then
        echo "(adm_build_log_file_for_pkg não disponível.)"
        return 0
    fi

    local log
    log="$(adm_build_log_file_for_pkg "$pkg_id" || true)"

    if [[ -z "$log" || ! -f "$log" ]]; then
        echo "(Nenhum log encontrado para $pkg_id.)"
        return 0
    fi

    tail -n "$lines" "$log" 2>/dev/null || echo "(Erro lendo log de $pkg_id.)"
}

# =========
# Desenho da tela
# =========

adm_tui_draw_progress_bar() {
    # Uso:
    #   adm_tui_draw_progress_bar row col width done total
    local row="$1"
    local col="$2"
    local width="$3"
    local done="$4"
    local total="$5"

    local ratio=0
    local filled=0

    if [[ "$total" -gt 0 ]]; then
        ratio=$(( done * 100 / total ))
        filled=$(( done * width / total ))
    fi

    adm_tui_move "$row" "$col"
    printf "["

    local i
    for ((i=0; i<width; i++)); do
        if (( i < filled )); then
            printf "#"
        else
            printf " "
        fi
    done

    printf "] %3d%%" "$ratio"
}

adm_tui_draw_screen() {
    # Uso:
    #   adm_tui_draw_screen selected_index state_file
    local selected_index="$1"
    local state_file="$2"

    local rows cols
    rows=$(tput lines 2>/dev/null || echo 24)
    cols=$(tput cols 2>/dev/null || echo 80)

    # Header
    adm_tui_move 0 0
    adm_tui_color_title
    printf " ADM TUI - Monitor de Build "
    adm_tui_color_reset

    # Linha de status/prompt
    adm_tui_move 1 0
    if adm_tui_is_paused; then
        adm_tui_color_warn; printf " [PAUSADO] "; adm_tui_color_reset
    else
        adm_tui_color_ok;   printf " [ATIVO] ";   adm_tui_color_reset
    fi
    printf "q: sair ↑/↓/j/k: mover espaço: pausa/resume p: priorizar r: refresh"

    # Coleta stats (já temos state_file pronto)
    local total=0 done=0 fail=0 building=0 queued=0
    local line pkg status ts

    while IFS=$'\t' read -r pkg status ts; do
        [[ -z "$pkg" ]] && continue
        total=$((total + 1))
        case "$status" in
            DONE)     done=$((done + 1)) ;;
            FAIL)     fail=$((fail + 1)) ;;
            BUILDING) building=$((building + 1)) ;;
            QUEUED)   queued=$((queued + 1)) ;;
        esac
    done <"$state_file"

    local finished=$((done + fail))

    adm_tui_move 2 0
    printf " Total: %d  Queued: %d  Building: %d  Done: %d  Fail: %d" \
        "$total" "$queued" "$building" "$done" "$fail"

    # Barra de progresso global
    adm_tui_draw_progress_bar 3 0 $((cols - 10)) "$finished" "$total"

    # Cabeçalho da tabela
    adm_tui_move 5 0
    adm_tui_color_header
    printf "%-4s %-40s %-10s %-20s\n" "Sel" "Pacote" "Status" "Último evento"
    adm_tui_color_reset

    # Carrega estado em array para poder indexar pela seleção
    mapfile -t state_lines <"$state_file"
    local total_lines=${#state_lines[@]}

    # Scrolling básico: offset da janela da tabela
    local table_start_row=6
    local max_rows="$ADM_TUI_MAX_ROWS"
    local offset=0

    if (( selected_index >= max_rows )); then
        offset=$((selected_index - max_rows + 1))
    fi

    local idx=0
    local row

    for ((i=0; i<total_lines; i++)); do
        if (( i < offset )); then
            continue
        fi
        if (( idx >= max_rows )); then
            break
        fi

        IFS=$'\t' read -r pkg status ts <<<"${state_lines[$i]}"

        row=$((table_start_row + idx))
        if (( row >= rows - 5 )); then
            break
        fi

        adm_tui_move "$row" 0

        if (( i == selected_index )); then
            tput rev 2>/dev/null || true
            printf " -> "
        else
            printf "    "
        fi

        case "$status" in
            DONE)
                adm_tui_color_ok
                ;;
            FAIL)
                adm_tui_color_error
                ;;
            BUILDING)
                tput bold 2>/dev/null || true; tput setaf 4 2>/dev/null || true # azul
                ;;
            QUEUED)
                adm_tui_color_dim
                ;;
            *)
                adm_tui_color_reset
                ;;
        esac

        printf "%-40s %-10s %-20s" "$pkg" "$status" "$ts"
        adm_tui_color_reset

        idx=$((idx + 1))
    done

    # Se não há pacotes
    if (( total == 0 )); then
        adm_tui_move "$table_start_row" 0
        adm_tui_color_dim
        printf "(Nenhum pacote na fila / sem eventos ainda.)"
        adm_tui_color_reset
    fi

    # Log do pacote selecionado
    local selected_pkg=""
    if (( selected_index >= 0 && selected_index < total_lines )); then
        IFS=$'\t' read -r selected_pkg _ <<<"${state_lines[$selected_index]}"
    fi

    local log_row=$((rows - ADM_TUI_LOG_LINES - 2))
    if (( log_row < table_start_row + 3 )); then
        log_row=$((table_start_row + 3))
    fi

    adm_tui_move "$log_row" 0
    adm_tui_color_header
    printf "Log do pacote selecionado: %s (últimas %d linhas)" \
        "${selected_pkg:-"(nenhum)"}" "$ADM_TUI_LOG_LINES"
    adm_tui_color_reset

    if [[ -n "$selected_pkg" ]]; then
        local lr=$((log_row + 1))
        local j=0

        while IFS= read -r line; do
            if (( lr + j >= rows )); then
                break
            fi
            adm_tui_move $((lr + j)) 0
            adm_tui_color_dim
            printf "%s" "$line"
            adm_tui_color_reset
            j=$((j + 1))
        done < <(adm_tui_build_log_tail "$selected_pkg" "$ADM_TUI_LOG_LINES")
    fi
}

# =========
# Loop principal
# =========

adm_tui_main_loop() {
    local state_file selected_index=0 key="" line_count

    state_file="$(mktemp "$ADM_TMP_DIR/tui-state-main-XXXXXX")" \
        || adm_log_fatal "Falha ao criar tmp state para TUI."

    adm_tui_term_init
    trap 'adm_tui_term_restore; rm -f "$state_file" 2>/dev/null || true; exit 0' INT TERM EXIT

    while :; do
        # Atualiza estado
        adm_tui_collect_state >"$state_file" 2>/dev/null || true

        line_count=$(wc -l <"$state_file" 2>/dev/null || echo 0)

        if (( line_count == 0 )); then
            selected_index=0
        elif (( selected_index >= line_count )); then
            selected_index=$((line_count - 1))
        fi

        if (( selected_index < 0 )); then
            selected_index=0
        fi

        adm_tui_draw_screen "$selected_index" "$state_file"

        # Espera tecla com timeout (para refresh periódico)
        key=""
        IFS= read -rsn1 -t "$ADM_TUI_REFRESH_INTERVAL" key || true

        case "$key" in
            q)
                break
                ;;
            k)
                selected_index=$((selected_index - 1))
                if (( selected_index < 0 )); then
                    selected_index=0
                fi
                ;;
            j)
                selected_index=$((selected_index + 1))
                ;;
            A)  # up arrow (seq ESC [ A -> aqui é o 'A' final)
                selected_index=$((selected_index - 1))
                if (( selected_index < 0 )); then
                    selected_index=0
                fi
                ;;
            B)  # down arrow
                selected_index=$((selected_index + 1))
                ;;
            " ")
                adm_tui_toggle_pause
                ;;
            p)
                # Priorizar pacote selecionado
                if (( line_count > 0 )); then
                    local pkg
                    pkg="$(awk -v idx="$((selected_index+1))" 'NR==idx{print $1}' "$state_file" 2>/dev/null || echo "")"
                    if [[ -n "$pkg" ]]; then
                        adm_tui_priority_add "$pkg"
                    fi
                fi
                ;;
            r)
                # refresh manual – já acontece por loop, então nada a fazer.
                ;;
            *)
                # ignora outras teclas
                ;;
        esac
    done

    adm_tui_term_restore
    rm -f "$state_file" 2>/dev/null || true
    trap - INT TERM EXIT
}

# =========
# CLI
# =========

adm_tui_usage() {
    cat <<EOF
adm-tui - Interface TUI para monitorar builds do ADM 2.0

Uso:
  adm-tui          # inicia TUI interativa
  adm-tui --help   # mostra esta ajuda

Controles:
  q           -> sair
  ↑ / k       -> mover seleção para cima
  ↓ / j       -> mover seleção para baixo
  espaço      -> pausar/resumir builds (cria/remove ${ADM_DB_CONTROL_DIR}/build.paused)
  p           -> colocar pacote selecionado no topo da prioridade (${ADM_DB_CONTROL_DIR}/build.priority)
  r           -> refresh manual (o TUI já atualiza periodicamente)

Arquivos usados:
  - Fila lógica de updates:
      ${ADM_DB_UPDATES_PENDING}

  - Controle de pause/resume:
      ${ADM_DB_CONTROL_DIR}/build.paused

  - Prioridade de builds:
      ${ADM_DB_CONTROL_DIR}/build.priority

  - Eventos de build:
      ${ADM_DB_EVENTS_DIR}/events-*.log

  - Logs de build:
      via adm_build_log_file_for_pkg(pkg_id)
EOF
}

adm_tui_main() {
    local cmd="${1:-}"

    case "$cmd" in
        "" )
            adm_tui_main_loop
            ;;
        --help|-h)
            adm_tui_usage
            ;;
        *)
            adm_log_fatal "Comando desconhecido para adm-tui: '$cmd'"
            ;;
    esac
}

if [[ "${BASH_SOURCE[0]:-$0}" == "$0" ]]; then
    adm_tui_main "$@"
fi
