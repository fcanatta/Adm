#!/usr/bin/env bash
# hook-pre-configure para toolchain/binutils-pass1
#
# Executado pelo adm-build ANTES do ./configure.
#
# Ambiente exportado pelo adm_build_run_hook:
#   ADM_PKG_ID
#   ADM_BUILD_DIR_CURRENT
#   ADM_DESTDIR
#   ADM_BUILD_SYSTEM
#
# Este hook adapta o binutils-pass1 ao livro LFS (cross, pass 1),
# mas integrado ao pipeline do ADM:
#
#  - usa um diretório de build separado (build/)
#  - força configure com:
#      --prefix=$LFS/tools (ou /tools se LFS não existir)
#      --with-sysroot=$LFS    (ou / se LFS não existir)
#      --target=$LFS_TGT      (ou x86_64-lfs-linux-gnu)
#      --disable-nls
#      --enable-gprofng=no
#      --disable-werror
#      --enable-new-dtags
#      --enable-default-hash-style=gnu
#
#  - remove qualquer --prefix injetado pelo adm-build.
#
# O restante do fluxo (make, make install DESTDIR=..., empacotar,
# instalar em /, registrar no DB) continua controlado pelo adm-build.

set -o errexit
set -o nounset
set -o pipefail

: "${ADM_PKG_ID:=toolchain/binutils-pass1}"
: "${ADM_BUILD_DIR_CURRENT:?ADM_BUILD_DIR_CURRENT não definido}"
: "${ADM_DESTDIR:?ADM_DESTDIR não definido}"

# =========
# 1. Detecta parâmetros de cross (LFS / defaults)
# =========

# Se o usuário definiu LFS/LFS_TGT como no livro, usamos isso.
# Caso contrário, caímos nos defaults seguros.
if [[ -n "${LFS:-}" ]]; then
    : "${ADM_SYSROOT:=$LFS}"
    : "${ADM_CROSS_PREFIX:=$LFS/tools}"
else
    : "${ADM_SYSROOT:=/}"
    : "${ADM_CROSS_PREFIX:=/tools}"
fi

# Target padrão, se não vier nem de ADM_CROSS_TARGET nem de LFS_TGT
: "${ADM_CROSS_TARGET:=${ADM_CROSS_TARGET:-${LFS_TGT:-x86_64-lfs-linux-gnu}}}"

# =========
# 2. Ajusta PATH para toolchain cross (se já existir)
# =========

CROSS_BIN_DIR="${ADM_CROSS_PREFIX%/}/${ADM_CROSS_TARGET}/bin"
if [[ -d "$CROSS_BIN_DIR" ]]; then
    export PATH="$CROSS_BIN_DIR:$PATH"
fi

# =========
# 3. Envolver ./configure com wrapper que segue o LFS
# =========

cd "$ADM_BUILD_DIR_CURRENT"

if [[ ! -x "./configure" ]]; then
    echo "[hook-pre-configure][$ADM_PKG_ID] ./configure não encontrado em $ADM_BUILD_DIR_CURRENT, nada a fazer." >&2
    exit 0
fi

# Se já rodou antes, não recria
if [[ -x "./configure.orig" ]]; then
    echo "[hook-pre-configure][$ADM_PKG_ID] wrapper de configure já existe, pulando." >&2
    exit 0
fi

mv ./configure ./configure.orig

cat > ./configure << 'EOF'
#!/usr/bin/env bash
# Wrapper gerado pelo hook-pre-configure do ADM para binutils-pass1

set -o errexit
set -o nounset
set -o pipefail

# Parâmetros de cross podem vir do ambiente ou assumir defaults
if [[ -n "${LFS:-}" ]]; then
    : "${ADM_SYSROOT:=$LFS}"
    : "${ADM_CROSS_PREFIX:=$LFS/tools}"
else
    : "${ADM_SYSROOT:=/}"
    : "${ADM_CROSS_PREFIX:=/tools}"
fi

: "${ADM_CROSS_TARGET:=${ADM_CROSS_TARGET:-${LFS_TGT:-x86_64-lfs-linux-gnu}}}"

# Resolve diretório real do script
src="${BASH_SOURCE[0]:-$0}"
while [ -L "$src" ]; do
    target=$(readlink "$src") || break
    if [[ "$target" = /* ]]; then
        src="$target"
    else
        src="$(dirname "$src")/$target"
    fi
done
cd "$(dirname "$src")" >/dev/null 2>&1

# Vamos construir em um subdiretório "build" como no LFS
mkdir -p build
cd build

# Filtra qualquer --prefix=... que o adm-build tenha passado
filtered_args=()
for a in "$@"; do
    case "$a" in
        --prefix=*) ;;
        *) filtered_args+=("$a") ;;
    esac
done

extra_cfg=(
    "--prefix=${ADM_CROSS_PREFIX}"
    "--with-sysroot=${ADM_SYSROOT}"
    "--target=${ADM_CROSS_TARGET}"
    "--disable-nls"
    "--enable-gprofng=no"
    "--disable-werror"
    "--enable-new-dtags"
    "--enable-default-hash-style=gnu"
)

echo "[configure-wrapper][binutils-pass1] target=${ADM_CROSS_TARGET} prefix=${ADM_CROSS_PREFIX} sysroot=${ADM_SYSROOT}" >&2

# ../configure.orig é o configure original do binutils
exec bash ../configure.orig "${filtered_args[@]}" "${extra_cfg[@]}"
EOF

chmod +x ./configure

echo "[hook-pre-configure][$ADM_PKG_ID] Wrapper de configure criado:"
echo "  target=${ADM_CROSS_TARGET}"
echo "  prefix=${ADM_CROSS_PREFIX}"
echo "  sysroot=${ADM_SYSROOT}"
