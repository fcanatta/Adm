#!/usr/bin/env bash
# hook-pre-configure para toolchain/m4 (LFS 6.2 + ADM 2.0)
#
# Executado pelo adm-build ANTES do ./configure.
#
# Ambiente exportado pelo adm_build_run_hook:
#   ADM_PKG_ID
#   ADM_BUILD_DIR_CURRENT  (source_dir da build, ex: .../m4-1.4.20)
#   ADM_DESTDIR            (DESTDIR da build atual)
#   ADM_BUILD_SYSTEM       (autotools, etc)
#
# Objetivo:
#   - Transformar ./configure em um wrapper que:
#       * injeta --host=$LFS_TGT (ou ADM_CROSS_TARGET)
#       * injeta --build=$(build-aux/config.guess)
#       * força --prefix=/usr
#       * remove args duplicados de --prefix/--host/--build
#   - Assim o fluxo fica equivalente ao LFS:
#       ./configure --prefix=/usr --host=$LFS_TGT --build=$(build-aux/config.guess)
#       make
#       make DESTDIR=$LFS install
#     Só que aqui o DESTDIR é o do ADM (ADM_DESTDIR).

set -o errexit
set -o nounset
set -o pipefail

: "${ADM_PKG_ID:=toolchain/m4}"
: "${ADM_BUILD_DIR_CURRENT:?ADM_BUILD_DIR_CURRENT não definido}"
: "${ADM_DESTDIR:?ADM_DESTDIR não definido}"

pkg_id="$ADM_PKG_ID"
build_dir="$ADM_BUILD_DIR_CURRENT"

cd "$build_dir"

if [[ ! -x "./configure" ]]; then
    echo "[hook-pre-configure][$pkg_id] ./configure não encontrado em $build_dir; nada a fazer." >&2
    exit 0
fi

# Se já foi executado antes, não sobrescreve o wrapper.
if [[ -x "./configure.orig" ]]; then
    echo "[hook-pre-configure][$pkg_id] Wrapper de configure já existe; pulando recriação." >&2
    exit 0
fi

mv ./configure ./configure.orig

cat > ./configure << 'EOF'
#!/usr/bin/env bash
# Wrapper gerado pelo hook-pre-configure do ADM para toolchain/m4
set -o errexit
set -o nounset
set -o pipefail

pkg_id="${ADM_PKG_ID:-toolchain/m4}"

# Diretório onde o configure wrapper está sendo chamado
build_dir="$(pwd)"

# === Descobrir HOST (alvo) ===
# Preferência:
#   1) LFS_TGT (ambiente LFS)
#   2) ADM_CROSS_TARGET (toolchain do ADM)
#   3) gcc -dumpmachine (fallback)
host="${LFS_TGT:-${ADM_CROSS_TARGET:-}}"

if [[ -z "$host" ]]; then
    if command -v gcc >/dev/null 2>&1; then
        host="$(gcc -dumpmachine 2>/dev/null || true)"
    fi
fi

if [[ -z "$host" ]]; then
    # Último recurso: tenta usar build-aux/config.guess como host também
    if [[ -x "$build_dir/build-aux/config.guess" ]]; then
        host="$("$build_dir/build-aux/config.guess")"
    else
        printf 'ADM-ERROR[%s]: não consegui determinar HOST (LFS_TGT/ADM_CROSS_TARGET/gcc -dumpmachine).\n' \
            "$pkg_id" >&2
        exit 1
    fi
fi

# === Descobrir BUILD ===
# LFS usa: --build=$(build-aux/config.guess)
if [[ -x "$build_dir/build-aux/config.guess" ]]; then
    build="$("$build_dir/build-aux/config.guess")"
else
    # Fallback razoável
    if command -v gcc >/dev/null 2>&1; then
        build="$(gcc -dumpmachine 2>/dev/null || echo "$host")"
    else
        build="$host"
    fi
fi

# Filtra argumentos que vieram do adm-build:
# Remove:
#   --prefix=*
#   --host=*
#   --build=*
filtered_args=()
for a in "$@"; do
    case "$a" in
        --prefix=*|--host=*|--build=*)
            # ignora esses, vamos forçar os nossos
            ;;
        *)
            filtered_args+=("$a")
            ;;
    esac
done

# Caminho do configure original
real_conf="./configure.orig"

if [[ ! -x "$real_conf" ]]; then
    printf 'ADM-ERROR[%s]: configure.orig não encontrado em %s\n' "$pkg_id" "$build_dir" >&2
    exit 1
fi

# Monta comando final, alinhado com o LFS:
#   ./configure.orig --prefix=/usr --host=$host --build=$build [args filtrados...]
args=(
    "$real_conf"
    "--prefix=/usr"
    "--host=${host}"
    "--build=${build}"
)

if [[ ${#filtered_args[@]} -gt 0 ]]; then
    args+=("${filtered_args[@]}")
fi

printf 'ADM-INFO[%s]: chamando configure real: %s\n' "$pkg_id" "${args[*]}" >&2
exec "${args[@]}"
EOF

chmod +x ./configure

echo "[hook-pre-configure][$pkg_id] Wrapper ./configure criado para M4 (cross LFS/ADM 2.0)." >&2
