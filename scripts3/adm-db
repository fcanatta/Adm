#!/usr/bin/env bash
# adm-db — banco leve de pacotes para ADM (versão inteligente, pretty output, spinner, highlights)
# Local: /usr/src/adm/db (índices, manifests, packages.db, deps/, rdeps/)
#
# Features:
#  - add/remove/list/query/list-deps/list-dependents/has-command
#  - pretty output (--pretty) with active line highlighted in PINK/BOLD
#  - spinner for long operations; clean, non-intrusive
#  - atomic writes, lockdir, backups
#  - dry-run support and --force handling
#  - robust error checking and no silent failures
#
set -euo pipefail
IFS=$'\n\t'

COMMON="$(dirname "$0")/adm-common.sh"
if [ ! -f "${COMMON}" ]; then
  echo "[ERR] adm-common.sh não encontrado em ${COMMON}" >&2
  exit 1
fi
# shellcheck disable=SC1090
. "${COMMON}"

# ---------- Config ----------
DB_DIR="${ADM_DB:-/usr/src/adm/db}"                   # default location
PACKAGES_INDEX="${DB_DIR}/packages.db"   # textual index: name|version|archive|manifest|timestamp
DEPS_DIR="${DB_DIR}/deps"            # deps/<name>-<version>.deps  (two lines: build then run)
RDEPS_DIR="${DB_DIR}/rdeps"          # rdeps/<dep-key>.rdeps -> dependents one per line
MANIFESTS_DIR="${DB_DIR}/manifests"  # central copy of manifests
LOCK_DIR="${DB_DIR}/.lock"           # simple lockdir for concurrency
TMPDIR="${ADM_TEMP:-/tmp}/adm-db-$$"
BACKUP_DIR="${DB_DIR}/backup_$(date +%s)"
SPINNER_PID=""

# color variables fallback (if adm-common didn't set)
: "${T_BOLD:=$(tput bold 2>/dev/null || printf '')}"
: "${T_RESET:=$(tput sgr0 2>/dev/null || printf '')}"
: "${T_MAGENTA:=$(tput setaf 5 2>/dev/null || printf '')}"
: "${T_GREEN:=$(tput setaf 2 2>/dev/null || printf '')}"
: "${T_YELLOW:=$(tput setaf 3 2>/dev/null || printf '')}"
: "${T_RED:=$(tput setaf 1 2>/dev/null || printf '')}"
: "${T_CYAN:=$(tput setaf 6 2>/dev/null || printf '')}"

mkdir -p "${DB_DIR}" "${DEPS_DIR}" "${RDEPS_DIR}" "${MANIFESTS_DIR}" "${TMPDIR}"

# ---------- Utilities ----------
lock_acquire() {
  local tries=0
  while ! mkdir "${LOCK_DIR}" 2>/dev/null; do
    tries=$((tries+1))
    sleep 0.05
    if [ "${tries}" -gt 200 ]; then
      adm_log ERR "Não foi possível adquirir lock do DB após várias tentativas."
      return 1
    fi
  done
  return 0
}
lock_release() {
  rm -rf "${LOCK_DIR}" 2>/dev/null || true
}

# spinner: start_spinner "<message>" ; stop_spinner
start_spinner() {
  local msg="$1"
  # spinner draws on same line; runs in background
  local spin='|/-\'
  printf "%s " "${msg}"
  (
    i=0
    while :; do
      printf "%b" "${spin:i%4:1}"
      printf "\b"
      i=$((i+1))
      sleep 0.08
    done
  ) &
  SPINNER_PID=$!
  disown "${SPINNER_PID}" 2>/dev/null || true
}
stop_spinner() {
  if [ -n "${SPINNER_PID}" ] && kill -0 "${SPINNER_PID}" 2>/dev/null; then
    kill "${SPINNER_PID}" 2>/dev/null || true
    wait "${SPINNER_PID}" 2>/dev/null || true
    SPINNER_PID=""
    printf " "
  fi
}

# print a pretty table with active line highlight (pink/bold)
# args: header_line, then array of lines; optionally active index (1-based)
print_pretty_table() {
  local header="$1"; shift
  local active="${1:-0}"; shift
  local -a lines=("$@")
  printf "%b%s%b\n" "${T_BOLD}${T_MAGENTA}────────────────────────────────────────────────────────────${T_RESET}" "" ""
  printf "%b %s %b\n" "${T_BOLD}${T_CYAN}" "ADM DB — ${header}" "${T_RESET}"
  printf "%b%s%b\n" "${T_BOLD}${T_MAGENTA}────────────────────────────────────────────────────────────${T_RESET}" "" ""
  local i=1
  for ln in "${lines[@]}"; do
    if [ "${i}" -eq "${active}" ]; then
      # highlight active line in pink bold
      printf " %b%s%b\n" "${T_BOLD}${T_MAGENTA}" "${ln}" "${T_RESET}"
    else
      printf " %s\n" "${ln}"
    fi
    i=$((i+1))
  done
}

# robust json escape using python3 if available
json_escape() {
  local s="$1"
  if command -v python3 >/dev/null 2>&1; then
    python3 - <<PY 2>/dev/null
import json,sys
print(json.dumps(sys.stdin.read()))
PY
    return 0
  fi
  # fallback: minimal escaping
  printf '"%s"' "$(printf "%s" "${s}" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e ':a;N;$!ba;s/\n/\\n/g')"
}

# atomic write helper: writes stdin to dest atomically
atomic_write_from_stdin() {
  local dest="$1"
  local tmp="${TMPDIR}/tmp.$(basename "${dest}").$$.$(date +%s)"
  cat > "${tmp}"
  mv -f "${tmp}" "${dest}"
}

timestamp_now() { date --iso-8601=seconds 2>/dev/null || date '+%Y-%m-%dT%H:%M:%S%z'; }

# append line to packages index (safe)
append_packages_index_line() {
  local line="$1"
  if [ "${ADM_DRYRUN:-1}" -eq 1 ]; then
    adm_log INFO "[dry-run] append to ${PACKAGES_INDEX}: ${line}"
    return 0
  fi
  mkdir -p "$(dirname "${PACKAGES_INDEX}")"
  printf '%s\n' "${line}" >> "${PACKAGES_INDEX}"
}

# read packages index lines into array (preserve ordering)
read_all_index_lines() {
  local -a arr=()
  if [ -f "${PACKAGES_INDEX}" ]; then
    while IFS= read -r l; do arr+=("${l}"); done < "${PACKAGES_INDEX}"
  fi
  printf '%s\n' "${arr[@]:-}"
}

# find package entries (lines) matching name and optional version
find_package_entries() {
  local name="$1"
  local version="${2:-}"
  if [ ! -f "${PACKAGES_INDEX}" ]; then return 0; fi
  if [ -z "${version}" ]; then
    grep -E "^${name}\\|" "${PACKAGES_INDEX}" 2>/dev/null || true
  else
    grep -E "^${name}\\|${version}\\|" "${PACKAGES_INDEX}" 2>/dev/null || true
  fi
}

# parse a packages.db line into variables (name|version|archive|manifest|ts)
parse_packages_line_vars() {
  local line="$1"
  IFS='|' read -r p_name p_ver p_archive p_manifest p_ts <<< "${line}"
  printf '%s\0%s\0%s\0%s\0%s' "${p_name}" "${p_ver}" "${p_archive}" "${p_manifest}" "${p_ts}"
}

# read deps from metafile if exists
read_deps_from_metafile() {
  local mf="$1"
  if [ ! -f "${mf}" ]; then
    printf '\n\n'
    return 0
  fi
  local bdeps rdeps
  bdeps="$(read_metafile_val "${mf}" "BUILD_DEPS" 2>/dev/null || echo "")"
  rdeps="$(read_metafile_val "${mf}" "RUN_DEPS" 2>/dev/null || echo "")"
  bdeps="$(printf "%s" "${bdeps}" | tr ',' ' ' | tr '\n' ' ' | awk '{$1=$1;print}')"
  rdeps="$(printf "%s" "${rdeps}" | tr ',' ' ' | tr '\n' ' ' | awk '{$1=$1;print}')"
  printf '%s\n%s' "${bdeps}" "${rdeps}"
}

# store deps to file: deps/<name>-<version>.deps (two lines: build then run)
store_deps_file() {
  local name="$1" ver="$2" bdeps="$3" rdeps="$4"
  local file="${DEPS_DIR}/${name}-${ver}.deps"
  if [ "${ADM_DRYRUN:-1}" -eq 1 ]; then
    adm_log INFO "[dry-run] write deps file ${file}: build='${bdeps}' run='${rdeps}'"
    return 0
  fi
  mkdir -p "${DEPS_DIR}"
  printf '%s\n%s\n' "${bdeps}" "${rdeps}" > "${file}.tmp" && mv -f "${file}.tmp" "${file}"
}

# update reverse deps for a package: adds this pkg to each dep's rdeps file
update_reverse_deps_for() {
  local name="$1" ver="$2" bdeps="$3" rdeps="$4"
  local pkgid="${name}-${ver}"
  for d in ${bdeps} ${rdeps}; do
    [ -z "${d}" ] && continue
    key="$(printf "%s" "${d}" | sed 's#/#__#g')"
    local rfile="${RDEPS_DIR}/${key}.rdeps"
    if [ "${ADM_DRYRUN:-1}" -eq 1 ]; then
      adm_log INFO "[dry-run] add reverse dep ${pkgid} -> ${rfile}"
      continue
    fi
    mkdir -p "${RDEPS_DIR}"
    grep -Fxq "${pkgid}" "${rfile}" 2>/dev/null || echo "${pkgid}" >> "${rfile}"
  done
}

# remove reverse-dep entries for a package (when removed)
remove_reverse_deps_for() {
  local name="$1" ver="$2"
  local pkgid="${name}-${ver}"
  if [ "${ADM_DRYRUN:-1}" -eq 1 ]; then
    adm_log INFO "[dry-run] would remove reverse-dep entries for ${pkgid} in ${RDEPS_DIR}"
    return 0
  fi
  for f in "${RDEPS_DIR}"/*.rdeps; do
    [ -f "${f}" ] || continue
    grep -Fvx "${pkgid}" "${f}" > "${f}.tmp" && mv -f "${f}.tmp" "${f}"
  done
}

# find reverse dependents for a dependency name (category/name or simple)
find_reverse_dependents_of() {
  local dep="$1"
  local key
  key="$(printf "%s" "${dep}" | sed 's#/#__#g')"
  local rfile="${RDEPS_DIR}/${key}.rdeps"
  if [ -f "${rfile}" ]; then
    cat "${rfile}"
    return 0
  fi
  # fallback: search for dep fragment inside all rdeps files
  if [ -d "${RDEPS_DIR}" ]; then
    grep -R --line-number --no-messages --exclude-dir=".git" -n "${dep}" "${RDEPS_DIR}" 2>/dev/null || true
  fi
  return 0
}
# ----- continuação PARTE 2/2 -----
# ---------- CLI ----------
CMD="${1:-}"; shift || true
FORMAT="short"
PRETTY=0
DRYRUN_FLAG=0
FORCE_FLAG=0

# parse common flags usage helper
parse_extra_flags() {
  local args=("$@")
  for ((i=0;i<${#args[@]};i++)); do
    case "${args[i]}" in
      --format) FORMAT="${args[i+1]:-short}"; i=$((i+1)) ;;
      --pretty) PRETTY=1 ;;
      --dry-run) DRYRUN_FLAG=1 ;;
      --no-dry-run) DRYRUN_FLAG=0 ;;
      --force) FORCE_FLAG=1 ;;
      *) ;;
    esac
  done
}

usage() {
  cat <<EOF
adm-db <command> [args...]
Commands:
  add <name> <version> <archive-or-src> <manifest> [--dry-run]
  remove <name> [<version>] [--force] [--dry-run]
  list [--format short|long|json] [--pretty]
  query <name> [<version>]
  list-deps <name> [<version>]
  list-dependents <name> [<version>]
  has-command <cmd>
EOF
  exit 1
}

if [ -z "${CMD}" ]; then usage; fi

case "${CMD}" in
  has-command)
    sub="${1:-}"; shift || true
    case "${sub}" in
      add|remove|list|query|list-deps|list-dependents|has-command) exit 0 ;;
      *) exit 1 ;;
    esac
    ;;

  add)
    name="${1:-}"; version="${2:-}"; archive="${3:-}"; manifest="${4:-}"; shift 4 || true
    parse_extra_flags "$@"
    # dry-run respects either ADM_DRYRUN or provided flag
    if [ "${DRYRUN_FLAG}" -eq 1 ]; then ADM_DRYRUN=1; fi

    if [ -z "${name}" ] || [ -z "${version}" ] || [ -z "${archive}" ] || [ -z "${manifest}" ]; then
      adm_log ERR "Usage: adm-db add <name> <version> <archive-or-src> <manifest> [--dry-run]"
      exit 1
    fi

    if [ ! -f "${manifest}" ]; then adm_log ERR "Manifest não encontrado: ${manifest}"; exit 1; fi

    lock_acquire || { adm_log ERR "Falha ao adquirir lock"; exit 1; }
    trap 'lock_release; exit 1' INT TERM

    # perform operation with spinner and highlight
    start_spinner "Registrando pacote ${name}-${version} ..."
    ts="$(timestamp_now)"
    line="${name}|${version}|${archive}|${manifest}|${ts}"
    mf_dest="${MANIFESTS_DIR}/${name}-${version}.manifest"
    if [ "${ADM_DRYRUN:-1}" -eq 1 ]; then
      adm_log INFO "[dry-run] copiar ${manifest} -> ${mf_dest}"
      stop_spinner
      adm_log OK "Pacote (dry-run) registrado: ${name}-${version}"
      lock_release
      exit 0
    fi

    # real add
    if ! cp -a "${manifest}" "${mf_dest}"; then
      stop_spinner
      adm_log ERR "Falha ao copiar manifest para ${mf_dest}"
      lock_release
      exit 1
    fi

    append_packages_index_line "${line}"

    # attempt to find metafile for deps; if none, read manifest for hints (best-effort)
    mf_found="$(find_metafile_for "${name}" 2>/dev/null || true)"
    if [ -n "${mf_found}" ]; then
      read -r bdeps rdeps < <(read_deps_from_metafile "${mf_found}")
    else
      # try to parse manifest file for common dependency hints (naive)
      bdeps="$(grep -Eo 'BUILD_DEPS=[^ ]+' "${manifest}" 2>/dev/null | sed 's/BUILD_DEPS=//' | tr -d '"')"
      rdeps="$(grep -Eo 'RUN_DEPS=[^ ]+' "${manifest}" 2>/dev/null | sed 's/RUN_DEPS=//' | tr -d '"')"
    fi

    store_deps_file "${name}" "${version}" "${bdeps}" "${rdeps}"
    update_reverse_deps_for "${name}" "${version}" "${bdeps}" "${rdeps}"

    stop_spinner
    adm_log OK "Pacote registrado: ${name}-${version}"
    lock_release
    ;;

  remove)
    name="${1:-}"; version="${2:-}"; shift 2 || true
    # parse any flags after
    parse_extra_flags "$@"
    if [ "${DRYRUN_FLAG}" -eq 1 ]; then ADM_DRYRUN=1; fi
    if [ -z "${name}" ]; then adm_log ERR "Usage: adm-db remove <name> [<version>] [--force] [--dry-run]"; exit 1; fi

    lock_acquire || { adm_log ERR "Falha ao adquirir lock"; exit 1; }
    trap 'lock_release; exit 1' INT TERM

    # find matching entries
    matches="$(find_package_entries "${name}" "${version}")"
    if [ -z "${matches}" ]; then
      adm_log WARN "Nenhuma entrada encontrada para ${name} ${version}"
      lock_release
      exit 1
    fi

    # iterate matches
    i=0
    while IFS= read -r line; do
      [ -z "${line}" ] && continue
      i=$((i+1))
      IFS='|' read -r p_name p_ver p_archive p_manifest p_ts <<< "${line}"

      # print active line highlighted (pink/bold)
      print_pretty_table "Removendo pacotes" "${i}" "${p_name}-${p_ver}"

      # check dependents via RDEPS
      deps_list="$(find_reverse_dependents_of "${p_name}" | sed '/^$/d' || true)"
      if [ -n "${deps_list}" ]; then
        adm_log WARN "Dependentes detectados para ${p_name}-${p_ver}:"
        adm_log WARN "$(printf '%s\n' "${deps_list}")"
        if [ "${FORCE_FLAG}" -ne 1 ]; then
          adm_log ERR "Use --force para remover mesmo com dependentes."
          lock_release
          exit 2
        else
          adm_log WARN "--force fornecido, removendo apesar dos dependentes."
        fi
      fi

      # remove line atomically from PACKAGES_INDEX
      start_spinner "Removendo ${p_name}-${p_ver} ..."
      if [ "${ADM_DRYRUN:-1}" -eq 1 ]; then
        stop_spinner
        adm_log INFO "[dry-run] remover linha do index: ${line}"
        adm_log OK "Remoção (dry-run) concluída para ${p_name}-${p_ver}"
        continue
      fi

      # create backup of packages index
      if [ -f "${PACKAGES_INDEX}" ]; then
        cp -a "${PACKAGES_INDEX}" "${PACKAGES_INDEX}.bak.$(date +%s)" || adm_log WARN "Falha ao criar backup do index"
      fi

      grep -Fvx "${line}" "${PACKAGES_INDEX}" > "${PACKAGES_INDEX}.tmp" && mv -f "${PACKAGES_INDEX}.tmp" "${PACKAGES_INDEX}" || {
        stop_spinner
        adm_log ERR "Falha ao atualizar packages index"
        lock_release
        exit 1
      }

      # remove deps file and reverse deps entries
      depfile="${DEPS_DIR}/${p_name}-${p_ver}.deps"
      if [ -f "${depfile}" ]; then rm -f "${depfile}" || adm_log WARN "Falha removendo deps file ${depfile}"; fi
      remove_reverse_deps_for "${p_name}" "${p_ver}"

      # remove manifest copy
      mfcopy="${MANIFESTS_DIR}/${p_name}-${p_ver}.manifest"
      if [ -f "${mfcopy}" ]; then rm -f "${mfcopy}" || adm_log WARN "Falha removendo manifest copy ${mfcopy}"; fi

      stop_spinner
      adm_log OK "Pacote removido do índice: ${p_name}-${p_ver}"
    done < <(printf '%s\n' "${matches}")

    lock_release
    ;;

  list)
    # flags: --format, --pretty
    parse_extra_flags "$@"
    # if pretty requested, build lines and call print_pretty_table
    if [ "${PRETTY}" -eq 1 ]; then
      if [ ! -f "${PACKAGES_INDEX}" ]; then
        adm_log INFO "Nenhum pacote registrado."
        exit 0
      fi
      lines=()
      while IFS= read -r l; do
        [ -z "${l}" ] && continue
        IFS='|' read -r n v a m t <<< "${l}"
        lines+=("${n}-${v}    ${a}")
      done < "${PACKAGES_INDEX}"
      print_pretty_table "Pacotes registrados" 0 "${lines[@]}"
      exit 0
    fi

    # non-pretty formats
    case "${FORMAT}" in
      short)
        if [ ! -f "${PACKAGES_INDEX}" ]; then adm_log INFO "Nenhum pacote registrado."; exit 0; fi
        awk -F'|' '{printf "%s-%s\n",$1,$2}' "${PACKAGES_INDEX}"
        ;;
      long)
        cat "${PACKAGES_INDEX}"
        ;;
      json)
        if [ ! -f "${PACKAGES_INDEX}" ]; then echo "[]"; exit 0; fi
        echo '['
        first=1
        while IFS= read -r line; do
          [ -z "${line}" ] && continue
          IFS='|' read -r n v a m t <<< "${line}"
          if [ "${first}" -eq 0 ]; then echo ','; fi
          first=0
          printf '  {"name":%s,"version":%s,"archive":%s,"manifest":%s,"timestamp":%s}' "$(json_escape "${n}")" "$(json_escape "${v}")" "$(json_escape "${a}")" "$(json_escape "${m}")" "$(json_escape "${t}")"
        done < "${PACKAGES_INDEX}"
        echo
        echo ']'
        ;;
      *)
        adm_log ERR "Formato desconhecido: ${FORMAT}"; exit 1 ;;
    esac
    ;;

  query)
    name="${1:-}"; version="${2:-}"
    if [ -z "${name}" ]; then adm_log ERR "Usage: adm-db query <name> [<version>]"; exit 1; fi
    matches="$(find_package_entries "${name}" "${version}")"
    if [ -z "${matches}" ]; then adm_log INFO "Nenhuma entrada encontrada para ${name} ${version}"; exit 0; fi
    while IFS= read -r line; do
      [ -z "${line}" ] && continue
      IFS='|' read -r n v a m t <<< "${line}"
      depsfile="${DEPS_DIR}/${n}-${v}.deps"
      build_deps=""; run_deps=""
      if [ -f "${depsfile}" ]; then
        build_deps="$(sed -n '1p' "${depsfile}")"
        run_deps="$(sed -n '2p' "${depsfile}")"
      fi
      cat <<JSON
{
  "name": $(json_escape "${n}"),
  "version": $(json_escape "${v}"),
  "archive": $(json_escape "${a}"),
  "manifest": $(json_escape "${m}"),
  "timestamp": $(json_escape "${t}"),
  "build_deps": $(json_escape "${build_deps}"),
  "run_deps": $(json_escape "${run_deps}")
}
JSON
    done < <(printf '%s\n' "${matches}")
    ;;

  list-deps)
    name="${1:-}"; version="${2:-}"
    if [ -z "${name}" ]; then adm_log ERR "Usage: adm-db list-deps <name> [<version>]"; exit 1; fi
    # check deps file
    if [ -n "${version}" ] && [ -f "${DEPS_DIR}/${name}-${version}.deps" ]; then
      sed -n '1p' "${DEPS_DIR}/${name}-${version}.deps"
      sed -n '2p' "${DEPS_DIR}/${name}-${version}.deps"
      exit 0
    fi
    entry="$(find_package_entries "${name}" "${version}" | tail -n1 || true)"
    if [ -n "${entry}" ]; then
      IFS='|' read -r n v a m t <<< "${entry}"
      if [ -f "${DEPS_DIR}/${n}-${v}.deps" ]; then
        sed -n '1p' "${DEPS_DIR}/${n}-${v}.deps"; sed -n '2p' "${DEPS_DIR}/${n}-${v}.deps"
        exit 0
      fi
    fi
    mf="$(find_metafile_for "${name}" 2>/dev/null || true)"
    if [ -n "${mf}" ]; then
      read -r b r < <(read_deps_from_metafile "${mf}")
      printf '%s\n%s\n' "${b}" "${r}"
      exit 0
    fi
    adm_log INFO "Nenhuma dependência registrada para ${name} ${version}"
    ;;

  list-dependents)
    name="${1:-}"; version="${2:-}"
    if [ -z "${name}" ]; then adm_log ERR "Usage: adm-db list-dependents <name> [<version>]"; exit 1; fi
    key="$(printf "%s" "${name}" | sed 's#/#__#g')"
    rfile="${RDEPS_DIR}/${key}.rdeps"
    if [ -f "${rfile}" ]; then
      cat "${rfile}"
      exit 0
    fi
    # fallback: search in rdeps files for occurrences
    found=0
    for f in "${RDEPS_DIR}"/*.rdeps; do
      [ -f "${f}" ] || continue
      if grep -Fxq "${name}-${version:-}" "${f}" 2>/dev/null; then
        found=1
        grep -Fx "${name}-${version:-}" "${f}" || true
      fi
      if grep -q "${name}" "${f}" 2>/dev/null; then
        found=1
        grep -F "${name}" "${f}" || true
      fi
    done
    if [ "${found}" -eq 1 ]; then exit 0; fi
    # last resort: scan packages index deps files
    if [ -f "${PACKAGES_INDEX}" ]; then
      while IFS= read -r line; do
        [ -z "${line}" ] && continue
        IFS='|' read -r n v a m t <<< "${line}"
        if [ -f "${DEPS_DIR}/${n}-${v}.deps" ]; then
          if grep -E "(^| )${name}($| )" "${DEPS_DIR}/${n}-${v}.deps" >/dev/null 2>&1; then
            echo "${n}-${v}"
          fi
        fi
      done < "${PACKAGES_INDEX}"
    fi
    ;;

  *)
    adm_log ERR "Comando desconhecido: ${CMD}"
    usage
    ;;
esac

exit 0
