#!/usr/bin/env bash
#
# adm-hooks - executor seguro de hooks para adm (bootstrap, build, install, etc.)
#
# Funcionalidades:
#  - Executa hooks em /usr/src/adm/metafiles/<cat>/<pkg>/hooks/<stage>*
#  - Suporte a hooks globais em /usr/src/adm/hooks/global/<stage>*
#  - Execução local, em chroot e (com confirmação) no sistema root (/)
#  - Timeout por hook (default 120s) com fallback se `timeout` não existir
#  - Logs em /usr/src/adm/logs/adm-hooks-<stage>-<pkg>-TIMESTAMP.log
#  - Registro em /usr/src/adm/db/hooks.jsonl (JSON por linha, sem dependências externas)
#  - Flags: --dry-run, --force, --timeout, --chroot, --root, --bootstrap, --system, --verbose, --quiet
#
# Segurança / Avisos:
#  - Hooks são scripts executáveis que podem executar qualquer comando. Revise-os antes.
#  - Chroot/mount/umount operations modify kernel mounts; use com cuidado.
#  - Executar com --root / e --system permite alterações no sistema real — potencialmente destrutivo.
#
set -euo pipefail

### Configurações padrão ###
ADM_ROOT="${ADM_ROOT:-/usr/src/adm}"
ADM_LOG="${ADM_ROOT}/logs"
ADM_DB="${ADM_ROOT}/db"
ADM_WORK="${ADM_ROOT}/work"
GLOBAL_HOOKS="${ADM_ROOT}/hooks/global"

DEFAULT_TIMEOUT=120

DRY_RUN=false
FORCE=false
VERBOSE=false
QUIET=false
TIMEOUT="$DEFAULT_TIMEOUT"
CHROOT_PATH=""
ROOT_PATH=""
BOOTSTRAP_MODE=false
SYSTEM_MODE=false

# Criar diretórios essenciais (seguros, dentro de ADM_ROOT)
mkdir -p "$ADM_LOG" "$ADM_DB" "$ADM_WORK"

# Color helpers
_noc="$(tput sgr0 2>/dev/null || true)"
_red="$(tput setaf 1 2>/dev/null || echo '')"
_grn="$(tput setaf 2 2>/dev/null || echo '')"
_yel="$(tput setaf 3 2>/dev/null || echo '')"
_blu="$(tput setaf 4 2>/dev/null || echo '')"

cecho() {
  local color="$1"; shift
  if $QUIET; then return 0; fi
  printf "%b%s%b\n" "$color" "$*" "$_noc"
}
info()  { cecho "$_blu" "[INFO] $*"; }
ok()    { cecho "$_grn" "✔️  $*"; }
warn()  { cecho "$_yel" "⚠️  $*"; }
error() { cecho "$_red" "✖️  $*"; }

timestamp() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }
ts_short()  { date +"%Y%m%d%H%M%S"; }

logfile_for() {
  local prefix="$1"
  echo "${ADM_LOG}/adm-hooks-${prefix}-$(ts_short).log"
}

# Write JSON line safely (minimal escaping for common characters)
json_escape() {
  # escape backslash and double quotes and control chars
  local s="$1"
  s="${s//\\/\\\\}"
  s="${s//\"/\\\"}"
  # remove carriage returns
  s="${s//$'\r'/}"
  printf "%s" "$s"
}

db_record() {
  # writes a JSON line to ADM_DB/hooks.jsonl
  # args: associative array in parameters (we'll build string)
  local jsonline="$1"
  if $DRY_RUN; then
    info "DRY-RUN: would append to ${ADM_DB}/hooks.jsonl : $jsonline"
    return 0
  fi
  printf "%s\n" "$jsonline" >> "${ADM_DB}/hooks.jsonl"
}

usage() {
  cat <<EOF
adm-hooks - executor de hooks (pre/post stages), com chroot/bootstrap/system support

Uso:
  adm-hooks [opções] <metadir|global> <stage>

Exemplos:
  adm-hooks /usr/src/adm/metafiles/net/wget pre-build
  adm-hooks global pre-bootstrap --chroot /usr/src/adm/stage1/rootfs
  adm-hooks /usr/src/adm/metafiles/core/bash pre-install --system --root /

Opções:
  -n, --dry-run           Mostrar ações sem executar
  -f, --force             Continuar mesmo se hook falhar (útil em automação)
  -t, --timeout N         Timeout por hook em segundos (default $DEFAULT_TIMEOUT)
  --chroot <path>         Executar hooks dentro de chroot (monta /proc,/sys,/dev via bind)
  --root <path>           Define root target (usado para runs que querem aplicar em outro root)
  --bootstrap             Modo bootstrap (executa pre/post-bootstrap)
  --system                Permite execução no sistema real '/' (requer --root / e confirmação, perigoso)
  -v, --verbose           Verbose (mostra saída dos hooks em tempo real)
  -q, --quiet             Silencia saída colorida (ainda grava logs)
  -h, --help              Mostrar esta ajuda
EOF
}

# Argument parsing
POSITIONAL=()
while [ $# -gt 0 ]; do
  case "$1" in
    -n|--dry-run) DRY_RUN=true; shift;;
    -f|--force) FORCE=true; shift;;
    -t|--timeout) TIMEOUT="$2"; shift 2;;
    --chroot) CHROOT_PATH="$2"; shift 2;;
    --root) ROOT_PATH="$2"; shift 2;;
    --bootstrap) BOOTSTRAP_MODE=true; shift;;
    --system) SYSTEM_MODE=true; shift;;
    -v|--verbose) VERBOSE=true; shift;;
    -q|--quiet) QUIET=true; shift;;
    -h|--help) usage; exit 0;;
    --) shift; break;;
    -*) error "Unknown option: $1"; usage; exit 1;;
    *) POSITIONAL+=("$1"); shift;;
  esac
done
set -- "${POSITIONAL[@]:-}"

if [ ${#POSITIONAL[@]} -lt 2 ]; then
  error "Faltam argumentos. Deve informar <metadir|global> e <stage>."
  usage
  exit 1
fi

TARGET="$1"   # metadir or 'global'
STAGE="$2"    # e.g., pre-build
shift 2

# Validate stage reasonable characters (alphanumeric, dash, underscore)
if ! [[ "$STAGE" =~ ^[a-zA-Z0-9_-]+$ ]]; then
  error "Nome de stage inválido: $STAGE"
  exit 1
fi

# Safety: if ROOT_PATH is '/', require SYSTEM_MODE explicit
if [ -n "$ROOT_PATH" ] && [ "$ROOT_PATH" = "/" ] && ! $SYSTEM_MODE; then
  error "ROOT_PATH is '/' but --system not provided. To run hooks directly on the system root, pass --system explicitly."
  exit 1
fi

# If user requests system mode on /, require confirmation unless FORCE
if $SYSTEM_MODE && [ -z "$ROOT_PATH" ]; then
  warn "--system requisitado mas nenhum --root fornecido; assumindo --root /"
  ROOT_PATH="/"
fi

if $SYSTEM_MODE && [ "$ROOT_PATH" = "/" ] && ! $FORCE; then
  # interactive confirmation
  cat <<-PROMPT
AVISO: você está prestes a executar hooks no sistema real (/).
Isso pode alterar /etc, /bin, /usr e outros arquivos críticos.
Se você tem certeza, rode novamente com --force para confirmar sem prompt.
PROMPT
  read -r -p "Continuar e executar hooks em / ? (Type 'YES' to continue): " CONFIRM
  if [ "$CONFIRM" != "YES" ]; then
    error "Confirmação não fornecida. Abortando."
    exit 1
  fi
fi

# Validate CHROOT_PATH exists when provided
if [ -n "$CHROOT_PATH" ] && [ ! -d "$CHROOT_PATH" ]; then
  error "Chroot path não encontrado: $CHROOT_PATH"
  exit 1
fi

# Resolve metadir or global
METADIR=""
IS_GLOBAL=false
if [ "$TARGET" = "global" ]; then
  IS_GLOBAL=true
  METADIR="$GLOBAL_HOOKS"
else
  METADIR="$TARGET"
fi

if [ ! -d "$METADIR" ]; then
  # If global dir missing and target is global, it's OK (nothing to do)
  if $IS_GLOBAL; then
    warn "Global hooks dir não encontrado: $METADIR (nada a fazer)"
    exit 0
  fi
  error "Metadir não encontrado ou inacessível: $METADIR"
  exit 1
fi

# Discover package details for log/db naming
# For metadir like /usr/src/adm/metafiles/<cat>/<pkg>/ we'd like to extract category/name
PACKAGE_CATEGORY=""
PACKAGE_NAME=""
if ! $IS_GLOBAL; then
  # Try to parse category and name from path under ADM_ROOT/metafiles
  rel="${METADIR#${ADM_ROOT}/metafiles/}"
  if [ "$rel" != "$METADIR" ]; then
    PACKAGE_CATEGORY="$(printf "%s" "$rel" | cut -d'/' -f1 || true)"
    PACKAGE_NAME="$(printf "%s" "$rel" | cut -d'/' -f2 || true)"
  else
    # fallback to dir names
    PACKAGE_NAME="$(basename "$METADIR")"
    PACKAGE_CATEGORY="$(basename "$(dirname "$METADIR")")"
  fi
fi

LOGFILE="$(logfile_for "${STAGE}-${PACKAGE_NAME:-global}")"
info "Log: $LOGFILE"
info "Stage: $STAGE"
info "Target meta dir: $METADIR"
if [ -n "$CHROOT_PATH" ]; then info "Chroot requested: $CHROOT_PATH"; fi
if [ -n "$ROOT_PATH" ]; then info "Root target: $ROOT_PATH"; fi
if $DRY_RUN; then info "DRY-RUN is enabled; no hooks will be executed."; fi

# Allowed stages (common)
declare -a ALLOWED_STAGES=(
  pre-download post-download
  pre-patch post-patch
  pre-build post-build
  pre-install post-install
  pre-uninstall post-uninstall
  pre-update post-update
  pre-bootstrap post-bootstrap
  pre-stage1 post-stage1 pre-stage2 post-stage2
)

stage_allowed() {
  local s="$1"
  for a in "${ALLOWED_STAGES[@]}"; do
    if [ "$a" = "$s" ]; then return 0; fi
  done
  return 1
}
if ! stage_allowed "$STAGE"; then
  warn "Stage '$STAGE' não é um stage padrão. Execução será permitida (custom stages suportados), mas confirme se deseja isso."
fi

# Helper: safe mount/umount operations (for chroot)
mounted() {
  grep -E " $1 " /proc/mounts >/dev/null 2>&1
}

safe_mount_bind() {
  # safe_mount_bind <source> <target>
  local src="$1"; local tgt="$2"
  if mounted "$tgt"; then
    info "Already mounted: $tgt"
    return 0
  fi
  if $DRY_RUN; then
    info "DRY-RUN: mount --bind $src -> $tgt"
    return 0
  fi
  mkdir -p "$tgt"
  mount --bind "$src" "$tgt"
}

safe_umount() {
  local tgt="$1"
  if ! mounted "$tgt"; then
    info "Not mounted (skip umount): $tgt"
    return 0
  fi
  if $DRY_RUN; then
    info "DRY-RUN: umount $tgt"
    return 0
  fi
  umount -l "$tgt" || umount "$tgt" || true
}

# Clean-up handler to unmount things on exit
declare -a _MOUNTS_TO_UMOUNT=()
register_umount() {
  _MOUNTS_TO_UMOUNT+=("$1")
}
cleanup_and_exit() {
  local rc=$1
  # attempt unmounts in reverse order
  for ((i=${#_MOUNTS_TO_UMOUNT[@]}-1; i>=0; i--)); do
    safe_umount "${_MOUNTS_TO_UMOUNT[i]}" || true
  done
  if [ $rc -ne 0 ]; then
    error "adm-hooks exiting with code $rc. Veja o log: $LOGFILE"
  fi
  exit $rc
}
trap 'cleanup_and_exit $? ' EXIT

# Remove dangerous env vars
unset LD_PRELOAD LD_LIBRARY_PATH LD_AUDIT LD_ASSUME_KERNEL IFS
export LANG=C LC_ALL=C
# PATH restricted; hooks may rely on coreutils in /bin /usr/bin
export PATH="/usr/bin:/bin:/usr/sbin:/sbin"

# Find hook files for stage
# We support: <metadir>/hooks/<stage> (single) OR files like <metadir>/hooks/<stage>-* or just any executable under hooks/ matching stage in name
HOOK_DIR="${METADIR}/hooks"
if [ ! -d "$HOOK_DIR" ]; then
  info "Nenhum diretório de hooks: $HOOK_DIR (nada a fazer)"
  exit 0
fi

# Determine list of hook scripts to run
# Accept executables that match exactly stage name or begin with stage- or contain stage as prefix
mapfile -t HOOK_CANDIDATES < <(
  find "$HOOK_DIR" -maxdepth 1 -type f -executable \
    \( -name "${STAGE}" -o -name "${STAGE}-*" -o -name "*-${STAGE}" -o -name "*${STAGE}*" \) \
    -print 2>/dev/null | sort
)

# If no hooks matching stage, nothing to do (but also try global hooks)
if [ ${#HOOK_CANDIDATES[@]} -eq 0 ]; then
  info "Nenhum hook específico do pacote encontrado para stage '$STAGE' em $HOOK_DIR"
fi

# Add global hooks (if exist)
if [ -d "$GLOBAL_HOOKS" ]; then
  mapfile -t GLOBAL_CAND < <(find "$GLOBAL_HOOKS" -maxdepth 1 -type f -executable \
    \( -name "${STAGE}" -o -name "${STAGE}-*" -o -name "*${STAGE}*" \) -print 2>/dev/null | sort)
  if [ ${#GLOBAL_CAND[@]} -gt 0 ]; then
    info "Encontradas ${#GLOBAL_CAND[@]} hooks globais para stage $STAGE"
    # prepend global hooks (global should run before package hooks)
    HOOKS=( "${GLOBAL_CAND[@]}" "${HOOK_CANDIDATES[@]}" )
  else
    HOOKS=( "${HOOK_CANDIDATES[@]}" )
  fi
else
  HOOKS=( "${HOOK_CANDIDATES[@]}" )
fi

if [ ${#HOOKS[@]} -eq 0 ]; then
  info "Nenhum hook a executar para stage $STAGE -> saindo."
  exit 0
fi

info "Hooks a executar (ordem determinística):"
for h in "${HOOKS[@]}"; do info " - $h"; done

# Function: run a hook with timeout, capture logs, possibly inside chroot
# args: run_hook <hook_path>
run_hook() {
  local hook="$1"
  local shortname
  shortname="$(basename "$hook")"
  local start_ts end_ts duration rc
  local logf="$LOGFILE"
  local hook_log="${ADM_LOG}/$(basename "$hook")-$(ts_short).log"
  echo "==== adm-hooks execution ====" >> "$logf"
  echo "timestamp: $(timestamp)" >> "$logf"
  echo "hook: $hook" >> "$logf"
  echo "stage: $STAGE" >> "$logf"
  echo "target_meta: $METADIR" >> "$logf"
  echo "chroot: ${CHROOT_PATH:-}" >> "$logf"
  echo "root: ${ROOT_PATH:-}" >> "$logf"
  echo "dry_run: $DRY_RUN" >> "$logf"
  echo "---- hook stdout/stderr below ----" >> "$logf"

  if ! [ -x "$hook" ]; then
    warn "Hook não executável (skip): $hook"
    echo "{\"timestamp\":\"$(timestamp)\",\"hook\":\"$hook\",\"stage\":\"$STAGE\",\"status\":\"not_executable\"}" >> "${ADM_DB}/hooks.jsonl"
    return 0
  fi

  # Build environment variables to pass to hook
  # Keep minimal PATH and sanitized environment (we already set PATH)
  export ADM_STAGE="$STAGE"
  export ADM_META="$METADIR"
  export ADM_LOG="$ADM_LOG"
  export ADM_WORK="$ADM_WORK"
  export ADM_ROOT="$ADM_ROOT"
  export ADM_CHROOT="${CHROOT_PATH:-}"
  export ADM_ROOT_TARGET="${ROOT_PATH:-}"

  # Prepare execution command
  local exec_cmd
  # If chroot requested, we will bind mount hook dir into chroot and run via chroot
  if [ -n "$CHROOT_PATH" ]; then
    # Danger note: mounting and chrooting can have system-wide effects.
    # We will bind-mount the hook file's directory into the chroot at /adm-hooks (readonly)
    local hook_dir
    hook_dir="$(dirname "$hook")"
    local bind_target="${CHROOT_PATH%/}/adm-hooks-$(basename "$METADIR")"
    # create mount point and bind
    info "Bind-mounting hook dir $hook_dir -> $bind_target inside chroot"
    if ! $DRY_RUN; then
      safe_mount_bind "$hook_dir" "$bind_target"
      register_umount "$bind_target"
    fi
    # inside chroot path to run
    local inside_path="/$(dirname "${bind_target#${CHROOT_PATH}}")/$(basename "$hook")"
    # but simpler: run by chrooting and invoking the hook file path as the bind_target plus basename
    # compute inside path relative to chroot: e.g., /adm-hooks-<pkg>/<hook>
    local basehookname
    basehookname="$(basename "$hook")"
    inside_path="/adm-hooks-$(basename "$METADIR")/${basehookname}"
    # ensure path is executable inside chroot - we assume bind mount preserved perms
    exec_cmd=( chroot "$CHROOT_PATH" /bin/bash -lc "export PATH=/usr/bin:/bin; export LANG=C; export ADM_STAGE='$ADM_STAGE' ADM_META='$ADM_META' ADM_WORK='$ADM_WORK' ADM_ROOT='$ADM_ROOT'; '$inside_path'" )
  elif [ -n "$ROOT_PATH" ] && [ "$ROOT_PATH" != "/" ]; then
    # Running hooks targeting other root (not chroot): perform bind mount of hook dir under $ROOT_PATH and run chroot similarly
    local hook_dir
    hook_dir="$(dirname "$hook")"
    local bind_target="${ROOT_PATH%/}/adm-hooks-$(basename "$METADIR")"
    info "Bind-mounting hook dir $hook_dir -> $bind_target (target root run)"
    if ! $DRY_RUN; then
      safe_mount_bind "$hook_dir" "$bind_target"
      register_umount "$bind_target"
    fi
    local basehookname
    basehookname="$(basename "$hook")"
    local inside_path="/adm-hooks-$(basename "$METADIR")/${basehookname}"
    exec_cmd=( chroot "$ROOT_PATH" /bin/bash -lc "export PATH=/usr/bin:/bin; export LANG=C; export ADM_STAGE='$ADM_STAGE' ADM_META='$ADM_META' ADM_WORK='$ADM_WORK' ADM_ROOT='$ADM_ROOT'; '$inside_path'" )
  else
    # Local execution (safe default)
    exec_cmd=( /bin/bash -lc "export PATH=/usr/bin:/bin; export LANG=C; export ADM_STAGE='$ADM_STAGE' ADM_META='$ADM_META' ADM_WORK='$ADM_WORK' ADM_ROOT='$ADM_ROOT'; '$hook'" )
  fi

  # Execute with timeout
  start_ts="$(date +%s.%N)"
  if $DRY_RUN; then
    info "DRY-RUN: would execute: ${exec_cmd[*]}"
    echo "DRY-RUN: ${exec_cmd[*]}" >> "$logf"
    rc=0
    end_ts="$(date +%s.%N)"
    duration="$(awk "BEGIN {print $end_ts - $start_ts}")"
  else
    # Prefer coreutils 'timeout' if available
    if command -v timeout >/dev/null 2>&1; then
      # For verbose: stream stdout/stderr to console as well as to log
      if $VERBOSE; then
        info "Running (verbose) with timeout ${TIMEOUT}s: ${exec_cmd[*]}"
        if timeout --preserve-status "$TIMEOUT" "${exec_cmd[@]}" 2>&1 | tee -a "$logf"; then
          rc=0
        else
          rc=${PIPESTATUS[0]:-1}
        fi
      else
        # Not verbose: capture to log only
        if timeout --preserve-status "$TIMEOUT" "${exec_cmd[@]}" >> "$logf" 2>&1; then
          rc=0
        else
          rc=$?
        fi
      fi
    else
      # Fallback: implement timeout using background killer
      info "timeout command not found; using fallback timer (may be less precise)"
      # start the command in background, capture pid
      if $VERBOSE; then
        "${exec_cmd[@]}" 2>&1 | tee -a "$logf" &
      else
        "${exec_cmd[@]}" >> "$logf" 2>&1 &
      fi
      local cmdpid=$!
      # start watchdog
      (
        sleep "$TIMEOUT"
        if kill -0 "$cmdpid" 2>/dev/null; then
          warn "Hook exceeding timeout ($TIMEOUT s); killing pid $cmdpid"
          kill -TERM "$cmdpid" 2>/dev/null || kill -KILL "$cmdpid" 2>/dev/null || true
        fi
      ) &
      local watchpid=$!
      wait "$cmdpid"
      rc=$?
      # kill watchdog if still running
      kill -9 "$watchpid" 2>/dev/null || true
    fi
    end_ts="$(date +%s.%N)"
    # compute duration
    duration="$(awk "BEGIN {print $end_ts - $start_ts}")"
  fi

  # Record outcome to log and DB
  if [ "$rc" -eq 0 ]; then
    ok "Hook succeeded: $hook (duration: ${duration}s)"
    echo "{\"timestamp\":\"$(timestamp)\",\"hook\":\"$(json_escape "$hook")\",\"stage\":\"$(json_escape "$STAGE")\",\"status\":\"ok\",\"duration\":${duration}}" >> "${ADM_DB}/hooks.jsonl"
  else
    warn "Hook failed: $hook (exit ${rc}) (duration: ${duration}s)"
    echo "{\"timestamp\":\"$(timestamp)\",\"hook\":\"$(json_escape "$hook")\",\"stage\":\"$(json_escape "$STAGE")\",\"status\":\"error\",\"code\":${rc},\"duration\":${duration}}" >> "${ADM_DB}/hooks.jsonl"
    if ! $FORCE; then
      error "Abortando execução de hooks devido ao erro. Use --force para ignorar falhas."
      return $rc
    else
      warn "--force ativo: continuando mesmo com falha."
    fi
  fi

  return 0
}

# Run all hooks sequentially
for h in "${HOOKS[@]}"; do
  if ! run_hook "$h"; then
    # run_hook returns non-zero when error and not forced (handled inside)
    error "Execução abortada por falha no hook: $h"
    exit 3
  fi
done

ok "Todos os hooks para stage '$STAGE' executados (ou ignorados conforme flags)."
exit 0
