#!/usr/bin/env bash
#
# adm-clean v1.1.0-dev
# Limpeza inteligente do ambiente ADM com integraÃ§Ã£o completa:
#   - adm-db (logs/metrics/spinner/progress)
#   - adm-hooks (pre/post hooks)
#   - adm-profile (adaptaÃ§Ã£o de comportamento por perfil)
#   - adm-resolver (checagem de dependÃªncias apÃ³s remoÃ§Ã£o)
#
# Use com --dry-run atÃ© estar seguro.
#
set -euo pipefail
IFS=$'\n\t'

### ------------- Configuration -------------
ADM_ROOT="${ADM_ROOT:-/usr/src/adm}"
ADM_BIN="${ADM_BIN:-${ADM_ROOT}/bin}"
ADM_DB_DIR="${ADM_DB_DIR:-${ADM_ROOT}/db}"
ADM_LOG="${ADM_LOG:-${ADM_ROOT}/logs}"
ADM_CACHE="${ADM_CACHE:-${ADM_ROOT}/cache}"
ADM_WORK="${ADM_WORK:-${ADM_ROOT}/work}"
ADM_BOOTSTRAP="${ADM_BOOTSTRAP:-${ADM_ROOT}/bootstrap}"
ADM_VERSION="v1.1.0-dev"

DB_GLOBAL="${ADM_DB_DIR}/logs.jsonl"
DB_AUDIT="${ADM_DB_DIR}/audit.jsonl"
DB_METRICS="${ADM_DB_DIR}/metrics.jsonl"
DB_QUEUE="${ADM_DB_DIR}/queue.jsonl"
DB_PKGS="${ADM_DB_DIR}/packages.jsonl"

# Defaults
MODE=""
DRY_RUN=false
FORCE=false
DAYS=30
KEEP=5
VERBOSE=false
PROFILE=""
QUIET=false

# Terminal detection
IS_TTY=false
if [ -t 1 ]; then IS_TTY=true; fi

# Colors / formatting
if $IS_TTY; then
  BOLD="$(tput bold 2>/dev/null || echo '')"
  NORM="$(tput sgr0 2>/dev/null || echo '')"
  RED="$(tput setaf 1 2>/dev/null || echo '')"
  GRN="$(tput setaf 2 2>/dev/null || echo '')"
  YEL="$(tput setaf 3 2>/dev/null || echo '')"
  BLU="$(tput setaf 4 2>/dev/null || echo '')"
  MAG="$(tput setaf 5 2>/dev/null || echo '')"
  CYA="$(tput setaf 6 2>/dev/null || echo '')"
else
  BOLD=""; NORM=""; RED=""; GRN=""; YEL=""; BLU=""; MAG=""; CYA=""
fi

ICON_CLEAN="ðŸ§¹"
ICON_OK="âœ”ï¸"
ICON_WARN="âš ï¸"
ICON_ERR="âœ–ï¸"
ICON_INFO="ðŸŒ€"
ICON_PKG="ðŸ“¦"
ICON_QUEUE="ðŸ§©"

# Traps
on_error() {
  local rc=$?
  echo "${RED}[ERROR] adm-clean encountered an error (exit ${rc})${NORM}" >&2
  # Attempt to record in adm-db if available
  if type db_log >/dev/null 2>&1; then
    db_log ERROR "adm-clean" "$MODE" "" "adm-clean aborted with code ${rc}"
    db_log END "adm-clean" "$MODE" "" "aborted"
  fi
  exit $rc
}
trap on_error ERR

on_exit() {
  # any cleanup here
  true
}
trap on_exit EXIT

### ------------- Integration: adm-db, adm-hooks, adm-profile, adm-resolver -------------
# Load adm-db functions if present (for spinner, progress, logging)
if [ -x "${ADM_BIN}/adm-db" ]; then
  # source rather than execute so functions like db_spinner_start are available
  # shellcheck source=/dev/null
  source "${ADM_BIN}/adm-db"
  HAS_ADM_DB=true
else
  HAS_ADM_DB=false
  # fallback: minimal logging functions
  db_log() { local level="$1"; shift; printf "[%s] %s\n" "$level" "$*"; }
  db_info() { db_log INFO "$*"; }
  db_ok() { db_log OK "$*"; }
  db_warn() { db_log WARN "$*"; }
  db_error() { db_log ERROR "$*"; }
  db_begin() { db_log BEGIN "$*"; }
  db_end() { db_log END "$*"; }
  db_spinner_start() { :; }
  db_spinner_stop() { :; }
  db_progress() { :; }
fi

# adm-hooks (optional)
if [ -x "${ADM_BIN}/adm-hooks" ]; then
  ADMH_HOOKS_CMD="${ADM_BIN}/adm-hooks"
else
  ADMH_HOOKS_CMD=""
fi

# adm-profile (optional)
if [ -x "${ADM_BIN}/adm-profile" ]; then
  ADMH_PROFILE_CMD="${ADM_BIN}/adm-profile"
else
  ADMH_PROFILE_CMD=""
fi

# adm-resolver (optional; used for dependency integrity check after orphan removal)
if [ -x "${ADM_BIN}/adm-resolver" ]; then
  ADMH_RESOLVER_CMD="${ADM_BIN}/adm-resolver"
else
  ADMH_RESOLVER_CMD=""
fi

### ------------- Ensure dirs exist (idempotent) -------------
mkdir -p "${ADM_LOG}" "${ADM_DB_DIR}" "${ADM_CACHE}" "${ADM_WORK}" "${ADM_BOOTSTRAP}" "${ADM_BIN}"
# Touch DB files to ensure existence
: > "${DB_GLOBAL}" 2>/dev/null || true
: > "${DB_AUDIT}" 2>/dev/null || true
: > "${DB_METRICS}" 2>/dev/null || true
: > "${DB_QUEUE}" 2>/dev/null || true
: > "${DB_PKGS}" 2>/dev/null || true

### ------------- Helpers -------------
timestamp() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }
now_sec() { date +%s.%N; }
file_age_days() { local f="$1"; [ -e "$f" ] || return 1; printf "%d" $(( ( $(date +%s) - $(stat -c %Y "$f") ) / 86400 )); }

# JSON-escape minimal
json_escape() {
  local s="$1"; s="${s//\\/\\\\}"; s="${s//\"/\\\"}"; s="${s//$'\n'/\\n}"; printf "%s" "$s"
}

# Atomic append using flock on DB directory lock
atomic_append_db() {
  local file="$1"; shift
  local line="$*"
  mkdir -p "$(dirname "$file")"
  exec 9>"${ADM_DB_DIR}/.adm_clean_lock"
  flock -x 9
  printf "%s\n" "$line" >> "$file" || true
  flock -u 9
  exec 9>&-
}

# safe overwrite with backup
safe_overwrite_file() {
  local dest="$1"; local content="$2"
  mkdir -p "$(dirname "$dest")"
  local tmp; tmp="$(mktemp "$(dirname "$dest")/.tmp.XXXXXX")"
  printf "%s\n" "$content" > "$tmp"
  chmod 0644 "$tmp"
  mv "$tmp" "$dest"
}

# safety: ensure path inside ADM_ROOT
inside_adm_root() {
  local p="$1"
  case "$p" in
    "$ADM_ROOT"/*) return 0 ;;
    *) return 1 ;;
  esac
}

# safe remove wrapper (records removed size + path)
safe_rm_record() {
  local target="$1"
  if [ ! -e "$target" ]; then return 0; fi
  if ! inside_adm_root "$target"; then
    db_warn "adm-clean" "$MODE" "" "Refusing to remove outside ADM_ROOT: $target"
    return 1
  fi
  local size=0
  if [ -f "$target" ]; then size=$(stat -c%s "$target" 2>/dev/null || echo 0); fi
  if $DRY_RUN; then
    printf "[DRY-RUN] would remove: %s (size=%s)\n" "$target" "$(human_size "$size")"
    # record dry-run removal in audit file
    atomic_append_db "${DB_AUDIT}" "$(printf '{"timestamp":"%s","script":"adm-clean","mode":"%s","action":"dry_remove","path":"%s","size":%d}' "$(json_escape "$(timestamp)")" "$(json_escape "$MODE")" "$(json_escape "$target")" "$size")"
    return 0
  fi
  # perform removal and record
  if rm -rf --one-file-system "$target" 2>/dev/null; then
    atomic_append_db "${DB_AUDIT}" "$(printf '{"timestamp":"%s","script":"adm-clean","mode":"%s","action":"removed","path":"%s","size":%d}' "$(json_escape "$(timestamp)")" "$(json_escape "$MODE")" "$(json_escape "$target")" "$size")"
    if $VERBOSE || $IS_TTY; then printf "%s Removed: %s (size=%s)\n" "$ICON_OK" "$target" "$(human_size "$size")"; fi
    return 0
  else
    atomic_append_db "${DB_AUDIT}" "$(printf '{"timestamp":"%s","script":"adm-clean","mode":"%s","action":"remove_failed","path":"%s"}' "$(json_escape "$(timestamp)")" "$(json_escape "$MODE")" "$(json_escape "$target")")"
    db_warn "adm-clean" "$MODE" "" "Failed to remove $target"
    return 1
  fi
}

# human_size function
human_size() {
  local bytes="$1"
  if [ -z "$bytes" ] || [ "$bytes" -le 0 ]; then echo "0B"; return; fi
  awk -v b="$bytes" 'function round(x){return int(x+0.5)} \
    BEGIN{ if(b>=1099511627776){printf "%.2f TB", b/1099511627776} \
      else if(b>=1073741824){printf "%.2f GB", b/1073741824} \
      else if(b>=1048576){printf "%.2f MB", b/1048576} \
      else if(b>=1024){printf "%.2f KB", b/1024} \
      else{printf "%d B", b}}'
}

# run adm-hooks if available - safe wrapper
run_hooks() {
  local hook_stage="$1"   # e.g., pre-clean, post-clean, pre-clean-cache
  if [ -n "$ADMH_HOOKS_CMD" ]; then
    if $DRY_RUN; then
      db_info "adm-clean" "$MODE" "" "DRY-RUN: would run hooks: $hook_stage"
      return 0
    fi
    if ! "$ADMH_HOOKS_CMD" "${ADM_ROOT}/metafiles" "$hook_stage" --dry-run >/dev/null 2>&1; then
      # Try without --dry-run; if hook fails and not forced, abort
      if ! "$ADMH_HOOKS_CMD" "${ADM_ROOT}/metafiles" "$hook_stage"; then
        db_warn "adm-clean" "$MODE" "" "hooks $hook_stage failed"
        if ! $FORCE; then
          db_error "adm-clean" "$MODE" "" "Hook $hook_stage failed and --force not set; aborting."
          exit 1
        fi
      fi
    fi
  fi
}

# query active profile via adm-profile (if available)
load_active_profile() {
  PROFILE="unknown"
  if [ -x "${ADM_BIN}/adm-profile" ]; then
    if $DRY_RUN; then
      db_info "adm-clean" "$MODE" "" "DRY-RUN: would query adm-profile current"
    else
      PROFILE="$("${ADM_BIN}/adm-profile" current 2>/dev/null | sed -n 's/^Perfil atual: //p' | head -n1 || true)"
      # fallback: read db/profile.conf
      if [ -z "$PROFILE" ]; then
        if [ -f "${ADM_DB_DIR}/profile.conf" ]; then
          PROFILE="$(grep '^ACTIVE_PROFILE=' "${ADM_DB_DIR}/profile.conf" 2>/dev/null | cut -d= -f2 | tr -d '"')"
        fi
      fi
    fi
  fi
  [ -z "$PROFILE" ] && PROFILE="default"
  db_info "adm-clean" "$MODE" "" "Active profile: ${PROFILE}"
}
### ------------- Cleaning functions ------------- 

# clean_cache: remove tarballs and sources older than $DAYS while respecting $KEEP recent files
clean_cache() {
  MODE="cache"
  db_begin "clean:cache" "${ADM_CACHE}" "adm-clean" "" "" || true
  run_hooks "pre-clean-cache" || true
  load_active_profile

  local removed_count=0 removed_bytes=0
  # handle tarballs
  local tar_dir="${ADM_CACHE}/tarballs"
  mkdir -p "$tar_dir"
  # list files sorted by modification time ascending (oldest first)
  mapfile -t files < <(find "$tar_dir" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | awk '{print $2}')
  local total="${#files[@]}"
  if [ "$total" -le "$KEEP" ]; then
    db_info "adm-clean" "$MODE" "" "No tarballs eligible for removal (keep=${KEEP})."
  else
    # delete oldest, keep last $KEEP
    local to_delete=$(( total - KEEP ))
    local i=0
    for f in "${files[@]}"; do
      i=$((i+1))
      if [ "$i" -le "$to_delete" ]; then
        local sz=0
        if [ -f "$f" ]; then sz=$(stat -c%s "$f" 2>/dev/null || echo 0); fi
        if safe_rm_record "$f"; then
          removed_count=$((removed_count+1))
          removed_bytes=$((removed_bytes+sz))
        fi
      fi
    done
  fi

  # handle sources: delete whole extracted source dirs older than DAYS
  local src_dir="${ADM_CACHE}/sources"
  if [ -d "$src_dir" ]; then
    while IFS= read -r -d '' dir; do
      if is_older_than "$dir" "$DAYS"; then
        local dirsize=$(du -sb "$dir" 2>/dev/null | awk '{print $1}' || echo 0)
        if safe_rm_record "$dir"; then
          removed_count=$((removed_count+1))
          removed_bytes=$((removed_bytes+dirsize))
        fi
      fi
    done < <(find "$src_dir" -mindepth 1 -maxdepth 2 -type d -print0 2>/dev/null)
  fi

  # record metrics
  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"cache_removed_count","value":%d}' "$(json_escape "$(timestamp)")" "$removed_count")"
  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"cache_removed_bytes","value":%d}' "$(json_escape "$(timestamp)")" "$removed_bytes")"
  db_end "clean:cache" ok "adm-clean" "" ""
  db_ok "adm-clean" "cache" "" "${removed_count} files removed, freed $(human_size $removed_bytes)"
  run_hooks "post-clean-cache" || true
}

# clean_logs: compress older logs and remove excessively old ones
clean_logs() {
  MODE="logs"
  db_begin "clean:logs" "${ADM_LOG}" "adm-clean" "" "" || true
  run_hooks "pre-clean-logs" || true

  local gz_count=0 rm_count=0 freed=0
  mkdir -p "${ADM_LOG}"
  # compress logs older than 7 days and keep last $KEEP uncompressed
  mapfile -t logs < <(find "${ADM_LOG}" -maxdepth 1 -type f -name '*.log' -printf '%T@ %p\n' 2>/dev/null | sort -n | awk '{print $2}')
  local total="${#logs[@]}"
  local keep="$KEEP"
  for i in "${!logs[@]}"; do
    idx=$((i+1))
    logfile="${logs[i]}"
    if [ "$idx" -le $((total - keep)) ]; then
      # compress or remove if too old
      if is_older_than "$logfile" "$DAYS"; then
        if $DRY_RUN; then
          printf "[DRY-RUN] would gzip %s\n" "$logfile"
        else
          if gzip -9f "$logfile" 2>/dev/null; then
            gz_count=$((gz_count+1))
            freed=$((freed + $(stat -c%s "${logfile}.gz" 2>/dev/null || echo 0)))
          else
            # if gzip fails, remove
            if rm -f "$logfile"; then
              rm_count=$((rm_count+1))
            fi
          fi
        fi
      fi
    fi
  done

  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"logs_compressed","value":%d}' "$(json_escape "$(timestamp)")" "$gz_count")"
  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"logs_removed","value":%d}' "$(json_escape "$(timestamp)")" "$rm_count")"
  db_end "clean:logs" ok "adm-clean" "" ""
  db_ok "adm-clean" "logs" "" "Compressed: ${gz_count}, removed: ${rm_count}"
  run_hooks "post-clean-logs" || true
}

# clean_work: remove work directories not currently used
clean_work() {
  MODE="work"
  db_begin "clean:work" "${ADM_WORK}" "adm-clean" "" "" || true
  run_hooks "pre-clean-work" || true

  local removed=0 freed=0
  # detect active builds by looking for pid files or running processes referencing ADM_WORK
  if pgrep -f adm-build >/dev/null 2>&1 || pgrep -f build >/dev/null 2>&1; then
    db_warn "adm-clean" "work" "" "Build-related processes detected; skipping work cleanup."
    db_end "clean:work" ok "adm-clean" "" ""
    return 0
  fi

  if [ -d "${ADM_WORK}" ]; then
    while IFS= read -r -d '' dir; do
      # ensure inside ADM_ROOT
      if ! inside_adm_root "$dir"; then continue; fi
      dirsize=$(du -sb "$dir" 2>/dev/null | awk '{print $1}' || echo 0)
      if $DRY_RUN; then
        printf "[DRY-RUN] would remove work dir: %s\n" "$dir"
      else
        if safe_rm_record "$dir"; then
          removed=$((removed+1))
          freed=$((freed+dirsize))
        fi
      fi
    done < <(find "${ADM_WORK}" -mindepth 1 -maxdepth 2 -type d -print0 2>/dev/null)
  fi

  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"work_removed_count","value":%d}' "$(json_escape "$(timestamp)")" "$removed")"
  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"work_removed_bytes","value":%d}' "$(json_escape "$(timestamp)")" "$freed")"
  db_end "clean:work" ok "adm-clean" "" ""
  db_ok "adm-clean" "work" "" "Removed ${removed} dirs, freed $(human_size $freed)"
  run_hooks "post-clean-work" || true
}

# clean_orphans: detect tarballs or cached packages not registered in DB_PKGS
clean_orphans() {
  MODE="orphans"
  db_begin "clean:orphans" "${ADM_CACHE}/tarballs" "adm-clean" "" "" || true
  run_hooks "pre-clean-orphans" || true

  local removed=0 freed=0
  local registered_pkgs
  registered_pkgs="$(awk -F'"' '/"package":/ {print $4}' "${DB_PKGS}" 2>/dev/null | sort -u || true)"

  # iterate tarballs
  local tar_dir="${ADM_CACHE}/tarballs"
  if [ -d "$tar_dir" ]; then
    while IFS= read -r -d '' tar; do
      # get base name (pkg-version.tar.*) extract pkg name (before first -)
      base="$(basename "$tar")"
      pkgname="$(echo "$base" | sed -E 's/^([^.-]+).*/\1/')"
      if ! grep -qx "$pkgname" <<<"$registered_pkgs"; then
        # orphan
        fsize=$(stat -c%s "$tar" 2>/dev/null || echo 0)
        if $DRY_RUN; then
          printf "[DRY-RUN] orphan: %s\n" "$tar"
        else
          if safe_rm_record "$tar"; then
            removed=$((removed+1))
            freed=$((freed+fsize))
            # record orphan removal list separately
            atomic_append_db "${ADM_DB_DIR}/orphans.jsonl" "$(printf '{"timestamp":"%s","action":"removed_orphan","path":"%s","size":%d}' "$(json_escape "$(timestamp)")" "$(json_escape "$tar")" "$fsize")"
          fi
        fi
      fi
    done < <(find "$tar_dir" -type f -print0 2>/dev/null)
  fi

  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"orphans_removed_count","value":%d}' "$(json_escape "$(timestamp)")" "$removed")"
  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"orphans_removed_bytes","value":%d}' "$(json_escape "$(timestamp)")" "$freed")"

  db_end "clean:orphans" ok "adm-clean" "" ""
  db_ok "adm-clean" "orphans" "" "Removed ${removed} orphan files, freed $(human_size $freed)"

  # If we removed anything and adm-resolver exists, trigger integrity check
  if [ -n "${ADMH_RESOLVER_CMD:-}" ] && [ "$removed" -gt 0 ]; then
    if $DRY_RUN; then
      db_info "adm-clean" "orphans" "" "DRY-RUN: would invoke adm-resolver --check-integrity"
    else
      if "${ADMH_RESOLVER_CMD}" --check-integrity >/dev/null 2>&1; then
        db_ok "adm-clean" "orphans" "" "adm-resolver integrity check OK"
      else
        db_warn "adm-clean" "orphans" "" "adm-resolver reported issues"
      fi
    fi
  fi
  run_hooks "post-clean-orphans" || true
}

# clean_db: compact and validate JSONL DBs; backup before write
clean_db() {
  MODE="db"
  db_begin "clean:db" "${ADM_DB_DIR}" "adm-clean" "" "" || true
  run_hooks "pre-clean-db" || true

  local processed=0 reduced_bytes=0
  for f in "${ADM_DB_DIR}"/*.jsonl; do
    [ -f "$f" ] || continue
    cp -a "$f" "${f}.bak" || { db_warn "adm-clean" "db" "" "backup failed for $f"; continue; }
    # remove empty lines and duplicates
    local tmp; tmp="$(mktemp "${ADM_DB_DIR}/.tmp.XXXXXX")"
    awk 'NF' "$f" | sort -u > "$tmp" || { db_warn "adm-clean" "db" "" "compact failed for $f"; rm -f "$tmp"; continue; }
    local oldsz=$(stat -c%s "$f" 2>/dev/null || echo 0)
    local newsz=$(stat -c%s "$tmp" 2>/dev/null || echo 0)
    mv "$tmp" "$f"
    processed=$((processed+1))
    reduced_bytes=$((reduced_bytes + (oldsz - newsz)))
    atomic_append_db "${DB_AUDIT}" "$(printf '{"timestamp":"%s","script":"adm-clean","action":"db_compact","file":"%s","old":%d,"new":%d}' "$(json_escape "$(timestamp)")" "$(json_escape "$f")" "$oldsz" "$newsz")"
  done

  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"db_compacted_files","value":%d}' "$(json_escape "$(timestamp)")" "$processed")"
  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"db_reduced_bytes","value":%d}' "$(json_escape "$(timestamp)")" "$reduced_bytes")"
  db_end "clean:db" ok "adm-clean" "" ""
  db_ok "adm-clean" "db" "" "DB compactado (${processed} arquivos, saved $(human_size "$reduced_bytes"))"
  run_hooks "post-clean-db" || true
}

# clean_bootstrap: removes bootstrap stages; requires --force
clean_bootstrap() {
  MODE="bootstrap"
  if ! $FORCE; then
    db_warn "adm-clean" "bootstrap" "" "--force requerido para limpar bootstrap"
    echo "${YEL}Use --force para confirmar limpeza de bootstrap.${NORM}"
    return 1
  fi
  db_begin "clean:bootstrap" "${ADM_BOOTSTRAP}" "adm-clean" "" "" || true
  run_hooks "pre-clean-bootstrap" || true

  local removed=0 freed=0
  if [ -d "${ADM_BOOTSTRAP}" ]; then
    while IFS= read -r -d '' d; do
      if safe_rm_record "$d"; then
        removed=$((removed+1))
        freed=$((freed + $(du -sb "$d" 2>/dev/null | awk '{print $1}' || echo 0)))
      fi
    done < <(find "${ADM_BOOTSTRAP}" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null)
  fi

  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"bootstrap_removed","value":%d}' "$(json_escape "$(timestamp)")" "$removed")"
  db_end "clean:bootstrap" ok "adm-clean" "" ""
  db_ok "adm-clean" "bootstrap" "" "Bootstrap cleaned: ${removed} dirs, freed $(human_size $freed)"
  run_hooks "post-clean-bootstrap" || true
}

# full_reset: destructive; keeps only adm-db and adm-clean in bin
clean_full_reset() {
  MODE="full-reset"
  if ! $FORCE; then
    db_error "adm-clean" "$MODE" "" "--force obrigatÃ³rio para full-reset"
    echo "${RED}full-reset requer --force. Aborting.${NORM}"
    exit 1
  fi
  echo "${YEL}${BOLD}WARNING: This will DELETE most of ${ADM_ROOT}${NORM}"
  read -rp "Type 'DELETE ALL' to confirm: " conf
  if [ "$conf" != "DELETE ALL" ]; then
    echo "Confirmation failed. Aborting."
    exit 1
  fi

  db_begin "clean:full-reset" "${ADM_ROOT}" "adm-clean" "" "" || true
  run_hooks "pre-clean-full-reset" || true

  # remove everything except bin/adm-db and bin/adm-clean
  for p in "${ADM_ROOT}"/*; do
    case "$(basename "$p")" in
      bin)
        # inside bin, remove everything except adm-db and adm-clean
        for f in "${p}"/*; do
          case "$(basename "$f")" in
            adm-db|adm-clean) continue ;;
            *) safe_rm_record "$f" ;;
          esac
        done
        ;;
      *) safe_rm_record "$p" ;;
    esac
  done

  atomic_append_db "${DB_AUDIT}" "$(printf '{"timestamp":"%s","script":"adm-clean","action":"full_reset","status":"ok"}' "$(json_escape "$(timestamp)")")"
  db_end "clean:full-reset" ok "adm-clean" "" ""
  db_ok "adm-clean" "full-reset" "" "Full reset executed (preserved adm-db and adm-clean)"
  run_hooks "post-clean-full-reset" || true
}

### ------------- Queue and installation-aware helpers -------------
# show queue (uses DB_QUEUE)
queue_show() {
  if [ ! -f "${DB_QUEUE}" ] || [ ! -s "${DB_QUEUE}" ]; then
    echo "Queue empty."
    return
  fi
  echo "â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®"
  echo "â”‚ ${ICON_QUEUE} Queue for installation/builds                â”‚"
  echo "â”œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
  printf "â”‚ %-2s â”‚ %-12s â”‚ %-7s â”‚ %-29s â”‚\n" "#" "Pacote" "VersÃ£o" "DependÃªncias"
  echo "â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
  local i=0
  while IFS= read -r line; do
    i=$((i+1))
    pkg="$(echo "$line" | sed -n 's/.*"package":"\([^"]*\)".*/\1/p')"
    ver="$(echo "$line" | sed -n 's/.*"version":"\([^"]*\)".*/\1/p')"
    deps="$(echo "$line" | sed -n 's/.*"deps":\(\[[^]]*\]\).*/\1/p')"
    deps="$(echo "$deps" | sed 's/\["\([^"]*\)"\]/\1/' | sed 's/","/, /g' )"
    printf "â”‚ %02d â”‚ %-12s â”‚ %-7s â”‚ %-29s â”‚\n" "$i" "$pkg" "$ver" "${deps:--}"
  done < "${DB_QUEUE}"
  echo "â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
}

# register package removal impacts for resolver
notify_resolver_if_needed() {
  if [ -n "${ADMH_RESOLVER_CMD:-}" ]; then
    if $DRY_RUN; then
      db_info "adm-clean" "" "" "DRY-RUN: would notify adm-resolver to re-evaluate deps"
    else
      if "${ADMH_RESOLVER_CMD}" --check-integrity >/dev/null 2>&1; then
        db_ok "adm-clean" "" "" "adm-resolver reports OK"
      else
        db_warn "adm-clean" "" "" "adm-resolver found issues after cleanup"
      fi
    fi
  fi
}

### ------------- Composite operations -------------
clean_all() {
  timer_start=$(now_sec)
  db_begin "clean:all" "${ADM_ROOT}" "adm-clean" "" "" || true
  run_hooks "pre-clean" || true
  clean_cache || true
  clean_logs || true
  clean_work || true
  clean_orphans || true
  clean_db || true
  run_hooks "post-clean" || true
  timer_end=$(now_sec)
  duration="$(awk "BEGIN{printf \"%.2f\", $timer_end - $timer_start}")"
  atomic_append_db "${DB_METRICS}" "$(printf '{"timestamp":"%s","metric":"clean_all_duration_s","value":"%s"}' "$(json_escape "$(timestamp)")" "$duration")"
  db_ok "adm-clean" "all" "" "All cleaning stages finished in ${duration}s"
}

# Print summary and final logs path
print_summary() {
  local total_bytes
  total_bytes=$(du -sb "${ADM_ROOT}" 2>/dev/null | awk '{print $1}' || echo 0)
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  printf "%b %bSummary%b\n" "$ICON_CLEAN" "$BOLD" "$NORM"
  echo "Mode: ${MODE}"
  echo "Profile: ${PROFILE}"
  echo "Dry-run: ${DRY_RUN}"
  echo "ADM root: ${ADM_ROOT}"
  echo "Total size: $(human_size "${total_bytes}")"
  echo "Logs: ${ADM_LOG}"
  echo "DB: ${ADM_DB_DIR}"
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
}

### ------------- Argument parsing and main -------------
show_help() {
  cat <<EOF
adm-clean ${ADM_VERSION}
Usage: adm-clean <mode> [options]
Modes: cache logs work orphans db bootstrap all full-reset
Options:
  --dry-run        Simulate actions
  --force          Force without confirmation
  --days <N>       Older than N days (default ${DAYS})
  --keep <N>       Keep N most recent items (default ${KEEP})
  --verbose
EOF
}

parse_args() {
  if [ $# -lt 1 ]; then show_help; exit 1; fi
  MODE="$1"; shift
  while [ $# -gt 0 ]; do
    case "$1" in
      --dry-run) DRY_RUN=true; shift ;;
      --force) FORCE=true; shift ;;
      --days) DAYS="$2"; shift 2 ;;
      --keep) KEEP="$2"; shift 2 ;;
      --verbose) VERBOSE=true; shift ;;
      --profile) PROFILE="$2"; shift 2 ;;
      -h|--help) show_help; exit 0 ;;
      *) echo "Unknown arg: $1"; show_help; exit 1 ;;
    esac
  done
}

main() {
  parse_args "$@"
  # ensure mode valid
  case "$MODE" in
    cache|logs|work|orphans|db|bootstrap|all|full-reset) ;;
    *) echo "Invalid mode: $MODE"; show_help; exit 1 ;;
  esac

  # announce start
  db_begin "adm-clean:$MODE" "${ADM_ROOT}" "adm-clean" "" ""
  # load profile
  load_active_profile

  # run selected mode
  case "$MODE" in
    cache) clean_cache ;;
    logs) clean_logs ;;
    work) clean_work ;;
    orphans) clean_orphans ;;
    db) clean_db ;;
    bootstrap) clean_bootstrap ;;
    all) clean_all ;;
    full-reset) clean_full_reset ;;
  esac

  print_summary
  db_end "adm-clean:$MODE" ok "adm-clean" "" ""
}

# If script executed (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi

# Export functions for sourcing by other scripts
export -f clean_cache clean_logs clean_work clean_orphans clean_db clean_bootstrap clean_all clean_full_reset queue_show notify_resolver_if_needed
