#!/usr/bin/env bash
#
# adm-patch - aplicar/reverter patches de forma segura e audível para adm
#
# Local: /usr/src/adm/bin/adm-patch
# Requisitos: bash, patch, sha256sum, sed, awk, coreutils. timeout é recomendado.
#
# Principais recursos:
#  - localiza patches em /usr/src/adm/metafiles/<cat>/<pkg>/patch/
#  - valida com `patch --dry-run`
#  - aplica com `patch -p1` (ou nível configurável via --strip)
#  - suporta --dry-run, --force, --revert, --chroot, --root, --timeout
#  - executa hooks pre-patch/post-patch via adm-hooks
#  - grava logs em /usr/src/adm/logs e registros em /usr/src/adm/db/patches.jsonl
#  - protege contra erros silenciosos, limpa mounts em exit
#
set -euo pipefail

### Configuration ###
ADM_ROOT="${ADM_ROOT:-/usr/src/adm}"
ADM_LOG="${ADM_ROOT}/logs"
ADM_DB="${ADM_ROOT}/db"
ADM_CACHE_SRC="${ADM_CACHE_SRC:-${ADM_ROOT}/cache/sources}"
ADM_METAFILES="${ADM_METAFILES:-${ADM_ROOT}/metafiles}"
ADM_WORK="${ADM_WORK:-${ADM_ROOT}/work}"

DEFAULT_TIMEOUT=120
DEFAULT_STRIP=1  # -p1 by default

# Flags
DRY_RUN=false
FORCE=false
REVERT=false
TIMEOUT_SEC="$DEFAULT_TIMEOUT"
CHROOT_PATH=""
ROOT_PATH=""
NO_HOOKS=false
VERBOSE=false
QUIET=false
STRIP_LEVEL="$DEFAULT_STRIP"
SOURCE_DIR_OVERRIDE=""

# Ensure necessary dirs
mkdir -p "$ADM_LOG" "$ADM_DB" "$ADM_WORK"

# Colors
_noc="$(tput sgr0 2>/dev/null || true)"
_red="$(tput setaf 1 2>/dev/null || echo '')"
_grn="$(tput setaf 2 2>/dev/null || echo '')"
_yel="$(tput setaf 3 2>/dev/null || echo '')"
_blu="$(tput setaf 4 2>/dev/null || echo '')"

cecho() {
  local color="$1"; shift
  if $QUIET; then return 0; fi
  printf "%b%s%b\n" "$color" "$*" "$_noc"
}
info()  { cecho "$_blu" "[INFO] $*"; }
ok()    { cecho "$_grn" "✔️  $*"; }
warn()  { cecho "$_yel" "⚠️  $*"; }
error() { cecho "$_red" "✖️  $*"; }

timestamp() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }
ts_short()  { date +"%Y%m%d%H%M%S"; }

logfile_for() { local name="$1"; printf "%s/adm-patch-%s-%s.log" "$ADM_LOG" "$name" "$(ts_short)"; }

# Minimal JSON escape without jq
json_escape() {
  local s="$1"
  s="${s//\\/\\\\}"
  s="${s//\"/\\\"}"
  s="${s//$'\r'/}"
  s="${s//$'\n'/\\n}"
  printf "%s" "$s"
}

db_append() {
  local line="$1"
  if $DRY_RUN; then
    info "DRY-RUN: would append to ${ADM_DB}/patches.jsonl : $line"
    return 0
  fi
  printf "%s\n" "$line" >> "${ADM_DB}/patches.jsonl"
}

usage() {
  cat <<EOF
adm-patch - aplicar/reverter patches controladamente

Uso:
  adm-patch [opções] <metadir|categoria/pacote>

Exemplos:
  adm-patch core/bash
  adm-patch /usr/src/adm/metafiles/core/bash
  adm-patch core/bash --dry-run
  adm-patch core/bash --revert --force
  adm-patch core/bash --chroot /usr/src/adm/stage1/rootfs --timeout 300

Opções:
  -n, --dry-run         Simula sem aplicar (usa patch --dry-run)
  -f, --force           Continua apesar de erros (cuidado)
  -r, --revert          Reverte patches já aplicados (ordem inversa)
  --timeout N           Timeout por patch em segundos (default $DEFAULT_TIMEOUT)
  --chroot <path>       Executa patches dentro do chroot indicado (monta bind /proc /sys /dev)
  --root <path>         Aplica patches dentro do root target sem chroot (assegure path)
  --no-hooks            Não executar pre/post hooks
  --strip N             Nível -pN para patch (default $DEFAULT_STRIP)
  -v, --verbose         Verbose (mostra saída do patch)
  -q, --quiet           Modo silencioso (apenas erros)
  -h, --help            Mostrar ajuda
EOF
}

# parse args
POSITIONAL=()
while [ $# -gt 0 ]; do
  case "$1" in
    -n|--dry-run) DRY_RUN=true; shift;;
    -f|--force) FORCE=true; shift;;
    -r|--revert) REVERT=true; shift;;
    --timeout) TIMEOUT_SEC="$2"; shift 2;;
    --chroot) CHROOT_PATH="$2"; shift 2;;
    --root) ROOT_PATH="$2"; shift 2;;
    --no-hooks) NO_HOOKS=true; shift;;
    --strip) STRIP_LEVEL="$2"; shift 2;;
    -v|--verbose) VERBOSE=true; shift;;
    -q|--quiet) QUIET=true; shift;;
    -h|--help) usage; exit 0;;
    --) shift; break;;
    -*) error "Unknown option: $1"; usage; exit 1;;
    *) POSITIONAL+=("$1"); shift;;
  esac
done
set -- "${POSITIONAL[@]:-}"

if [ ${#POSITIONAL[@]} -lt 1 ]; then
  error "É necessário especificar <metadir|categoria/pacote>"
  usage
  exit 1
fi

TARGET="$1"

# If TARGET looks like category/name, map to metafile dir
METADIR=""
if [[ "$TARGET" == /* ]]; then
  # absolute path
  METADIR="$TARGET"
else
  # try expand under ADM_METAFILES
  if [ -d "${ADM_METAFILES}/${TARGET}" ]; then
    METADIR="${ADM_METAFILES}/${TARGET}"
  else
    # try split by '/'
    if [[ "$TARGET" =~ ^[^/]+/[^/]+$ ]] && [ -d "${ADM_METAFILES}/${TARGET}" ]; then
      METADIR="${ADM_METAFILES}/${TARGET}"
    else
      # try find first metafile containing package name
      cand="$(find "$ADM_METAFILES" -type d -name "$(basename "$TARGET")" -path "*/$(dirname "$TARGET")/*" -print -quit 2>/dev/null || true)"
      if [ -n "$cand" ]; then
        METADIR="$cand"
      elif [ -d "${ADM_METAFILES}/${TARGET}" ]; then
        METADIR="${ADM_METAFILES}/${TARGET}"
      else
        # fallback: try treat TARGET as path if exists
        if [ -d "$TARGET" ]; then
          METADIR="$TARGET"
        else
          error "Metadir não encontrado: $TARGET (procure em ${ADM_METAFILES})"
          exit 1
        fi
      fi
    fi
  fi
fi

if [ ! -d "$METADIR" ]; then
  error "Metadir inválido ou não acessível: $METADIR"
  exit 1
fi

# Extract package info from metafile if exists
METAFILE="$METADIR/metafile"
PKG_NAME="$(basename "$METADIR")"
PKG_CAT="$(basename "$(dirname "$METADIR")")"
PKG_VERSION=""
PKG_BUILD=""
PKG_SOURCE=""
PKG_SHA256=""

# simple safe parser for metafile (key=value)
parse_metafile() {
  local mf="$1"
  if [ ! -f "$mf" ]; then return 0; fi
  # only accept keys we know
  while IFS= read -r line || [ -n "$line" ]; do
    line="${line%%#*}"            # strip comments
    line="${line%"${line##*[![:space:]]}"}"
    line="${line#"${line%%[![:space:]]*}"}"
    [ -z "$line" ] && continue
    if [[ "$line" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$ ]]; then
      key="${BASH_REMATCH[1]}"
      val="${BASH_REMATCH[2]}"
      # remove surrounding quotes if present
      if [[ "$val" =~ ^\".*\"$ ]]; then val="${val#\"}"; val="${val%\"}"; fi
      case "$key" in
        name) PKG_NAME="$val";;
        version) PKG_VERSION="$val";;
        build) PKG_BUILD="$val";;
        source) PKG_SOURCE="$val";;
        sha256sum) PKG_SHA256="$val";;
        *) ;; # ignore others
      esac
    fi
  done < "$mf"
}

parse_metafile "$METAFILE"

# Determine source dir with sources cached by adm-download if not overridden
if [ -n "$SOURCE_DIR_OVERRIDE" ]; then
  SOURCE_DIR="$SOURCE_DIR_OVERRIDE"
else
  # prefer explicit source dir under cache: <ADM_CACHE_SRC>/<category>/<pkg>/<version> if version known
  if [ -n "$PKG_VERSION" ] && [ -d "${ADM_CACHE_SRC}/${PKG_CAT}/${PKG_NAME}/${PKG_VERSION}" ]; then
    SOURCE_DIR="${ADM_CACHE_SRC}/${PKG_CAT}/${PKG_NAME}/${PKG_VERSION}"
  else
    # fallback: try any directory under cache matching name
    cand="$(find "${ADM_CACHE_SRC}" -type d -path "*/${PKG_NAME}/*" -print -quit 2>/dev/null || true)"
    if [ -n "$cand" ]; then
      SOURCE_DIR="$cand"
    else
      # allow user to use --root to indicate location of sources
      SOURCE_DIR=""
    fi
  fi
fi

# If CHROOT_PATH provided, ensure exists
if [ -n "$CHROOT_PATH" ] && [ ! -d "$CHROOT_PATH" ]; then
  error "Chroot path não existe: $CHROOT_PATH"
  exit 1
fi

# If ROOT_PATH provided, ensure exists
if [ -n "$ROOT_PATH" ] && [ ! -d "$ROOT_PATH" ]; then
  error "Root path não existe: $ROOT_PATH"
  exit 1
fi

LOGNAME="${PKG_NAME}-${PKG_VERSION:-snapshot}"
LOGFILE="$(logfile_for "$LOGNAME")"
info "Logfile: $LOGFILE"
info "Metadir: $METADIR"
info "Source dir (detected): ${SOURCE_DIR:-<not-detected>}"
if $DRY_RUN; then info "DRY-RUN enabled (no changes will be written)"; fi
if $REVERT; then info "REVERT mode: patches will be reverted (if applied)"; fi

# Prepare patch dir
PATCH_DIR="${METADIR}/patch"
if [ ! -d "$PATCH_DIR" ]; then
  info "Nenhum diretório de patch encontrado em $PATCH_DIR -> nada a aplicar"
  exit 0
fi

# find patch files
mapfile -t ALL_PATCHES < <(find "$PATCH_DIR" -maxdepth 1 -type f \( -iname "*.patch" -o -iname "*.diff" -o -iname "*.patch.gz" -o -iname "*.diff.gz" \) -print 2>/dev/null | sort -V)
if [ ${#ALL_PATCHES[@]} -eq 0 ]; then
  info "Nenhum patch válido encontrado em $PATCH_DIR"
  exit 0
fi

# If revert: we will process reverse order
if $REVERT; then
  # reverse
  mapfile -t PATCHES < <(printf "%s\n" "${ALL_PATCHES[@]}" | tac)
else
  PATCHES=( "${ALL_PATCHES[@]}" )
fi

# mounting helpers (safe bind mounts)
mounted() {
  grep -E " $1 " /proc/mounts >/dev/null 2>&1
}
safe_mount_bind() {
  local src="$1"; local tgt="$2"
  if mounted "$tgt"; then
    info "Already mounted: $tgt"
    return 0
  fi
  if $DRY_RUN; then
    info "DRY-RUN: mount --bind $src -> $tgt"
    return 0
  fi
  mkdir -p "$tgt"
  mount --bind "$src" "$tgt"
}
safe_umount() {
  local tgt="$1"
  if ! mounted "$tgt"; then
    info "Not mounted: $tgt"
    return 0
  fi
  if $DRY_RUN; then
    info "DRY-RUN: umount $tgt"
    return 0
  fi
  umount -l "$tgt" || umount "$tgt" || true
}

declare -a _TO_UMOUNT=()
register_umount() { _TO_UMOUNT+=("$1"); }

cleanup_and_exit() {
  rc=$1
  # unmount in reverse order
  for ((i=${#_TO_UMOUNT[@]}-1;i>=0;i--)); do
    safe_umount "${_TO_UMOUNT[i]}" || true
  done
  if [ $rc -ne 0 ]; then
    error "adm-patch exiting with code $rc. Ver logs em $LOGFILE"
  fi
  exit $rc
}
trap 'cleanup_and_exit $?' EXIT

# run adm-hooks pre-patch unless disabled
run_hooks_stage() {
  local stage="$1"
  if $NO_HOOKS; then
    info "Hooks desativados (--no-hooks) -> pulando $stage"
    return 0
  fi
  if ! command -v "${ADM_ROOT}/bin/adm-hooks" >/dev/null 2>&1; then
    # try PATH
    if ! command -v adm-hooks >/dev/null 2>&1; then
      warn "adm-hooks não encontrado; pulando execução de hooks ($stage). Instale adm-hooks se quiser hooks."
      return 0
    else
      HOOK_CMD="adm-hooks"
    fi
  else
    HOOK_CMD="${ADM_ROOT}/bin/adm-hooks"
  fi

  # call adm-hooks with chroot/root flags if provided
  local hook_args=()
  [ "$DRY_RUN" = true ] && hook_args+=( --dry-run )
  [ "$FORCE" = true ] && hook_args+=( --force )
  [ "$VERBOSE" = true ] && hook_args+=( --verbose )
  [ "$QUIET" = true ] && hook_args+=( --quiet )
  [ -n "$CHROOT_PATH" ] && hook_args+=( --chroot "$CHROOT_PATH" )
  [ -n "$ROOT_PATH" ] && hook_args+=( --root "$ROOT_PATH" )

  info "Invocando hooks: $HOOK_CMD $METADIR $stage ${hook_args[*]}"
  if $DRY_RUN; then
    info "DRY-RUN: adm-hooks $METADIR $stage ${hook_args[*]}"
    return 0
  fi

  if ! "${HOOK_CMD}" "$METADIR" "$stage" "${hook_args[@]}"; then
    warn "adm-hooks retornou erro para $stage"
    if ! $FORCE; then
      error "pre/post-hook falhou e --force não foi passado -> abortando"
      return 3
    else
      warn "--force ativo: ignorando falha em hooks"
      return 0
    fi
  fi
  return 0
}

# compute sha256 of patch file (supports gz)
compute_patch_sha() {
  local f="$1"
  if [[ "$f" =~ \.gz$ ]]; then
    if command -v zcat >/dev/null 2>&1; then
      zcat "$f" | sha256sum | awk '{print $1}'
    else
      # fallback: gunzip to stdout
      gunzip -c "$f" | sha256sum | awk '{print $1}'
    fi
  else
    sha256sum "$f" | awk '{print $1}'
  fi
}

# validate a patch with patch --dry-run
validate_patch() {
  local patchfile="$1"
  local target_dir="$2"  # directory where patch will be applied
  # Use -pN from STRIP_LEVEL
  local pflag="-p${STRIP_LEVEL}"
  # For gzip patch, pipe through zcat
  info "Validating patch $patchfile in $target_dir with $pflag"
  if $DRY_RUN; then
    info "DRY-RUN: would run validation of $patchfile"
    return 0
  fi
  if [ -n "$CHROOT_PATH" ]; then
    # run inside chroot: bind patch dir and run patch --dry-run inside chroot
    local patchdir
    patchdir="$(dirname "$patchfile")"
    local bind_target="${CHROOT_PATH%/}/adm-patch-bind-$(basename "$patchdir")"
    safe_mount_bind "$patchdir" "$bind_target"
    register_umount "$bind_target"
    local inside_patch="${bind_target#${CHROOT_PATH}}"
    # inside path relative to chroot
    inside_patch="${inside_patch#/}"
    # command
    if [[ "$patchfile" =~ \.gz$ ]]; then
      cmd=( chroot "$CHROOT_PATH" /bin/bash -lc "zcat /${inside_patch}/$(basename "$patchfile") | patch --dry-run ${pflag} -d '${target_dir}'" )
    else
      cmd=( chroot "$CHROOT_PATH" /bin/bash -lc "patch --dry-run ${pflag} -d '${target_dir}' < '/${inside_patch}/$(basename "$patchfile")'" )
    fi
  elif [ -n "$ROOT_PATH" ]; then
    # similar bind into root path
    local patchdir
    patchdir="$(dirname "$patchfile")"
    local bind_target="${ROOT_PATH%/}/adm-patch-bind-$(basename "$patchdir")"
    safe_mount_bind "$patchdir" "$bind_target"
    register_umount "$bind_target"
    local inside_patch="${bind_target#${ROOT_PATH}}"
    inside_patch="${inside_patch#/}"
    if [[ "$patchfile" =~ \.gz$ ]]; then
      cmd=( chroot "$ROOT_PATH" /bin/bash -lc "zcat /${inside_patch}/$(basename "$patchfile") | patch --dry-run ${pflag} -d '${target_dir}'" )
    else
      cmd=( chroot "$ROOT_PATH" /bin/bash -lc "patch --dry-run ${pflag} -d '${target_dir}' < '/${inside_patch}/$(basename "$patchfile")'" )
    fi
  else
    # normal local execution
    if [[ "$patchfile" =~ \.gz$ ]]; then
      if ! command -v zcat >/dev/null 2>&1; then
        error "zcat não disponível para ler patch .gz"
        return 4
      fi
      cmd=( bash -lc "zcat '$patchfile' | patch --dry-run ${pflag} -d '$target_dir'" )
    else
      cmd=( bash -lc "patch --dry-run ${pflag} -d '$target_dir' < '$patchfile'" )
    fi
  fi

  # run with timeout
  if command -v timeout >/dev/null 2>&1; then
    if "${cmd[@]}" >"$LOGFILE" 2>&1; then
      info "Validation OK for $patchfile"
      return 0
    else
      warn "Validation failed for $patchfile (see $LOGFILE)"
      return 4
    fi
  else
    # fallback to run without timeout (less safe)
    if "${cmd[@]}" >"$LOGFILE" 2>&1; then
      info "Validation OK for $patchfile"
      return 0
    else
      warn "Validation failed for $patchfile (see $LOGFILE)"
      return 4
    fi
  fi
}

# apply single patch (or revert)
apply_single_patch() {
  local patchfile="$1"
  local target_dir="$2"
  local action="$3"  # apply or revert
  local pflag="-p${STRIP_LEVEL}"
  local patchname="$(basename "$patchfile")"
  local sha
  sha="$(compute_patch_sha "$patchfile" || true)"
  local start_ts end_ts duration rc

  # log header
  {
    printf "==== adm-patch: %s ====\n" "$patchname"
    printf "timestamp: %s\n" "$(timestamp)"
    printf "action: %s\n" "$action"
    printf "patchfile: %s\n" "$patchfile"
    printf "target_dir: %s\n" "$target_dir"
    printf "strip: %s\n" "$STRIP_LEVEL"
    printf "sha256: %s\n" "$sha"
    printf "dry_run: %s\n" "$DRY_RUN"
    printf "force: %s\n" "$FORCE"
    printf "---- output below ----\n"
  } >> "$LOGFILE"

  if $DRY_RUN; then
    info "DRY-RUN: would ${action} patch $patchname in $target_dir"
    db_append "{\"timestamp\":\"$(timestamp)\",\"category\":\"$(json_escape "$PKG_CAT")\",\"name\":\"$(json_escape "$PKG_NAME")\",\"version\":\"$(json_escape "$PKG_VERSION")\",\"patch\":\"$(json_escape "$patchname")\",\"action\":\"${action}\",\"status\":\"dry-run\",\"sha256\":\"$sha\"}"
    return 0
  fi

  # Build actual command
  if [ -n "$CHROOT_PATH" ]; then
    # bind patch dir
    local pdir
    pdir="$(dirname "$patchfile")"
    local bind_target="${CHROOT_PATH%/}/adm-patch-bind-$(basename "$pdir")"
    safe_mount_bind "$pdir" "$bind_target"
    register_umount "$bind_target"
    local inside_patch="/${bind_target#${CHROOT_PATH}}"
    inside_patch="${inside_patch#/}"   # remove leading slash
    if [[ "$patchfile" =~ \.gz$ ]]; then
      cmd=( chroot "$CHROOT_PATH" /bin/bash -lc "zcat '/${inside_patch}/$(basename "$patchfile")' | patch ${pflag} -d '${target_dir}' $( [ "$action" = "revert" ] && echo "-R" )" )
    else
      cmd=( chroot "$CHROOT_PATH" /bin/bash -lc "patch ${pflag} -d '${target_dir}' $( [ "$action" = "revert" ] && echo "-R" ) < '/${inside_patch}/$(basename "$patchfile")'" )
    fi
  elif [ -n "$ROOT_PATH" ]; then
    local pdir
    pdir="$(dirname "$patchfile")"
    local bind_target="${ROOT_PATH%/}/adm-patch-bind-$(basename "$pdir")"
    safe_mount_bind "$pdir" "$bind_target"
    register_umount "$bind_target"
    local inside_patch="/${bind_target#${ROOT_PATH}}"
    inside_patch="${inside_patch#/}"
    if [[ "$patchfile" =~ \.gz$ ]]; then
      cmd=( chroot "$ROOT_PATH" /bin/bash -lc "zcat '/${inside_patch}/$(basename "$patchfile")' | patch ${pflag} -d '${target_dir}' $( [ "$action" = "revert" ] && echo "-R" )" )
    else
      cmd=( chroot "$ROOT_PATH" /bin/bash -lc "patch ${pflag} -d '${target_dir}' $( [ "$action" = "revert" ] && echo "-R" ) < '/${inside_patch}/$(basename "$patchfile")'" )
    fi
  else
    if [[ "$patchfile" =~ \.gz$ ]]; then
      if ! command -v zcat >/dev/null 2>&1; then
        error "zcat não encontrado para ler patch .gz"
        return 4
      fi
      cmd=( bash -lc "zcat '$patchfile' | patch ${pflag} -d '$target_dir' $( [ "$action" = "revert" ] && echo "-R" )" )
    else
      cmd=( bash -lc "patch ${pflag} -d '$target_dir' $( [ "$action" = "revert" ] && echo "-R" ) < '$patchfile'" )
    fi
  fi

  start_ts="$(date +%s.%N)"
  # run with timeout if available
  if command -v timeout >/dev/null 2>&1; then
    if $VERBOSE; then
      info "Running (verbose) ${cmd[*]}"
      if timeout --preserve-status "$TIMEOUT_SEC" "${cmd[@]}" 2>&1 | tee -a "$LOGFILE"; then rc=0; else rc=${PIPESTATUS[0]:-1}; fi
    else
      if timeout --preserve-status "$TIMEOUT_SEC" "${cmd[@]}" >>"$LOGFILE" 2>&1; then rc=0; else rc=$?; fi
    fi
  else
    # fallback (no timeout exec): run and hope it ends
    if $VERBOSE; then
      info "Running (no timeout available) ${cmd[*]}"
      if "${cmd[@]}" 2>&1 | tee -a "$LOGFILE"; then rc=0; else rc=$?; fi
    else
      if "${cmd[@]}" >>"$LOGFILE" 2>&1; then rc=0; else rc=$?; fi
    fi
  fi
  end_ts="$(date +%s.%N)"
  duration="$(awk "BEGIN{print $end_ts - $start_ts}")"

  # record
  if [ "$rc" -eq 0 ]; then
    ok "Patch ${action}ed: $patchname (duration ${duration}s)"
    db_append "{\"timestamp\":\"$(timestamp)\",\"category\":\"$(json_escape "$PKG_CAT")\",\"name\":\"$(json_escape "$PKG_NAME")\",\"version\":\"$(json_escape "$PKG_VERSION\")\",\"patch\":\"$(json_escape "$patchname")\",\"action\":\"${action}\",\"status\":\"ok\",\"duration\":${duration},\"sha256\":\"${sha}\"}"
    return 0
  else
    warn "Falha ao ${action} patch $patchname (exit $rc). Veja $LOGFILE"
    db_append "{\"timestamp\":\"$(timestamp)\",\"category\":\"$(json_escape "$PKG_CAT")\",\"name\":\"$(json_escape "$PKG_NAME")\",\"version\":\"$(json_escape "$PKG_VERSION")\",\"patch\":\"$(json_escape "$patchname")\",\"action\":\"${action}\",\"status\":\"error\",\"code\":${rc},\"duration\":${duration},\"sha256\":\"${sha}\"}"
    if ! $FORCE; then
      error "Patch falhou e --force não fornecido -> abortando"
      return $rc
    else
      warn "--force ativo: continuando apesar do erro"
      return 0
    fi
  fi
}

# Main flow
# 1) pre-patch hooks
run_hooks_stage "pre-patch" || { error "pre-patch hooks falharam"; if ! $FORCE; exit 3; fi }

# 2) validate patches (unless reverting)
if ! $REVERT; then
  info "Validando ${#PATCHES[@]} patches"
  for p in "${PATCHES[@]}"; do
    if ! validate_patch "$p" "${SOURCE_DIR:-.}"; then
      warn "Validação falhou para patch $p"
      if ! $FORCE; then
        error "Validacao falhou e --force não fornecido -> abort"
        exit 4
      else
        warn "--force ativo: ignorando erro de validação e prosseguindo"
      fi
    fi
  done
else
  info "Modo REVERT: skip validation pass (reversão será tentada)"
fi

# 3) apply/revert each patch
if [ -z "${SOURCE_DIR:-}" ]; then
  warn "Source directory não detectado automaticamente. Você deve passar --root <dir> apontando para código-fonte ou colocar fontes em ${ADM_CACHE_SRC}"
  # proceed but actions may fail
fi

for p in "${PATCHES[@]}"; do
  apply_action="apply"
  if $REVERT; then apply_action="revert"; fi
  # call apply_single_patch with target_dir = SOURCE_DIR or '.' if empty
  target="${SOURCE_DIR:-.}"
  info "Processing patch $(basename "$p") -> action $apply_action on target $target"
  if ! apply_single_patch "$p" "$target" "$apply_action"; then
    error "apply_single_patch falhou para $p"
    exit 4
  fi
done

# 4) post-patch hooks
run_hooks_stage "post-patch" || { error "post-patch hooks falharam"; if ! $FORCE; exit 5; fi }

ok "Todos os patches processados para ${PKG_NAME} (metadir $METADIR)."
exit 0
