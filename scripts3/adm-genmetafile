#!/usr/bin/env bash
# adm-genmetafile — Gerador de metafiles reais para o sistema ADM
# Autor: GPT-5 para o sistema ADM de Fernando
# Versão: 2.0 (formato real funcional do ADM)
#
# Gera metafile em: /usr/src/adm/metafiles/<categoria>/<pacote>/metafile
#
# Detecta: nome, versão, build system, dependências, checksums, URLs múltiplas, etc.
# Cria diretórios de hooks e patches automaticamente.
# Segue a arquitetura do ADM (adm-detect, adm-build, adm-resolver, adm-download).

set -euo pipefail
IFS=$'\n\t'

ADM_METAFILES="/usr/src/adm/metafiles"
TMPDIR="$(mktemp -d /tmp/adm-genmeta.XXXXXX)"
trap 'rm -rf "$TMPDIR"' EXIT

# ==== Funções utilitárias ====
log() { printf "\033[1;36m[adm-genmetafile]\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[WARN]\033[0m %s\n" "$*"; }
err() { printf "\033[1;31m[ERRO]\033[0m %s\n" "$*" >&2; exit 1; }

# Detectar nome e versão a partir de um arquivo tarball
detect_name_version() {
  local file base
  file="$1"
  base="$(basename "$file")"
  base="${base%.tar.xz}"; base="${base%.tar.gz}"; base="${base%.tar.bz2}"; base="${base%.tar.zst}"; base="${base%.zip}"
  if [[ "$base" =~ ^([A-Za-z0-9._+-]+)-([0-9]+(\.[0-9]+)*.*)$ ]]; then
    echo "${BASH_REMATCH[1]} ${BASH_REMATCH[2]}"
  else
    echo "$base unknown"
  fi
}

sha256_of() {
  if command -v sha256sum >/dev/null 2>&1; then
    sha256sum "$1" | awk '{print $1}'
  elif command -v shasum >/dev/null 2>&1; then
    shasum -a 256 "$1" | awk '{print $1}'
  else
    echo ""
  fi
}

detect_build_system() {
  local d="$1"
  if [ -f "$d/configure" ] || [ -f "$d/configure.ac" ]; then
    echo "autotools"
  elif [ -f "$d/CMakeLists.txt" ]; then
    echo "cmake"
  elif [ -f "$d/meson.build" ]; then
    echo "meson"
  elif [ -f "$d/setup.py" ] || [ -f "$d/pyproject.toml" ]; then
    echo "python"
  elif [ -f "$d/Cargo.toml" ]; then
    echo "cargo"
  elif [ -f "$d/package.json" ]; then
    echo "node"
  elif [ -f "$d/Makefile" ]; then
    echo "make"
  else
    echo "manual"
  fi
}

build_deps_for() {
  case "$1" in
    autotools) echo "gcc make autoconf automake libtool m4 texinfo" ;;
    cmake) echo "gcc make cmake" ;;
    meson) echo "gcc meson ninja python3" ;;
    cargo) echo "rustc cargo" ;;
    python) echo "python3 setuptools" ;;
    node) echo "node npm" ;;
    make) echo "gcc make" ;;
    manual) echo "gcc make" ;;
    *) echo "gcc make" ;;
  esac
}

run_deps_for() {
  case "$1" in
    python) echo "python3" ;;
    node) echo "node" ;;
    *) echo "" ;;
  esac
}

# ==== Entrada e parsing ====
SRC="${1:-}"
CATEGORY="${2:-misc}"

[ -z "$SRC" ] && err "Uso: adm-genmetafile <arquivo|diretorio|git> [categoria]"

OUT_BASE="${ADM_METAFILES}/${CATEGORY}"

mkdir -p "$OUT_BASE"

# ==== Determinar tipo de fonte ====
if [[ "$SRC" =~ \.tar.*$ || "$SRC" =~ \.zip$ ]]; then
  TYPE="tarball"
elif [[ "$SRC" =~ \.git$ || "$SRC" =~ ^git@ || "$SRC" =~ ^https?://.*\.git ]]; then
  TYPE="git"
elif [ -d "$SRC" ]; then
  TYPE="dir"
else
  err "Fonte inválida: $SRC"
fi

# ==== Preparar nome e versão ====
NAME=""; VERSION=""

if [ "$TYPE" = "tarball" ]; then
  read -r NAME VERSION < <(detect_name_version "$SRC")
elif [ "$TYPE" = "git" ]; then
  NAME="$(basename "$SRC" .git)"
  VERSION="$(git ls-remote --tags "$SRC" | awk -F/ '{print $NF}' | sort -V | tail -n1)"
  VERSION="${VERSION:-git-latest}"
else
  NAME="$(basename "$SRC")"
  VERSION="dev"
fi

[ -n "$NAME" ] || err "Não foi possível detectar o nome"
[ -n "$VERSION" ] || VERSION="unknown"

WORKDIR="${TMPDIR}/${NAME}-${VERSION}"
mkdir -p "$WORKDIR"

# ==== Detectar build system e deps (opcionalmente extraindo tarball) ====
if [ "$TYPE" = "tarball" ]; then
  tar -tf "$SRC" >/dev/null 2>&1 || err "Arquivo inválido: $SRC"
  tar -xf "$SRC" -C "$TMPDIR"
  subdir="$(find "$TMPDIR" -maxdepth 1 -type d ! -path "$TMPDIR" | head -n1)"
  BUILD_SYSTEM="$(detect_build_system "$subdir")"
elif [ "$TYPE" = "dir" ]; then
  BUILD_SYSTEM="$(detect_build_system "$SRC")"
elif [ "$TYPE" = "git" ]; then
  TMP_GIT="${TMPDIR}/repo"
  git clone --depth 1 "$SRC" "$TMP_GIT" >/dev/null 2>&1 || err "Falha ao clonar repositório git"
  BUILD_SYSTEM="$(detect_build_system "$TMP_GIT")"
else
  BUILD_SYSTEM="manual"
fi

BUILD_DEPS="$(build_deps_for "$BUILD_SYSTEM")"
RUN_DEPS="$(run_deps_for "$BUILD_SYSTEM")"
OPT_DEPS=""

SHA256=""
if [ "$TYPE" = "tarball" ]; then
  SHA256="$(sha256_of "$SRC")"
fi

# ==== Gerar bloco de URLs múltiplas ====
URLS=""
if [ "$TYPE" = "tarball" ]; then
  base="$(basename "$SRC")"
  URLS="
https://ftp.gnu.org/gnu/${NAME}/${base}
ftp://ftp.gnu.org/gnu/${NAME}/${base}
rsync://ftp.gnu.org/gnu/${NAME}/${base}
git://git.savannah.gnu.org/${NAME}.git
sourceforge://${NAME}/${base}
"
elif [ "$TYPE" = "git" ]; then
  URLS="
${SRC}
"
else
  URLS="file://${SRC}"
fi

# ==== Criar diretório final ====
DEST_DIR="${OUT_BASE}/${NAME}"
mkdir -p "${DEST_DIR}/hooks" "${DEST_DIR}/patches"

# ==== Gerar metafile funcional ADM ====
METAFILE="${DEST_DIR}/metafile"

cat > "$METAFILE" <<EOF
# Metafile gerado automaticamente pelo adm-genmetafile (formato funcional ADM)
NAME="${NAME}"
VERSION="${VERSION}"
CATEGORY="${CATEGORY}"
BUILD_SYSTEM="${BUILD_SYSTEM}"

URLS="${URLS}"
SHA256="${SHA256}"

BUILD_DEPS="${BUILD_DEPS}"
RUN_DEPS="${RUN_DEPS}"
OPT_DEPS="${OPT_DEPS}"

# Campos internos de integração ADM
STAGE="0"
PROFILE="system"
HOOKS_AUTO="1"
EOF

log "Metafile criado: ${METAFILE}"
log "Estrutura completa:"
tree -L 2 "${OUT_BASE}/${NAME}" 2>/dev/null || find "${OUT_BASE}/${NAME}" -maxdepth 2

exit 0
