#!/usr/bin/env bash
# adm-build — orquestrador de builds automáticos (parte 1/3)
# Regras: usa adm-common.sh; respeita ADM_DRYRUN/ADM_FORCE/ADM_JOBS; suporta profiles, resume, hooks, destdir, bootstrap/chroot.
set -euo pipefail
IFS=$'\n\t'

SCRIPTS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMMON="${SCRIPTS_DIR}/adm-common.sh"

if [ -f "${COMMON}" ]; then
  # shellcheck disable=SC1090
  . "${COMMON}"
else
  # fallback minimal implementations (non-fatal)
  adm_log() { printf "[%s] %s\n" "${1:-INFO}" "$*" >&2; }
  read_metafile_val() {
    local file="$1"; local key="$2"
    awk -F= -v k="$key" '$0 ~ "^"k"=" {sub(/^[^=]+=/,"",$0); gsub(/^["'\'']|["'\'']$/,"",$0); print $0; exit}' "$file" 2>/dev/null || true
  }
  adm_source_metafile() {
    # source in a subshell and echo env-like output to caller: but for now simply source (best-effort)
    # WARNING: when adm-common missing, sourcing arbitrary file could be unsafe. We assume local control.
    # shellcheck disable=SC1090
    . "$1" || true
  }
fi

# Defaults and paths
: "${ADM_ROOT:=/usr/src/adm}"
: "${ADM_METAFILES:=${ADM_ROOT}/metafiles}"
: "${ADM_PACKAGES:=${ADM_ROOT}/packages}"
: "${ADM_CACHE:=${ADM_ROOT}/cache}"
: "${ADM_DESTDIR:=${ADM_ROOT}/destdir}"
: "${ADM_TEMP:=${ADM_ROOT}/temp}"
: "${ADM_LOG:=${ADM_ROOT}/log}"
: "${ADM_PROFILES:=${ADM_ROOT}/profiles}"

: "${ADM_DRYRUN:=1}"   # por segurança, dry-run por default
: "${ADM_FORCE:=0}"
: "${ADM_JOBS:=$(nproc || echo 1)}"

mkdir -p "${ADM_PACKAGES}" "${ADM_CACHE}" "${ADM_DESTDIR}" "${ADM_TEMP}" "${ADM_LOG}" "${ADM_PROFILES}"

# state file used to resume builds
STATE_DIR="${ADM_TEMP}/adm-build-state"
mkdir -p "${STATE_DIR}"

# spinner (simple)
SPIN_PID=""
start_spinner() {
  [ "${ADM_DRYRUN}" -eq 1 ] && return 0
  local msg="$1"
  printf "%s " "$msg"
  ( local s='|/-\' i=0
    while :; do
      printf "%s" "${s:i%4:1}"
      printf "\b"
      i=$((i+1))
      sleep 0.08
    done ) &
  SPIN_PID=$!
  disown "${SPIN_PID}" 2>/dev/null || true
}
stop_spinner() {
  if [ -n "${SPIN_PID}" ] && kill -0 "${SPIN_PID}" 2>/dev/null; then
    kill "${SPIN_PID}" 2>/dev/null || true
    wait "${SPIN_PID}" 2>/dev/null || true
    SPIN_PID=""
    printf " \n"
  fi
}

safe_exec() {
  local label="$1"; shift
  adm_log INFO "EXEC: ${label}"
  if [ "${ADM_DRYRUN}" -eq 1 ]; then
    adm_log INFO "[dry-run] $*"
    return 0
  fi
  start_spinner "${label}"
  set +e
  "$@"
  local rc=$?
  set -e
  stop_spinner
  if [ "${rc}" -ne 0 ]; then
    adm_log ERR "Comando retornou ${rc}: ${label}"
  else
    adm_log OK "${label}"
  fi
  return "${rc}"
}

# helper: find metafile by id or path
find_metafile() {
  local id="$1"
  if [ -f "$id" ]; then
    printf "%s" "$id"
    return 0
  fi
  # try under ADM_METAFILES
  # allow id like category/name or name
  if [ -f "${ADM_METAFILES}/${id}/metafile" ]; then
    printf "%s" "${ADM_METAFILES}/${id}/metafile"; return 0
  fi
  # if id is simple name, try categories
  if [ -d "${ADM_METAFILES}" ]; then
    local mf
    mf="$(find "${ADM_METAFILES}" -type f -name metafile -exec grep -H "^NAME=.*${id}" {} \; 2>/dev/null | head -n1 || true)"
    if [ -n "$mf" ]; then
      # output path portion before colon when grep prints filename:line
      printf "%s" "${mf%%:*}"; return 0
    fi
  fi
  return 1
}

# load metafile: prefer safe reader
load_metafile() {
  local mf="$1"
  if [ ! -f "${mf}" ]; then
    adm_log WARN "metafile não encontrado: ${mf}"
    return 1
  fi
  # read core vars via read_metafile_val for safety
  NAME="$(read_metafile_val "${mf}" NAME || true)"
  VERSION="$(read_metafile_val "${mf}" VERSION || true)"
  CATEGORY="$(read_metafile_val "${mf}" CATEGORY || true)"
  URLS="$(read_metafile_val "${mf}" URLS || true)"
  FILENAME="$(read_metafile_val "${mf}" FILENAME || true)"
  SHA256="$(read_metafile_val "${mf}" SHA256 || true)"
  BUILD_SYSTEM="$(read_metafile_val "${mf}" BUILD_SYSTEM || true)"
  BUILD_DIR="$(read_metafile_val "${mf}" BUILD_DIR || echo "build")"
  PREFIX="$(read_metafile_val "${mf}" PREFIX || echo "/usr")"
  DESTDIR_META="$(read_metafile_val "${mf}" DESTDIR || echo "${ADM_DESTDIR}/${CATEGORY}/${NAME}-${VERSION}")"
  CONFIGURE_ARGS="$(read_metafile_val "${mf}" CONFIGURE_ARGS || true)"
  MAKE_ARGS="$(read_metafile_val "${mf}" MAKE_ARGS || true)"
  INSTALL_ARGS="$(read_metafile_val "${mf}" INSTALL_ARGS || true)"
  BUILD_DEPS="$(read_metafile_val "${mf}" BUILD_DEPS || true)"
  RUN_DEPS="$(read_metafile_val "${mf}" RUN_DEPS || true)"
  OPT_DEPS="$(read_metafile_val "${mf}" OPT_DEPS || true)"
  # fallback
  : "${NAME:=${1##*/}}"
  : "${VERSION:=}"
  : "${CATEGORY:=misc}"
  : "${DESTDIR:=${DESTDIR_META}}"
  return 0
}

# profile loader: load profile vars from ADM_PROFILES/<profile>
load_profile() {
  local profile="$1"
  PROFILE_CFLAGS="" ; PROFILE_LDFLAGS="" ; PROFILE_ENV=""
  local pfile="${ADM_PROFILES}/${profile}"
  if [ -f "${pfile}" ]; then
    adm_log INFO "Carregando profile: ${profile}"
    # profile file uses KEY=VAL style; safe source in subshell to capture variables
    # we allow CFLAGS, CXXFLAGS, LDFLAGS, MAKEFLAGS etc.
    # shellcheck disable=SC1090
    . "${pfile}"
    PROFILE_CFLAGS="${CFLAGS:-}${PROFILE_CFLAGS:+ }${PROFILE_CFLAGS}"
    PROFILE_CXXFLAGS="${CXXFLAGS:-}${PROFILE_CXXFLAGS:+ }${PROFILE_CXXFLAGS}"
    PROFILE_LDFLAGS="${LDFLAGS:-}${PROFILE_LDFLAGS:+ }${PROFILE_LDFLAGS}"
    PROFILE_ENV="${PROFILE_ENV:-}"
  else
    adm_log INFO "Profile não existe: ${profile} (usando defaults)"
  fi
}

# prepare source: use adm-download if available, else try local path or cache
prepare_source() {
  local srcref="$1"  # could be metafile path or URL or package name or tarball
  local outdir="$2"  # where to extract: e.g. ${ADM_TEMP}/build-<name>
  mkdir -p "${outdir}"
  if [ -f "$srcref" ]; then
    # tarball or dir
    if [ -d "$srcref" ]; then
      adm_log INFO "Fonte é diretório local: ${srcref}"
      cp -a "${srcref}/." "${outdir}/" || true
      printf "%s" "${outdir}"
      return 0
    fi
    # tarball: extract
    adm_log INFO "Extraindo tarball ${srcref} para ${outdir}"
    if [ "${ADM_DRYRUN}" -eq 1 ]; then
      adm_log INFO "[dry-run] extrair ${srcref} -> ${outdir}"
      printf "%s" "${outdir}"; return 0
    fi
    case "${srcref}" in
      *.tar.xz) tar -xJf "${srcref}" -C "${outdir}" ;; 
      *.tar.gz) tar -xzf "${srcref}" -C "${outdir}" ;; 
      *.tar.bz2) tar -xjf "${srcref}" -C "${outdir}" ;; 
      *.tar.zst) ( _has unzstd || _has zstd ) && ( ( _has unzstd && unzstd -c "${srcref}" | tar -xf - -C "${outdir}" ) || ( _has zstd && zstd -d -c "${srcref}" | tar -xf - -C "${outdir}" ) ) || err_exit "zstd/unzstd necessário";;
      *.zip) unzip -q "${srcref}" -d "${outdir}" ;; 
      *) tar -xf "${srcref}" -C "${outdir}" ;; 
    esac
    # if extraction created a single top-level dir, return that path
    local top
    top="$(find "${outdir}" -mindepth 1 -maxdepth 1 -type d | head -n1 || true)"
    if [ -n "${top}" ]; then
      printf "%s" "${top}"; return 0
    fi
    printf "%s" "${outdir}"; return 0
  fi

  # if adm-download exists and a metafile was given, use it
  if command -v adm-download >/dev/null 2>&1; then
    adm_log INFO "Usando adm-download para obter fonte de ${srcref}"
    # adm-download may accept metafile path or package id; we call it and expect it leave tarball in cache
    if [ "${ADM_DRYRUN}" -eq 1 ]; then
      adm_log INFO "[dry-run] adm-download ${srcref}"
      printf "%s" "${outdir}"; return 0
    fi
    if adm-download "${srcref}"; then
      # find downloaded filename in cache by NAME/VERSION or FILENAME
      # strategy: look for files in ADM_CACHE matching NAME or FILENAME
      local candidate
      if [ -n "${FILENAME}" ]; then
        candidate="$(find "${ADM_CACHE}" -type f -name "${FILENAME}" -print -quit 2>/dev/null || true)"
      fi
      if [ -z "${candidate}" ]; then
        candidate="$(find "${ADM_CACHE}" -type f -iname "*${NAME}*${VERSION}*" -print -quit 2>/dev/null || true)"
      fi
      if [ -n "${candidate}" ]; then
        prepare_source "${candidate}" "${outdir}"
        return $?
      else
        adm_log ERR "Arquivo de fonte não encontrado no cache após adm-download"
        return 1
      fi
    else
      adm_log ERR "adm-download falhou para ${srcref}"
      return 1
    fi
  fi

  adm_log ERR "Não sei como obter a fonte: ${srcref}"
  return 1
}

# resume helpers
state_file_for() {
  local name="$1"; local ver="$2"
  printf "%s/%s-%s.state" "${STATE_DIR}" "${name}" "${ver}"
}
save_state() {
  local sf="$1"; shift
  printf "%s\n" "$@" > "${sf}.tmp"
  mv -f "${sf}.tmp" "${sf}"
}
load_state() {
  local sf="$1"
  [ -f "${sf}" ] && cat "${sf}"
}

# end of part 
# adm-build — parte 2/3
set -euo pipefail
IFS=$'\n\t'

# helper: minimal _has
_has() { command -v "$1" >/dev/null 2>&1; }

# apply patches automatically (patch files in metafile dir)
apply_patches_auto() {
  local metafile_dir="$1"
  if [ ! -d "${metafile_dir}" ]; then
    adm_log INFO "No patch dir for ${metafile_dir}"
    return 0
  fi
  # find *.patch files, apply in alphanumeric order
  local p
  for p in $(find "${metafile_dir}" -maxdepth 1 -type f -name "*.patch" | sort); do
    adm_log INFO "Aplicando patch: $(basename "${p}")"
    if [ "${ADM_DRYRUN}" -eq 1 ]; then
      adm_log INFO "[dry-run] patch -p1 < ${p}"
      continue
    fi
    (cd "${WORKDIR}" && patch -Np1 < "${p}") || { adm_log ERR "Falha aplicando patch ${p}"; return 1; }
  done
  return 0
}

# run hooks automatically: stage e.g. pre-build, post-build, pre-install, post-install
run_hooks_auto() {
  local metafile_dir="$1"
  local stage="$2"  # e.g. pre-build
  local script
  # hooks may be executable files in metafile_dir/hooks or named at top-level
  for script in "${metafile_dir}/hooks/${stage}" "${metafile_dir}/${stage}"; do
    [ -x "${script}" ] || continue
    adm_log INFO "Executando hook ${stage}: ${script}"
    if [ "${ADM_DRYRUN}" -eq 1 ]; then
      adm_log INFO "[dry-run] ${script}"
      continue
    fi
    if ! "${script}" "${WORKDIR}" "${DESTDIR}"; then
      adm_log ERR "Hook ${script} retornou erro"
      return 1
    fi
  done
  return 0
}

# detect build system from WORKDIR (if BUILD_SYSTEM empty)
auto_detect_build_system() {
  if [ -n "${BUILD_SYSTEM}" ]; then
    adm_log INFO "BUILD_SYSTEM já definido: ${BUILD_SYSTEM}"
    return 0
  fi
  local bs="unknown"
  [ -f "${WORKDIR}/configure" ] && bs="autotools"
  [ -f "${WORKDIR}/autogen.sh" ] && bs="autotools"
  [ -f "${WORKDIR}/CMakeLists.txt" ] && bs="cmake"
  [ -f "${WORKDIR}/meson.build" ] && bs="meson"
  [ -f "${WORKDIR}/Cargo.toml" ] && bs="cargo"
  [ -f "${WORKDIR}/setup.py" ] && bs="python"
  [ -f "${WORKDIR}/Makefile" ] && [ "${bs}" = "unknown" ] && bs="make"
  BUILD_SYSTEM="${bs}"
  adm_log INFO "Detectado build system: ${BUILD_SYSTEM}"
}

# chroot helpers (simple wrappers around adm-chroot if available)
in_chroot_run() {
  local chroot_path="$1"
  shift
  if [ -x "${SCRIPTS_DIR}/adm-chroot" ]; then
    "${SCRIPTS_DIR}/adm-chroot" exec "${chroot_path}" -- "$@"
    return $?
  fi
  adm_log WARN "adm-chroot não disponível, executando no host"
  "$@"
}

# builders for different systems
build_autotools() {
  adm_log INFO "Builder: autotools"
  mkdir -p "${WORKDIR}/${BUILD_DIR}"
  cd "${WORKDIR}/${BUILD_DIR}" || return 1
  local cfg_cmd="../configure --prefix=${PREFIX} ${CONFIGURE_ARGS:-}"
  adm_log INFO "Configurar: ${cfg_cmd}"
  safe_exec "configure" sh -c "${cfg_cmd}" || return 1
  safe_exec "make" sh -c "make ${MAKE_ARGS:-} -j${ADM_JOBS}" || return 1
  # install to DESTDIR
  safe_exec "make install" sh -c "make ${INSTALL_ARGS:-} DESTDIR='${DESTDIR}'" || return 1
  return 0
}

build_cmake() {
  adm_log INFO "Builder: cmake"
  mkdir -p "${WORKDIR}/${BUILD_DIR}"
  cd "${WORKDIR}/${BUILD_DIR}" || return 1
  local cfg_cmd="cmake .. -DCMAKE_INSTALL_PREFIX=${PREFIX} ${CONFIGURE_ARGS:-}"
  safe_exec "cmake configure" sh -c "${cfg_cmd}" || return 1
  safe_exec "make" sh -c "make ${MAKE_ARGS:-} -j${ADM_JOBS}" || return 1
  safe_exec "make install" sh -c "make ${INSTALL_ARGS:-} DESTDIR='${DESTDIR}'" || return 1
  return 0
}

build_meson() {
  adm_log INFO "Builder: meson"
  mkdir -p "${WORKDIR}/${BUILD_DIR}"
  cd "${WORKDIR}" || return 1
  safe_exec "meson setup" sh -c "meson setup ${BUILD_DIR} --prefix=${PREFIX} ${CONFIGURE_ARGS:-}" || return 1
  cd "${WORKDIR}/${BUILD_DIR}" || return 1
  safe_exec "ninja" sh -c "ninja -j${ADM_JOBS}" || return 1
  safe_exec "ninja install" sh -c "DESTDIR='${DESTDIR}' ninja install" || return 1
  return 0
}

build_cargo() {
  adm_log INFO "Builder: cargo"
  cd "${WORKDIR}" || return 1
  safe_exec "cargo build" sh -c "cargo build --release ${CONFIGURE_ARGS:-}"
  # cargo install into DESTDIR is custom: copy target/release binaries
  local bindir="${DESTDIR}${PREFIX}/bin"
  mkdir -p "${bindir}"
  find target/release -maxdepth 1 -type f -executable -print0 | xargs -0 -I{} cp -a {} "${bindir}/" || true
  return 0
}

build_python() {
  adm_log INFO "Builder: python/setup.py"
  cd "${WORKDIR}" || return 1
  safe_exec "python build" sh -c "python3 setup.py build ${CONFIGURE_ARGS:-}"
  safe_exec "python install" sh -c "python3 setup.py install --root='${DESTDIR}' ${INSTALL_ARGS:-}"
  return 0
}

build_make_simple() {
  adm_log INFO "Builder: make (simple)"
  cd "${WORKDIR}" || return 1
  safe_exec "make" sh -c "make ${MAKE_ARGS:-} -j${ADM_JOBS}"
  safe_exec "make install" sh -c "make ${INSTALL_ARGS:-} DESTDIR='${DESTDIR}'"
  return 0
}

# dispatcher to builder
run_builder() {
  case "${BUILD_SYSTEM}" in
    autotools) build_autotools ;;
    cmake) build_cmake ;;
    meson) build_meson ;;
    cargo) build_cargo ;;
    python) build_python ;;
    make) build_make_simple ;;
    *) adm_log ERR "Build system desconhecido: ${BUILD_SYSTEM}"; return 1 ;;
  esac
}

# packaging: pack DESTDIR/<prefix> into tar.zst or tar.xz (store in ADM_PACKAGES)
package_result() {
  local name="$1"; local ver="$2"
  local outname="${name}-${ver}.tar"
  local packdir="${ADM_PACKAGES}"
  mkdir -p "${packdir}"
  local tmpdir="${ADM_TEMP}/pkg-${name}-${ver}"
  rm -rf "${tmpdir}" && mkdir -p "${tmpdir}"
  # copy content under DESTDIR root
  cp -a "${DESTDIR}/." "${tmpdir}/" || true
  if _has zstd; then
    tar -C "${tmpdir}" -cf - . | zstd -19 -T0 -o "${packdir}/${outname}.zst"
    adm_log OK "Empacotado: ${packdir}/${outname}.zst"
    printf "%s\n" "${packdir}/${outname}.zst"
  else
    tar -C "${tmpdir}" -cJf "${packdir}/${outname}.xz" .
    adm_log OK "Empacotado: ${packdir}/${outname}.xz"
    printf "%s\n" "${packdir}/${outname}.xz"
  fi
}

# register package via adm-db if available
register_package_db() {
  local name="$1"; local ver="$2"; local pkgfile="$3"
  if command -v adm-db >/dev/null 2>&1; then
    safe_exec "adm-db add ${name}" adm-db add --name "${name}" --version "${ver}" --file "${pkgfile}" --category "${CATEGORY}"
  else
    adm_log WARN "adm-db não disponível; não registrei ${name}"
  fi
}

# end of part 2
# adm-build — parte 3/3
set -euo pipefail
IFS=$'\n\t'

# top-level build orchestration
orchestrate_build() {
  local target="$1"   # metafile path or package id or source path
  local profile="${PROFILE:-default}"
  local use_chroot="${CHROOT_PATH:-}"
  # find metafile if target is package id
  local mf
  if find_metafile "${target}" >/dev/null 2>&1; then
    mf="$(find_metafile "${target}")"
  elif [ -f "${target}" ]; then
    mf="${target}"
  else
    mf=""
  fi

  if [ -n "${mf}" ]; then
    load_metafile "${mf}" || return 1
  else
    adm_log INFO "Sem metafile; chamando adm-detect para: ${target}"
    if command -v adm-detect >/dev/null 2>&1; then
      if [ "${ADM_DRYRUN}" -eq 1 ]; then
        adm_log INFO "[dry-run] adm-detect ${target}"
      else
        adm-detect "${target}" || adm_log WARN "adm-detect retornou erro"
        mf="$(find_metafile "${target}")" || mf=""
        if [ -n "${mf}" ]; then load_metafile "${mf}" || true; fi
      fi
    else
      adm_log WARN "adm-detect não disponível; tentando inferir"
      NAME="$(basename "${target}")"
      VERSION=""
      CATEGORY="misc"
      BUILD_SYSTEM=""
      DESTDIR="${ADM_DESTDIR}/${CATEGORY}/${NAME}"
    fi
  fi

  # prepare profile
  load_profile "${profile}"

  # create workdir and prepare source
  WORKDIR="${ADM_TEMP}/build-${NAME}-${VERSION:-unknown}"
  rm -rf "${WORKDIR}" || true
  mkdir -p "${WORKDIR}"
  if [ -n "${mf}" ]; then
    # if metafile provides URLS, prefer adm-download
    if [ -n "${URLS}" ] && command -v adm-download >/dev/null 2>&1; then
      adm_log INFO "Baixando via adm-download"
      if [ "${ADM_DRYRUN}" -eq 1 ]; then adm_log INFO "[dry-run] adm-download ${mf}"; else adm-download "${mf}" || adm_log ERR "adm-download falhou"; fi
      # try prepare_source from cache
      prepare_source "${mf}" "${WORKDIR}" || adm_log WARN "prepare_source falhou"
    else
      # if target is a tarball path, extract
      if [ -f "${target}" ]; then
        prepare_source "${target}" "${WORKDIR}" || return 1
      else
        # fallback: assume target is remote and adm-download not available
        adm_log ERR "Não consigo obter fonte: ${target}"
        return 1
      fi
    fi
  else
    # no metafile and no adm-detect -> try prepare_source on target
    prepare_source "${target}" "${WORKDIR}" || return 1
  fi

  # canonicalize top source dir if extraction created subdir
  local topdir
  topdir="$(find "${WORKDIR}" -maxdepth 1 -mindepth 1 -type d | head -n1 || true)"
  if [ -n "${topdir}" ]; then
    WORKDIR="${topdir}"
  fi
  adm_log INFO "Workdir final: ${WORKDIR}"

  # apply patches automatically (patches live in metafile dir)
  local mf_dir=""
  [ -n "${mf}" ] && mf_dir="$(dirname "${mf}")"
  apply_patches_auto "${mf_dir}" || adm_log WARN "apply_patches_auto retornou erro"

  # resume state
  local sf
  sf="$(state_file_for "${NAME}" "${VERSION}")"
  local last_stage=""
  if [ -f "${sf}" ]; then
    last_stage="$(sed -n '1p' "${sf}" || true)"
    adm_log INFO "Detectado estado anterior: ${last_stage}"
  fi

  # run pre-build hooks
  run_hooks_auto "${mf_dir}" pre-build || { adm_log ERR "pre-build hook falhou"; return 1; }

  # detect build system if needed
  auto_detect_build_system

  # build stages: configure/build/install
  if [ "${last_stage}" = "built" ]; then
    adm_log INFO "Stage de build já concluído (resuming install)"
  else
    save_state "${sf}" "building"
    # export profile flags
    export CFLAGS="${PROFILE_CFLAGS:-${CFLAGS:-}}"
    export CXXFLAGS="${PROFILE_CXXFLAGS:-${CXXFLAGS:-}}"
    export LDFLAGS="${PROFILE_LDFLAGS:-${LDFLAGS:-}}"
    # run resolver to ensure build deps installed or queued
    if command -v adm-resolver >/dev/null 2>&1; then
      adm_log INFO "Invocando adm-resolver para dependências"
      if [ "${ADM_DRYRUN}" -eq 1 ]; then adm_log INFO "[dry-run] adm-resolver ${NAME}" ; else adm-resolver "${NAME}" || adm_log WARN "adm-resolver retornou erro" ; fi
    fi

    # if bootstrap mode requested, ensure bootstrap toolchain is available
    if [ "${BOOTSTRAP_MODE:-0}" -eq 1 ]; then
      if command -v adm-bootstrap >/dev/null 2>&1; then
        adm_log INFO "Bootstrap mode: invocando adm-bootstrap (se necessário)"
        [ "${ADM_DRYRUN}" -eq 1 ] && adm_log INFO "[dry-run] adm-bootstrap" || adm-bootstrap || adm_log WARN "adm-bootstrap retornou erro"
      else
        adm_log WARN "adm-bootstrap não disponível; continuando sem bootstrap"
      fi
    fi

    # Enter chroot if requested
    if [ -n "${CHROOT_PATH:-}" ]; then
      adm_log INFO "Usando chroot: ${CHROOT_PATH}"
      # create destdir inside chroot or bind-mount as needed — we delegate to adm-chroot if available
      # Danger: mounting must be done carefully. Commented for safety but left ready.
      # NOTE: operações de montagem podem afetar o host se feitas incorretamente — garantir permissões.
      # shellcheck disable=SC2086
      # if [ "${ADM_DRYRUN}" -eq 0 ]; then
      #   ${SCRIPTS_DIR}/adm-chroot create "${CHROOT_PATH}"
      # fi
      # For now run build commands via in_chroot_run wrapper
    fi

    # run builder
    if ! run_builder; then
      adm_log ERR "Build falhou"
      save_state "${sf}" "failed"
      return 1
    fi
    save_state "${sf}" "built"
  fi

  # run post-build hooks
  run_hooks_auto "${mf_dir}" post-build || adm_log WARN "post-build hooks falharam"

  # Register and package
  local pkgfile
  pkgfile="$(package_result "${NAME}" "${VERSION}" || true)"
  if [ -n "${pkgfile}" ]; then
    register_package_db "${NAME}" "${VERSION}" "${pkgfile}" || true
  fi

  # run pre-install hooks
  run_hooks_auto "${mf_dir}" pre-install || adm_log WARN "pre-install hooks falharam"

  # perform install to final location (if user requested adm-install flow, maybe different)
  # Here we consider that "installation" for a package build means copying from DESTDIR to system via adm-install
  if [ "${ADM_DRYRUN}" -eq 1 ]; then
    adm_log INFO "[dry-run] install from ${DESTDIR}"
  else
    if command -v adm-install >/dev/null 2>&1; then
      adm_log INFO "Chamando adm-install para registrar/instalar ${NAME}"
      adm-install install "${pkgfile}" || adm_log WARN "adm-install retornou erro"
    else
      # fallback: copy to / (dangerous) — commented; user must use adm-install to push to system.
      adm_log WARN "adm-install não disponível; pacote empacotado em ${pkgfile}"
    fi
  fi

  # run post-install hooks
  run_hooks_auto "${mf_dir}" post-install || adm_log WARN "post-install hooks falharam"

  save_state "${sf}" "done"
  adm_log OK "Build orquestrado concluído: ${NAME}-${VERSION}"
  return 0
}

# CLI parsing
print_help() {
  cat <<EOF
adm-build — orquestrador automático
Uso:
  adm-build build <metafile|pkgid|source> [--category <cat>] [--profile <profile>] [--chroot <path>] [--bootstrap]
  adm-build resume <name> <version>
  adm-build clean <name> <version>
  adm-build status <name> <version>
Flags globais:
  --no-dry-run  (ou ADM_DRYRUN=0)
  --force
  --jobs N
EOF
}

# parse basic args
if [ $# -lt 1 ]; then print_help; exit 1; fi
CMD="$1"; shift || true

case "${CMD}" in
  build)
    TARGET="$1"; shift || { adm_log ERR "Especifique target"; exit 1; }
    # options
    PROFILE="default"; CHROOT_PATH=""; BOOTSTRAP_MODE=0
    while [ $# -gt 0 ]; do
      case "$1" in
        --profile) PROFILE="$2"; shift 2 ;;
        --chroot) CHROOT_PATH="$2"; shift 2 ;;
        --bootstrap) BOOTSTRAP_MODE=1; shift ;;
        --no-dry-run) ADM_DRYRUN=0; shift ;;
        --force) ADM_FORCE=1; shift ;;
        --jobs) ADM_JOBS="$2"; shift 2 ;;
        *) shift ;;
      esac
    done
    PROFILE="${PROFILE:-default}"
    orchestrate_build "${TARGET}"
    ;;
  resume)
    NAME="$1"; VERSION="$2"
    sf="$(state_file_for "${NAME}" "${VERSION}")"
    if [ -f "${sf}" ]; then
      adm_log INFO "Estado: $(sed -n '1p' "${sf}")"
    else
      adm_log INFO "Nenhum estado encontrado para ${NAME}-${VERSION}"
    fi
    ;;
  clean)
    NAME="$1"; VERSION="$2"
    sf="$(state_file_for "${NAME}" "${VERSION}")"
    rm -f "${sf}" 2>/dev/null || true
    adm_log OK "Estado limpo para ${NAME}-${VERSION}"
    ;;
  status)
    NAME="$1"; VERSION="$2"
    sf="$(state_file_for "${NAME}" "${VERSION}")"
    [ -f "${sf}" ] && adm_log INFO "Status: $(sed -n '1p' "${sf}")" || adm_log INFO "Sem estado"
    ;;
  *)
    print_help; exit 1 ;;
esac

# cleanup
stop_spinner 2>/dev/null || true
exit 0
