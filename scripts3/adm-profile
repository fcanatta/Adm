#!/usr/bin/env bash
#
# adm-profile - Gerenciador de perfis e setup inicial para o sistema ADM
#
# Local sugerido: /usr/src/adm/bin/adm-profile
# Requisitos: bash, coreutils (mkdir, chmod, cp, mv), sha256sum, grep, awk, sed, gcc (para check), make
#
# Objetivo:
#  - Criar a estrutura inicial /usr/src/adm (idempotente)
#  - Gerenciar perfis: safe, normal, aggressive, custom/*
#  - set/list/show/current/export-env/check/reset
#  - Tratar erros explicitamente, logs e DB JSONL
#
set -euo pipefail

### ----------------------
### Configuração padrão
### ----------------------
ADM_ROOT="${ADM_ROOT:-/usr/src/adm}"
ADM_BIN="${ADM_ROOT}/bin"
ADM_LOG="${ADM_ROOT}/logs"
ADM_DB="${ADM_ROOT}/db"
ADM_PROFILES="${ADM_ROOT}/profiles"
ADM_CACHE="${ADM_ROOT}/cache"
ADM_WORK="${ADM_ROOT}/work"
ADM_HOOKS="${ADM_ROOT}/hooks"
PROFILE_CONF="${ADM_DB}/profile.conf"         # shell key=value file
PROFILE_JSONL="${ADM_DB}/profile.jsonl"       # events of profile changes
DEFAULT_PROFILE="safe"
TIMESTAMP_FMT="%Y%m%d%H%M%S"

# exit codes
E_USAGE=1
E_MISSING=2
E_PERM=3
E_NO_PROFILE=4
E_INVALID_VAR=5
E_SETUP_FAIL=6
E_TOOLCHAIN=7
E_DB_WRITE=8

# defaults
DRY_RUN=false
FORCE=false
QUIET=false
VERBOSE=false
ROOT_OVERRIDE=""
LOGFILE=""
SAFE_MODE=true

# create safe umask for files we create
UMASK_PREV=$(umask)
umask 022

### ----------------------
### Helpers: logging & JSON
### ----------------------
_noc="$(tput sgr0 2>/dev/null || true)"
_red="$(tput setaf 1 2>/dev/null || echo '')"
_grn="$(tput setaf 2 2>/dev/null || echo '')"
_yel="$(tput setaf 3 2>/dev/null || echo '')"
_blu="$(tput setaf 4 2>/dev/null || echo '')"

cecho() { local color="$1"; shift; if $QUIET; then return 0; printf "%b%s%b\n" "$color" "$*" "$_noc"; }
info()  { cecho "$_blu" "[INFO] $*"; }
ok()    { cecho "$_grn" "✔️  $*"; }
warn()  { cecho "$_yel" "⚠️  $*"; }
error() { cecho "$_red" "✖️  $*"; }

timestamp() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }
ts_short()  { date +"$TIMESTAMP_FMT"; }

logfile_for() {
  local name="$1"
  printf "%s/adm-profile-%s-%s.log" "${ADM_LOG}" "${name}" "$(ts_short)"
}

# JSON-escape minimal (backslash and quote + newline removal)
json_escape() {
  local s="$1"
  s="${s//\\/\\\\}"
  s="${s//\"/\\\"}"
  s="${s//$'\r'/}"
  s="${s//$'\n'/\\n}"
  printf "%s" "$s"
}
# append JSON line to profile.jsonl
db_append_profile() {
  local json="$1"
  if $DRY_RUN; then
    info "DRY-RUN: would append to ${PROFILE_JSONL}: $json"
    return 0
  fi
  if ! printf "%s\n" "$json" >> "$PROFILE_JSONL"; then
    error "Falha ao gravar em $PROFILE_JSONL"
    exit $E_DB_WRITE
  fi
}

# sanity: ensure basic binaries exist when needed
require_bin() {
  for b in "$@"; do
    if ! command -v "$b" >/dev/null 2>&1; then
      error "Binário obrigatório não encontrado: $b"
      return 1
    fi
  done
  return 0
}

# safe write text to file (atomic)
safe_write_file() {
  local path="$1"; local content="$2"
  local dir
  dir="$(dirname "$path")"
  mkdir -p "$dir"
  if $DRY_RUN; then
    info "DRY-RUN: would write file $path"
    return 0
  fi
  local tmp
  tmp="$(mktemp "${dir}/.tmp.XXXXXXXX")"
  printf "%s\n" "$content" > "$tmp"
  chmod 0644 "$tmp"
  mv "$tmp" "$path"
}

# compute sha256 if available
file_sha256() {
  local f="$1"
  if [ -f "$f" ] && command -v sha256sum >/dev/null 2>&1; then
    sha256sum "$f" | awk '{print $1}'
  else
    echo ""
  fi
}

# confirm interactive unless force
confirm_action() {
  local prompt="$1"
  if $FORCE; then
    info "--force fornecido, pulando confirmação"
    return 0
  fi
  read -r -p "$prompt [type YES to continue]: " ans
  if [ "$ans" != "YES" ]; then
    warn "Confirmação não fornecida, abortando."
    return 1
  fi
  return 0
}

### ----------------------
### CLI usage
### ----------------------
usage() {
  cat <<EOF
adm-profile - Gerenciador de perfis e setup inicial do ADM

Uso:
  adm-profile [opções] <comando> [args...]

Comandos:
  setup [--root <path>]        Cria estrutura inicial (idempotente)
  list                        Lista perfis disponíveis
  show <perfil>               Mostra conteúdo do perfil
  set <perfil>                Define/ativa um perfil (grava profile.conf)
  current                     Mostra perfil ativo
  export-env                  Imprime comandos "export" para o perfil ativo (shell-safe)
  check                       Valida perfil atual e toolchain mínima
  reset                       Reset para perfil 'safe'
  help                        Mostra esta ajuda

Opções:
  -n, --dry-run               Simula as ações (não grava)
  -f, --force                 Força operações sem pedir confirmação
  -q, --quiet                 Saída mínima
  -v, --verbose               Verbose
  --root <path>               Use alternative ADM_ROOT for this invocation
  -h, --help                  Ajuda
EOF
}

### ----------------------
### Parse args
### ----------------------
POSITIONAL=()
while [ $# -gt 0 ]; do
  case "$1" in
    setup|list|show|set|current|export-env|check|reset|help) COMMAND="$1"; shift; break;;
    -n|--dry-run) DRY_RUN=true; shift;;
    -f|--force) FORCE=true; shift;;
    -q|--quiet) QUIET=true; shift;;
    -v|--verbose) VERBOSE=true; shift;;
    --root) ROOT_OVERRIDE="$2"; shift 2;;
    -h|--help) usage; exit 0;;
    *) POSITIONAL+=("$1"); shift;;
  esac
done

# collect rest args
REST_ARGS=("$@")
# if a root override was specified, change ADM_ROOT for this run
if [ -n "$ROOT_OVERRIDE" ]; then
  ADM_ROOT="$ROOT_OVERRIDE"
  ADM_BIN="${ADM_ROOT}/bin"
  ADM_LOG="${ADM_ROOT}/logs"
  ADM_DB="${ADM_ROOT}/db"
  ADM_PROFILES="${ADM_ROOT}/profiles"
  ADM_CACHE="${ADM_ROOT}/cache"
  ADM_WORK="${ADM_ROOT}/work"
  PROFILE_CONF="${ADM_DB}/profile.conf"
  PROFILE_JSONL="${ADM_DB}/profile.jsonl"
fi

# Basic dir creation for logs/db to ensure logging from now on
mkdir -p "$ADM_LOG" "$ADM_DB" "$ADM_PROFILES" "$ADM_BIN" "$ADM_CACHE" "$ADM_WORK" "$ADM_HOOKS"
if [ $? -ne 0 ]; then
  error "Falha ao criar diretórios em $ADM_ROOT - verifique permissões."
  exit $E_PERM
fi

LOGFILE="$(logfile_for "${COMMAND:-run}")"
info "Log: $LOGFILE"

# ensure DB files exist (empty if absent)
: > "${PROFILE_JSONL}" 2>/dev/null || true

### ----------------------
### Profile internals
### ----------------------
# default profiles content (safe, normal, aggressive) - idempotent creation
default_profile_safe() {
  cat <<'EOF'
# PROFILE_NAME="safe"
# PROFILE_DESC="Modo seguro: recomendado para bootstrap/toolchain. Baixo paralelismo, sem LTO."
export PROFILE_NAME="safe"
export PROFILE_DESC="Modo seguro: recomendado para bootstrap/toolchain. Baixo paralelismo, sem LTO."
export MAKEFLAGS="-j1"
export CFLAGS="-O2 -pipe"
export CXXFLAGS="${CFLAGS}"
export LDFLAGS=""
export USE_LTO=0
export STRIP_BINARIES=0
export DEBUG_SYMBOLS=1
export SAFE_MODE=1
export BUILD_SANITIZE=0
EOF
}

default_profile_normal() {
  cat <<'EOF'
# PROFILE_NAME="normal"
# PROFILE_DESC="Modo equilibrado: desempenho estável com segurança."
export PROFILE_NAME="normal"
export PROFILE_DESC="Modo equilibrado: desempenho estável com segurança."
export MAKEFLAGS="-j$(nproc || echo 2)"
export CFLAGS="-O2 -pipe -march=native"
export CXXFLAGS="${CFLAGS}"
export LDFLAGS=""
export USE_LTO=0
export STRIP_BINARIES=1
export DEBUG_SYMBOLS=0
export SAFE_MODE=1
export BUILD_SANITIZE=0
EOF
}

default_profile_aggressive() {
  cat <<'EOF'
# PROFILE_NAME="aggressive"
# PROFILE_DESC="Máximo desempenho: LTO, O3, paralelismo máximo. Uso em sistemas estáveis."
export PROFILE_NAME="aggressive"
export PROFILE_DESC="Máximo desempenho: LTO, O3, paralelismo máximo. Uso em sistemas estáveis."
export MAKEFLAGS="-j$(nproc || echo 4)"
export CFLAGS="-O3 -march=native -mtune=native -pipe -flto"
export CXXFLAGS="${CFLAGS}"
export LDFLAGS="-flto"
export USE_LTO=1
export STRIP_BINARIES=1
export DEBUG_SYMBOLS=0
export SAFE_MODE=0
export BUILD_SANITIZE=0
EOF
}

# Create default profiles files if missing (idempotent)
create_default_profiles() {
  info "Criando perfis padrão em $ADM_PROFILES (se ausentes)"
  mkdir -p "$ADM_PROFILES" "$ADM_PROFILES/custom"
  # safe
  if [ ! -f "${ADM_PROFILES}/safe.profile" ]; then
    if $DRY_RUN; then info "DRY-RUN: would create ${ADM_PROFILES}/safe.profile"; else default_profile_safe > "${ADM_PROFILES}/safe.profile"; fi
  fi
  # normal
  if [ ! -f "${ADM_PROFILES}/normal.profile" ]; then
    if $DRY_RUN; then info "DRY-RUN: would create ${ADM_PROFILES}/normal.profile"; else default_profile_normal > "${ADM_PROFILES}/normal.profile"; fi
  fi
  # aggressive
  if [ ! -f "${ADM_PROFILES}/aggressive.profile" ]; then
    if $DRY_RUN; then info "DRY-RUN: would create ${ADM_PROFILES}/aggressive.profile"; else default_profile_aggressive > "${ADM_PROFILES}/aggressive.profile"; fi
  fi
  ok "Perfis padrão garantidos"
}

# ensure the full ADM layout (idempotent). Called by setup
ensure_layout() {
  info "Garantindo estrutura base em $ADM_ROOT"
  local -a dirs=( "$ADM_BIN" "$ADM_LOG" "$ADM_DB" "$ADM_PROFILES" "$ADM_CACHE/tarballs" "$ADM_CACHE/sources" "$ADM_WORK" "$ADM_HOOKS" "$ADM_ROOT/bootstrap" )
  for d in "${dirs[@]}"; do
    if [ ! -d "$d" ]; then
      if $DRY_RUN; then
        info "DRY-RUN: criar diretório $d"
      else
        mkdir -p "$d" || { error "Falha ao criar $d"; exit $E_SETUP_FAIL; }
        chmod 0755 "$d" || true
      fi
    fi
  done
  ok "Estrutura verificada"
}

# read current profile.conf (key=value)
read_profile_conf() {
  if [ -f "$PROFILE_CONF" ]; then
    # shellcheck disable=SC1090
    # source safely: only read lines matching KEY="value" or KEY=value
    while IFS= read -r line || [ -n "$line" ]; do
      # strip comments and whitespace
      line="${line%%#*}"
      line="${line%"${line##*[![:space:]]}"}"
      line="${line#"${line%%[![:space:]]*}"}"
      [ -z "$line" ] && continue
      if [[ "$line" =~ ^([A-Z_][A-Z0-9_]*)=(.*)$ ]]; then
        k="${BASH_REMATCH[1]}"
        v="${BASH_REMATCH[2]}"
        # remove optional surrounding quotes
        if [[ "$v" =~ ^\".*\"$ ]]; then v="${v#\"}"; v="${v%\"}"; fi
        case "$k" in
          ACTIVE_PROFILE) ACTIVE_PROFILE="$v" ;;
          LAST_SET) LAST_SET="$v" ;;
        esac
      fi
    done < "$PROFILE_CONF"
  else
    ACTIVE_PROFILE=""
    LAST_SET=""
  fi
}

# write profile.conf atomically
write_profile_conf() {
  local profile="$1"
  local ts="$2"
  local content="ACTIVE_PROFILE=\"$profile\"\nLAST_SET=\"$ts\""
  if $DRY_RUN; then
    info "DRY-RUN: would write $PROFILE_CONF"
    return 0
  fi
  mkdir -p "$(dirname "$PROFILE_CONF")"
  safe_write_file "$PROFILE_CONF" "$content"
  if [ ! -f "$PROFILE_CONF" ]; then
    error "Falha ao gravar $PROFILE_CONF"
    exit $E_DB_WRITE
  fi
}

# display list of profiles with one-line description
list_profiles() {
  create_default_profiles
  info "Perfis disponíveis em $ADM_PROFILES:"
  local p
  for p in "${ADM_PROFILES}"/*.profile "${ADM_PROFILES}"/custom/*.profile; do
    [ -e "$p" ] || continue
    # read first non-empty comment or PROFILE_DESC
    desc="$(grep -E '^#|^export PROFILE_DESC' "$p" | head -n1 || true)"
    desc="${desc#\# }"
    desc="${desc#export PROFILE_DESC=}"
    desc="$(echo "$desc" | sed -e 's/^"\(.*\)"$/\1/')"
    printf "%-18s - %s\n" "$(basename "$p")" "${desc:-(no description)}"
  done
}

# show profile file content
show_profile() {
  local prof="$1"
  local file
  file="$(profile_path "$prof")"
  if [ ! -f "$file" ]; then
    error "Perfil não encontrado: $prof (esperado em $file)"
    exit $E_NO_PROFILE
  fi
  info "Conteúdo de $file:"
  sed -n '1,200p' "$file"
}

# resolve profile path from name
profile_path() {
  local prof="$1"
  # allow passing with or without .profile, and custom/
  if [ -f "${ADM_PROFILES}/${prof}.profile" ]; then
    printf "%s" "${ADM_PROFILES}/${prof}.profile"
  elif [ -f "${ADM_PROFILES}/${prof}" ]; then
    printf "%s" "${ADM_PROFILES}/${prof}"
  elif [ -f "${ADM_PROFILES}/custom/${prof}.profile" ]; then
    printf "%s" "${ADM_PROFILES}/custom/${prof}.profile"
  elif [ -f "${ADM_PROFILES}/${prof}" ]; then
    printf "%s" "${ADM_PROFILES}/${prof}"
  else
    # try direct path
    printf "%s" "${prof}"
  fi
}

# validate profile variables after sourcing; ensures required vars present and sane
validate_profile_vars() {
  # expect MAKEFLAGS, CFLAGS, CXXFLAGS, LDFLAGS present at least (may be empty)
  local missing=()
  local required=(MAKEFLAGS CFLAGS CXXFLAGS LDFLAGS)
  for k in "${required[@]}"; do
    if ! env | grep -q "^${k}="; then
      missing+=("$k")
    fi
  done
  if [ ${#missing[@]} -ne 0 ]; then
    error "Perfil inválido: variáveis obrigatórias ausentes: ${missing[*]}"
    return 1
  fi
  # basic validation: ensure MAKEFLAGS doesn't contain dangerous chars
  if env | grep -q "^MAKEFLAGS=.*[;&|`]\|.*\$\(.*\)"; then
    error "MAKEFLAGS parece conter caracteres inseguros"
    return 1
  fi
  return 0
}

# set profile (activate)
set_profile() {
  local prof="$1"
  local prof_file
  prof_file="$(profile_path "$prof")"
  if [ ! -f "$prof_file" ]; then
    error "Perfil não encontrado: $prof (procure em ${ADM_PROFILES})"
    exit $E_NO_PROFILE
  fi

  # source in subshell to capture environment without polluting current shell except allowed exports
  local tmp
  tmp="$(mktemp)"
  # run in subshell to collect exported vars
  if $DRY_RUN; then
    info "DRY-RUN: would set profile $prof from $prof_file"
  else
    # create backup of existing profile.conf
    if [ -f "$PROFILE_CONF" ]; then
      cp -a "$PROFILE_CONF" "${PROFILE_CONF}.old" || warn "Não foi possível criar backup ${PROFILE_CONF}.old"
    fi
  fi

  # Use a subshell: source the profile and print exports we accept
  (
    set -euo pipefail
    # unset possibly dangerous variables before sourcing
    unset LD_PRELOAD LD_LIBRARY_PATH LD_AUDIT IFS
    # shellcheck disable=SC1090
    source "$prof_file"
    # ensure the expected vars are present (if not, set empty)
    : "${MAKEFLAGS:=}"
    : "${CFLAGS:=}"
    : "${CXXFLAGS:=}"
    : "${LDFLAGS:=}"
    : "${USE_LTO:=0}"
    : "${STRIP_BINARIES:=0}"
    : "${DEBUG_SYMBOLS:=0}"
    : "${SAFE_MODE:=0}"
    : "${BUILD_SANITIZE:=0}"
    : "${PROFILE_NAME:=${prof}}"
    : "${PROFILE_DESC:=}"
    # output as KEY=VALUE lines to tmp
    cat <<EOT > "$tmp"
MAKEFLAGS='${MAKEFLAGS}'
CFLAGS='${CFLAGS}'
CXXFLAGS='${CXXFLAGS}'
LDFLAGS='${LDFLAGS}'
USE_LTO='${USE_LTO}'
STRIP_BINARIES='${STRIP_BINARIES}'
DEBUG_SYMBOLS='${DEBUG_SYMBOLS}'
SAFE_MODE='${SAFE_MODE}'
BUILD_SANITIZE='${BUILD_SANITIZE}'
PROFILE_NAME='${PROFILE_NAME}'
PROFILE_DESC='${PROFILE_DESC}'
EOT
  )

  # read tmp into environment (but do not export to parent shell; we will write conf)
  # validate contents
  # sanity parse
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ ! "$line" =~ ^[A-Za-z0-9_]+= ]]; then
      error "Perfil contém linha inválida: $line"
      rm -f "$tmp"
      exit $E_INVALID_VAR
    fi
  done < "$tmp"

  # validate minimal variables (we'll check presence)
  # source tmp into env for validation (use subshell)
  if ! ( set -euo pipefail; source "$tmp"; validate_profile_vars ); then
    rm -f "$tmp"
    error "Validação do perfil falhou"
    exit $E_INVALID_VAR
  fi

  # compute checksum of profile file for record
  local sha
  sha="$(file_sha256 "$prof_file" || true)"

  local now
  now="$(timestamp)"

  # write profile.conf (ACTIVE_PROFILE and LAST_SET)
  if ! $DRY_RUN; then
    write_profile_conf "$prof" "$now"
    # write event JSONL
    local content
    content="$(printf '{"timestamp":"%s","profile":"%s","action":"set","profile_path":"%s","sha256":"%s"}' "$(json_escape "$now")" "$(json_escape "$prof")" "$(json_escape "$prof_file")" "$(json_escape "$sha")")"
    db_append_profile "$content"
  else
    info "DRY-RUN: profile.conf would be written with ACTIVE_PROFILE=$prof"
  fi

  # Optionally export ENV to a file for other scripts to source (e.g., $ADM_DB/profile.env)
  local envfile="${ADM_DB}/profile.env"
  if $DRY_RUN; then
    info "DRY-RUN: would generate $envfile"
  else
    # write sanitized exports
    # read tmp and produce export lines
    {
      echo "# Generated by adm-profile on $(timestamp)"
      while IFS= read -r ln || [ -n "$ln" ]; do
        # ln is like VAR='value'
        var="${ln%%=*}"
        val="${ln#*=}"
        # remove surrounding single quotes if present
        val="${val#\'}"; val="${val%\'}"
        # sanitize: remove dangerous characters ; & | ` $()
        val_sanitized="$(printf "%s" "$val" | sed "s/[;&|\\\`\\\$<>]//g")"
        printf "export %s='%s'\n" "$var" "$(printf "%s" "$val_sanitized")"
      done < "$tmp"
    } > "${envfile}.tmp" && mv "${envfile}.tmp" "${envfile}"
    chmod 0644 "${envfile}"
    ok "Profile '$prof' ativado e export disponível em $envfile"
  fi

  rm -f "$tmp"
}

# show currently active profile
current_profile() {
  read_profile_conf
  if [ -z "${ACTIVE_PROFILE:-}" ]; then
    warn "Nenhum perfil ativo. Use 'adm-profile set <perfil>' para definir."
    return 1
  fi
  local prof="${ACTIVE_PROFILE}"
  local prof_file
  prof_file="$(profile_path "$prof")"
  info "Perfil atual: $prof"
  echo "  path: $prof_file"
  if [ -f "$PROFILE_CONF" ]; then
    echo "  last_set: ${LAST_SET:-unknown}"
  fi
  # if profile env exists, print summary
  if [ -f "${ADM_DB}/profile.env" ]; then
    echo "  exports: (summary)"
    grep -E '^(export )?(MAKEFLAGS|CFLAGS|CXXFLAGS|LDFLAGS|USE_LTO|STRIP_BINARIES|DEBUG_SYMBOLS)' "${ADM_DB}/profile.env" || true
  fi
}

# export-env: print "export ..." lines to stdout for eval
export_env() {
  read_profile_conf
  if [ -z "${ACTIVE_PROFILE:-}" ]; then
    error "Nenhum perfil ativo para exportar"
    exit $E_NO_PROFILE
  fi
  local envfile="${ADM_DB}/profile.env"
  if [ ! -f "$envfile" ]; then
    warn "Arquivo de ambiente não encontrado ($envfile). Aplicando o perfil para gerar."
    set_profile "$ACTIVE_PROFILE"
  fi
  # sanitize output: only export allowed vars
  awk '/^export /{print}' "$envfile" | sed -E 's/[^[:print:]\t]//g'
}

# perform basic checks: required tools and test compile
check_environment() {
  info "Checando ambiente e perfil ativo..."
  read_profile_conf
  local prof="${ACTIVE_PROFILE:-}"
  if [ -z "$prof" ]; then
    warn "Nenhum perfil ativo — resultado pode ser parcial"
  fi

  # check profile.env exists and source it in subshell
  local envfile="${ADM_DB}/profile.env"
  if [ ! -f "$envfile" ]; then
    error "profile.env não encontrado; ative um perfil com 'adm-profile set <perfil>'"
    return 5
  fi

  # check tools
  local missing_tools=()
  for t in gcc g++ make ld; do
    if ! command -v "$t" >/dev/null 2>&1; then
      missing_tools+=("$t")
    fi
  done
  if [ ${#missing_tools[@]} -gt 0 ]; then
    warn "Ferramentas ausentes: ${missing_tools[*]}"
    return $E_TOOLCHAIN
  fi

  # test compile simple program
  local tmpc tempbin
  tmpc="$(mktemp /tmp/admtst.XXXX.c)"
  tempbin="$(mktemp /tmp/admbin.XXXX)"
  cat > "$tmpc" <<'EOF'
int main(void){return 0;}
EOF
  # source env and compile in subshell
  if ( set -euo pipefail; source "$envfile"; gcc $CFLAGS -o "$tempbin" "$tmpc" >/dev/null 2>&1 ); then
    ok "Compilador funcionando com CFLAGS configurado"
    rm -f "$tmpc" "$tempbin"
    return 0
  else
    warn "Compilação de teste falhou (verifique CFLAGS/MACHINEFLAGS/TOOLCHAIN)"
    rm -f "$tmpc" || true
    rm -f "$tempbin" || true
    return 6
  fi
}

# reset to safe profile
reset_profile() {
  info "Resetando perfil para 'safe'"
  create_default_profiles
  if ! profile_path "safe" >/dev/null 2>&1; then
    error "Perfil safe não encontrado após criação"
    exit $E_NO_PROFILE
  fi
  if ! $FORCE; then
    confirm_action "Confirm reset profile to 'safe'?" || exit 1
  fi
  set_profile "safe"
  ok "Perfil resetado para safe"
}

### ----------------------
### Setup entrypoint
### ----------------------
adm_setup() {
  info "Executando adm-setup em $ADM_ROOT"
  # validate writability
  if [ -e "$ADM_ROOT" ] && [ ! -w "$ADM_ROOT" ]; then
    error "ADM_ROOT ($ADM_ROOT) existe mas não é gravável pelo usuário atual. Verifique permissões."
    exit $E_PERM
  fi

  ensure_layout
  create_default_profiles

  # create DB JSONL skeletons if missing
  : > "${PROFILE_JSONL}" 2>/dev/null || true
  : > "${ADM_DB}/installed.jsonl" 2>/dev/null || true
  : > "${ADM_DB}/hooks.jsonl" 2>/dev/null || true
  : > "${ADM_DB}/patches.jsonl" 2>/dev/null || true

  # create a minimal profile.conf if missing
  if [ ! -f "$PROFILE_CONF" ]; then
    if $DRY_RUN; then
      info "DRY-RUN: would initialize profile.conf with ACTIVE_PROFILE=$DEFAULT_PROFILE"
    else
      now="$(timestamp)"
      write_profile_conf "$DEFAULT_PROFILE" "$now"
      db_append_profile "$(printf '{"timestamp":"%s","profile":"%s","action":"init"}' "$(json_escape "$now")" "$(json_escape "$DEFAULT_PROFILE")")"
      ok "Profile.conf inicializado com perfil '$DEFAULT_PROFILE'"
    fi
  else
    info "profile.conf já existe; ignorando inicialização"
  fi

  ok "adm-setup concluído"
}

### ----------------------
### MAIN command dispatch
### ----------------------
case "${COMMAND:-help}" in
  setup)
    # allow passing --root <path> via earlier parsing (ROOT_OVERRIDE)
    adm_setup
    ;;

  list)
    list_profiles
    ;;

  show)
    if [ ${#REST_ARGS[@]} -lt 1 ]; then
      error "Uso: adm-profile show <perfil>"
      exit $E_USAGE
    fi
    show_profile "${REST_ARGS[0]}"
    ;;

  set)
    if [ ${#REST_ARGS[@]} -lt 1 ]; then
      error "Uso: adm-profile set <perfil>"
      exit $E_USAGE
    fi
    create_default_profiles
    set_profile "${REST_ARGS[0]}"
    ;;

  current)
    current_profile
    ;;

  "export-env")
    export_env
    ;;

  check)
    # ensure that profile.env exists if profile active; else instruct user
    read_profile_conf
    if [ -z "${ACTIVE_PROFILE:-}" ]; then
      warn "Nenhum perfil ativo; execute 'adm-profile set <perfil>' ou 'adm-profile setup'"
      exit 1
    fi
    check_environment
    rc=$?
    if [ $rc -eq 0 ]; then ok "Check OK"; else warn "Check returned code $rc"; fi
    exit $rc
    ;;

  reset)
    reset_profile
    ;;

  help|*)
    usage
    ;;
esac

# restore umask
umask "$UMASK_PREV"
exit 0
